<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CNN-LSTM Multi-Task Konfiguration - KI Trading Model</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 50%, #16213e 100%);
            color: #e8e8e8;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1.5rem;
        }

        header {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1rem 0;
            margin-bottom: 1.5rem;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        header .container {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #64c8ff;
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .back-link:hover {
            color: #fff;
        }

        .header-title {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .service-badge {
            background: rgba(167, 139, 250, 0.2);
            color: #a78bfa;
            padding: 0.3rem 0.8rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .service-badge.train {
            background: rgba(255, 152, 0, 0.2);
            color: #ffb74d;
        }

        /* Card */
        .card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 1.5rem;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .card-title {
            font-size: 1.2rem;
            color: #64c8ff;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .card-description {
            color: #888;
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 600;
            color: #64c8ff;
        }

        .stat-value.success { color: #81c784; }
        .stat-value.warning { color: #ffb74d; }
        .stat-value.error { color: #e57373; }
        .stat-value.purple { color: #a78bfa; }

        .stat-label {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-top: 0.25rem;
        }

        /* Buttons */
        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            font-size: 0.85rem;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
        }

        .btn-primary {
            background: rgba(100, 200, 255, 0.2);
            color: #64c8ff;
            border: 1px solid rgba(100, 200, 255, 0.3);
        }

        .btn-primary:hover {
            background: rgba(100, 200, 255, 0.3);
        }

        .btn-success {
            background: rgba(76, 175, 80, 0.2);
            color: #81c784;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .btn-success:hover {
            background: rgba(76, 175, 80, 0.3);
        }

        .btn-danger {
            background: rgba(244, 67, 54, 0.2);
            color: #e57373;
            border: 1px solid rgba(244, 67, 54, 0.3);
        }

        .btn-danger:hover {
            background: rgba(244, 67, 54, 0.3);
        }

        .btn-warning {
            background: rgba(255, 152, 0, 0.2);
            color: #ffb74d;
            border: 1px solid rgba(255, 152, 0, 0.3);
        }

        .btn-warning:hover {
            background: rgba(255, 152, 0, 0.3);
        }

        .btn-purple {
            background: rgba(167, 139, 250, 0.2);
            color: #a78bfa;
            border: 1px solid rgba(167, 139, 250, 0.3);
        }

        .btn-purple:hover {
            background: rgba(167, 139, 250, 0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Progress Bar */
        .progress-container {
            display: none;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
            border: 1px solid rgba(100, 200, 255, 0.2);
        }

        .progress-container.active {
            display: block;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .progress-title {
            font-size: 0.9rem;
            color: #64c8ff;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .progress-title .spinner-small {
            width: 16px;
            height: 16px;
            border: 2px solid rgba(100, 200, 255, 0.3);
            border-top-color: #64c8ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .progress-stats {
            font-size: 0.8rem;
            color: #888;
        }

        .progress-bar-outer {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            height: 8px;
            overflow: hidden;
        }

        .progress-bar-inner {
            height: 100%;
            background: linear-gradient(90deg, #64c8ff, #81c784);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .progress-details {
            display: flex;
            justify-content: space-between;
            margin-top: 0.5rem;
            font-size: 0.75rem;
            color: #888;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: #1a1a2e;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-title {
            font-size: 1.2rem;
            color: #64c8ff;
        }

        .modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem;
            line-height: 1;
        }

        .modal-close:hover {
            color: #e57373;
        }

        .modal-body {
            padding: 1.5rem;
            overflow-y: auto;
            flex: 1;
        }

        .modal-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
        }

        .symbol-set-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .symbol-set-item.editing {
            border-color: #64c8ff;
        }

        .symbol-set-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .symbol-set-name {
            font-weight: 600;
            color: #64c8ff;
        }

        .symbol-set-symbols {
            font-size: 0.85rem;
            color: #888;
            word-break: break-all;
        }

        .symbol-set-input {
            width: 100%;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: #e8e8e8;
            font-size: 0.85rem;
            margin-top: 0.5rem;
        }

        .btn-group {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 0;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .tab {
            padding: 0.75rem 1.5rem;
            background: transparent;
            border: none;
            color: #888;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.2s;
            border-bottom: 2px solid transparent;
            margin-bottom: -1px;
        }

        .tab:hover {
            color: #64c8ff;
            background: rgba(100, 200, 255, 0.05);
        }

        .tab.active {
            color: #64c8ff;
            border-bottom-color: #64c8ff;
            background: rgba(100, 200, 255, 0.1);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Prediction Grid */
        .prediction-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 1.5rem;
        }

        .prediction-card {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 1.25rem;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .prediction-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .prediction-card-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #a78bfa;
        }

        .prediction-badge {
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
        }

        .prediction-badge.bullish {
            background: rgba(76, 175, 80, 0.2);
            color: #81c784;
        }

        .prediction-badge.bearish {
            background: rgba(244, 67, 54, 0.2);
            color: #e57373;
        }

        .prediction-badge.neutral {
            background: rgba(255, 152, 0, 0.2);
            color: #ffb74d;
        }

        /* Price Forecasts */
        .price-forecasts {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .forecast-item {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 0.75rem;
            text-align: center;
        }

        .forecast-label {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 0.25rem;
        }

        .forecast-value {
            font-size: 1rem;
            font-weight: 600;
            color: #64c8ff;
        }

        .forecast-change {
            font-size: 0.75rem;
            margin-top: 0.25rem;
        }

        .forecast-change.positive { color: #81c784; }
        .forecast-change.negative { color: #e57373; }

        /* Patterns List */
        .patterns-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .pattern-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0.75rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
        }

        .pattern-name {
            font-weight: 500;
        }

        .pattern-confidence {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .confidence-bar {
            width: 60px;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }

        .confidence-fill {
            height: 100%;
            background: #a78bfa;
            border-radius: 3px;
            transition: width 0.3s;
        }

        .confidence-value {
            font-size: 0.8rem;
            color: #a78bfa;
            min-width: 40px;
            text-align: right;
        }

        /* Regime Display */
        .regime-display {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .regime-current {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .regime-icon {
            font-size: 2rem;
        }

        .regime-info {
            flex: 1;
        }

        .regime-name {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .regime-probability {
            font-size: 0.85rem;
            color: #888;
        }

        .regime-transitions {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
        }

        .transition-item {
            text-align: center;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
        }

        .transition-label {
            font-size: 0.65rem;
            color: #888;
            margin-bottom: 0.25rem;
        }

        .transition-value {
            font-size: 0.9rem;
            font-weight: 600;
        }

        /* Symbol Input */
        .symbol-input-group {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .symbol-input {
            flex: 1;
            padding: 0.6rem 1rem;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            font-size: 0.95rem;
        }

        .symbol-input:focus {
            outline: none;
            border-color: #64c8ff;
        }

        .timeframe-select {
            padding: 0.6rem 1rem;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            font-size: 0.95rem;
            cursor: pointer;
        }

        .timeframe-select option {
            background: #1a1a2e;
        }

        .symbol-select {
            padding: 0.6rem 1rem;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            font-size: 0.95rem;
            cursor: pointer;
        }

        .symbol-select option {
            background: #1a1a2e;
        }

        .symbol-select optgroup {
            background: #1a1a2e;
            color: #64c8ff;
            font-weight: 600;
        }

        /* Model Info */
        .model-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .model-info-item {
            display: flex;
            justify-content: space-between;
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
        }

        .model-info-label {
            color: #888;
        }

        .model-info-value {
            color: #64c8ff;
            font-weight: 500;
        }

        /* Training Status */
        .training-status {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .status-indicator.idle { background: #888; }
        .status-indicator.running { background: #81c784; animation: pulse 2s infinite; }
        .status-indicator.error { background: #e57373; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Training Form */
        .training-form {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
        }

        .form-label {
            font-size: 0.85rem;
            color: #888;
        }

        .form-input, .form-select {
            padding: 0.6rem;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            font-size: 0.9rem;
        }

        .form-input:focus, .form-select:focus {
            outline: none;
            border-color: #64c8ff;
        }

        .form-select option {
            background: #1a1a2e;
        }

        /* Feature Table */
        .feature-table {
            width: 100%;
            border-collapse: collapse;
        }

        .feature-table th,
        .feature-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }

        .feature-table th {
            color: #64c8ff;
            font-weight: 600;
            font-size: 0.85rem;
            text-transform: uppercase;
        }

        .feature-table tr:hover {
            background: rgba(100, 200, 255, 0.05);
        }

        .feature-category {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .feature-category.ohlcv { background: rgba(76, 175, 80, 0.2); color: #81c784; }
        .feature-category.returns { background: rgba(33, 150, 243, 0.2); color: #64b5f6; }
        .feature-category.trend { background: rgba(255, 152, 0, 0.2); color: #ffb74d; }
        .feature-category.momentum { background: rgba(156, 39, 176, 0.2); color: #ce93d8; }
        .feature-category.volatility { background: rgba(244, 67, 54, 0.2); color: #e57373; }
        .feature-category.volume { background: rgba(0, 150, 136, 0.2); color: #4db6ac; }
        .feature-category.position { background: rgba(63, 81, 181, 0.2); color: #7986cb; }
        .feature-category.meta { background: rgba(121, 85, 72, 0.2); color: #a1887f; }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            color: #fff;
            font-size: 0.9rem;
            z-index: 2000;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s;
        }

        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }

        .toast-success { background: #2e7d32; }
        .toast-error { background: #c62828; }
        .toast-info { background: #1565c0; }

        /* Loading */
        .loading {
            text-align: center;
            padding: 2rem;
            color: #888;
        }

        .spinner {
            display: inline-block;
            width: 30px;
            height: 30px;
            border: 3px solid rgba(100, 200, 255, 0.3);
            border-radius: 50%;
            border-top-color: #64c8ff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Recommendation Box */
        .recommendation-box {
            padding: 1rem;
            border-radius: 8px;
            margin-top: 1rem;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .recommendation-box.buy {
            background: rgba(76, 175, 80, 0.15);
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .recommendation-box.sell {
            background: rgba(244, 67, 54, 0.15);
            border: 1px solid rgba(244, 67, 54, 0.3);
        }

        .recommendation-box.hold {
            background: rgba(255, 152, 0, 0.15);
            border: 1px solid rgba(255, 152, 0, 0.3);
        }

        .recommendation-icon {
            font-size: 2rem;
        }

        .recommendation-info {
            flex: 1;
        }

        .recommendation-action {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .recommendation-score {
            font-size: 0.85rem;
            opacity: 0.8;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 3rem;
            color: #888;
        }

        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        /* Timeframe Table */
        .timeframe-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }

        .timeframe-table th,
        .timeframe-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }

        .timeframe-table th {
            background: rgba(0, 0, 0, 0.3);
            color: #64c8ff;
            font-weight: 600;
        }

        .quick-links {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-top: 1rem;
        }

        .quick-links a {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: rgba(100, 200, 255, 0.1);
            color: #64c8ff;
            border-radius: 6px;
            text-decoration: none;
            font-size: 0.85rem;
            transition: all 0.2s;
            border: 1px solid rgba(100, 200, 255, 0.2);
        }

        .quick-links a:hover {
            background: rgba(100, 200, 255, 0.2);
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <header>
        <div class="container" style="flex-direction: column; gap: 0.5rem;">
            <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                <a href="/index.html" class="back-link">&#8592; Dashboard</a>
                <h1 class="header-title">CNN-LSTM Multi-Task Konfiguration</h1>
                <span class="service-badge" id="serviceStatus">Laden...</span>
            </div>
            <!-- Compact Header Status Bar -->
            <div style="display: flex; gap: 1.5rem; align-items: center; flex-wrap: wrap; font-size: 0.85rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.1);">
                <div style="display: flex; align-items: center; gap: 0.4rem;" title="Service-Status">
                    <span>&#9889;</span>
                    <span style="color: #888;">Status:</span>
                    <strong id="headerStatus" style="color: #4caf50;">Lädt...</strong>
                </div>
                <div style="display: flex; align-items: center; gap: 0.4rem;" title="Modell-Version">
                    <span>&#129516;</span>
                    <span style="color: #888;">Version:</span>
                    <strong id="headerVersion" style="color: #a78bfa;">-</strong>
                </div>
                <div style="display: flex; align-items: center; gap: 0.4rem;" title="Multi-Task Outputs">
                    <span>&#127919;</span>
                    <span style="color: #888;">Tasks:</span>
                    <strong id="headerTasks" style="color: #64c8ff;">Price, Pattern, Regime</strong>
                </div>
                <div style="display: flex; align-items: center; gap: 0.4rem;" title="Input Features">
                    <span>&#128202;</span>
                    <span style="color: #888;">Features:</span>
                    <strong id="headerFeatures" style="color: #64c8ff;">25</strong>
                </div>
                <div style="display: flex; align-items: center; gap: 0.4rem;" title="Zeit seit Service-Start">
                    <span>&#128336;</span>
                    <span style="color: #888;">Uptime:</span>
                    <strong id="headerUptime" style="color: #64c8ff;">-</strong>
                </div>
                <button class="btn btn-primary btn-sm" onclick="updateHeaderStatus()" style="margin-left: auto; padding: 0.3rem 0.6rem; font-size: 0.8rem;">&#8635;</button>
            </div>
        </div>
    </header>

    <div class="container">
        <!-- Tabs -->
        <div class="tabs">
            <button class="tab active" onclick="switchTab('features')">&#128200; Übersicht</button>
            <button class="tab" onclick="switchTab('predictions')">&#127919; Live Predictions</button>
            <button class="tab" onclick="switchTab('revalidation')">&#128202; Revalidierung</button>
            <button class="tab" onclick="switchTab('training')">&#128203; Training</button>
            <button class="tab" onclick="switchTab('selflearning')">&#129302; Self-Learning</button>
        </div>

        <!-- Live Predictions Tab -->
        <div id="tab-predictions" class="tab-content">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">&#127919; Multi-Task Vorhersage</h2>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="loadPrediction()">&#128260; Aktualisieren</button>
                        <button class="btn btn-purple" onclick="loadAnalysis()">&#128202; Analyse</button>
                    </div>
                </div>
                <p class="card-description">
                    Kombinierte Vorhersage aus Preis-Forecast, Pattern-Erkennung und Regime-Klassifikation.
                </p>

                <div class="symbol-input-group">
                    <select class="symbol-select" id="prediction-symbol" style="min-width: 180px;">
                        <optgroup label="Krypto">
                            <option value="BTCUSD" selected>BTCUSD</option>
                            <option value="ETHUSD">ETHUSD</option>
                            <option value="XRPUSD">XRPUSD</option>
                            <option value="SOLUSD">SOLUSD</option>
                            <option value="ADAUSD">ADAUSD</option>
                            <option value="DOTUSD">DOTUSD</option>
                            <option value="LINKUSD">LINKUSD</option>
                            <option value="AVAXUSD">AVAXUSD</option>
                        </optgroup>
                        <optgroup label="Forex">
                            <option value="EURUSD">EURUSD</option>
                            <option value="GBPUSD">GBPUSD</option>
                            <option value="USDJPY">USDJPY</option>
                            <option value="USDCHF">USDCHF</option>
                            <option value="AUDUSD">AUDUSD</option>
                            <option value="USDCAD">USDCAD</option>
                            <option value="NZDUSD">NZDUSD</option>
                            <option value="EURGBP">EURGBP</option>
                        </optgroup>
                        <optgroup label="Aktien">
                            <option value="AAPL">AAPL</option>
                            <option value="MSFT">MSFT</option>
                            <option value="NVDA">NVDA</option>
                            <option value="GOOGL">GOOGL</option>
                            <option value="AMZN">AMZN</option>
                            <option value="META">META</option>
                            <option value="TSLA">TSLA</option>
                            <option value="AMD">AMD</option>
                        </optgroup>
                        <optgroup label="Indizes">
                            <option value="SPX">SPX (S&amp;P 500)</option>
                            <option value="NDX">NDX (Nasdaq 100)</option>
                            <option value="DJI">DJI (Dow Jones)</option>
                            <option value="DAX">DAX</option>
                        </optgroup>
                        <optgroup label="Rohstoffe">
                            <option value="XAUUSD">XAUUSD (Gold)</option>
                            <option value="XAGUSD">XAGUSD (Silber)</option>
                            <option value="WTIUSD">WTIUSD (Öl)</option>
                        </optgroup>
                    </select>
                    <select class="timeframe-select" id="prediction-timeframe">
                        <option value="M1">M1</option>
                        <option value="M5">M5</option>
                        <option value="M15">M15</option>
                        <option value="M30">M30</option>
                        <option value="H1" selected>H1</option>
                        <option value="H4">H4</option>
                        <option value="D1">D1</option>
                        <option value="W1">W1</option>
                        <option value="MN">MN</option>
                    </select>
                    <button class="btn btn-success" onclick="loadPrediction()">Vorhersage</button>
                </div>

                <div id="prediction-content">
                    <div class="empty-state">
                        <div class="empty-state-icon">&#129516;</div>
                        <p>Klicke auf "Vorhersage" um eine Multi-Task Prediction zu laden</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Revalidierung Tab -->
        <div id="tab-revalidation" class="tab-content">
            <!-- History Statistics -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">&#128202; Prediction-History Statistiken</h2>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="loadHistoryStats()">&#128260; Aktualisieren</button>
                        <button class="btn btn-success" onclick="triggerPredictionScan()">&#128269; Scan starten</button>
                    </div>
                </div>
                <div class="stats-grid" id="history-stats">
                    <div class="stat-card">
                        <div class="stat-value" id="stat-total-predictions">-</div>
                        <div class="stat-label">Predictions</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value purple" id="stat-symbols">-</div>
                        <div class="stat-label">Symbole</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value success" id="stat-confirmed">-</div>
                        <div class="stat-label">Bestätigt</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value warning" id="stat-corrected">-</div>
                        <div class="stat-label">Korrigiert</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="stat-avg-confidence">-</div>
                        <div class="stat-label">&#8709; Konfidenz</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="stat-scan-status">-</div>
                        <div class="stat-label">Scan</div>
                    </div>
                </div>

                <!-- Scan Progress Bar -->
                <div class="progress-container" id="scan-progress-container">
                    <div class="progress-header">
                        <div class="progress-title">
                            <div class="spinner-small"></div>
                            <span>Prediction-Scan läuft...</span>
                        </div>
                        <div class="progress-stats" id="scan-progress-stats">0 / 0 Symbole</div>
                    </div>
                    <div class="progress-bar-outer">
                        <div class="progress-bar-inner" id="scan-progress-bar"></div>
                    </div>
                    <div class="progress-details">
                        <span id="scan-current-symbol">Initialisiere...</span>
                        <span id="scan-new-predictions">Neue Predictions: 0</span>
                    </div>
                </div>
            </div>

            <!-- Backtest Statistics & Scheduler -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">&#9989; Backtest-Validierung</h2>
                    <div class="btn-group">
                        <button class="btn btn-success" onclick="runAutoBacktest()" title="Validiert alle offenen Predictions gegen echte Marktdaten">&#9989; Jetzt ausführen</button>
                        <button class="btn btn-primary" id="scheduler-toggle-btn" onclick="toggleBacktestScheduler()">&#9202; Scheduler starten</button>
                    </div>
                </div>
                <div class="stats-grid" id="backtest-stats">
                    <div class="stat-card">
                        <div class="stat-value" id="stat-backtest-total">-</div>
                        <div class="stat-label">Backtests</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value success" id="stat-backtest-accuracy">-</div>
                        <div class="stat-label">Richtungs-Genauigkeit</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="stat-backtest-regime">-</div>
                        <div class="stat-label">Regime-Genauigkeit</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="stat-scheduler-status">Inaktiv</div>
                        <div class="stat-label">Auto-Scheduler</div>
                    </div>
                </div>
                <div id="scheduler-config" style="padding: 1rem; display: none;">
                    <div style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
                        <label style="color: #aaa;">Intervall:</label>
                        <select class="timeframe-select" id="scheduler-interval">
                            <option value="1">1 Stunde</option>
                            <option value="2">2 Stunden</option>
                            <option value="4">4 Stunden</option>
                            <option value="6" selected>6 Stunden</option>
                            <option value="12">12 Stunden</option>
                            <option value="24">24 Stunden</option>
                        </select>
                        <span id="scheduler-next-run" style="color: #888; font-size: 0.85rem;"></span>
                        <span id="scheduler-auto-start" style="color: #81c784; font-size: 0.85rem;"></span>
                    </div>
                </div>
            </div>

            <!-- Prediction History Table -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">&#128203; Prediction-History</h2>
                    <div class="btn-group">
                        <select class="timeframe-select" id="history-symbol-filter" onchange="loadPredictionHistory()">
                            <option value="">Alle Symbole</option>
                            <option value="BTCUSD">BTCUSD</option>
                            <option value="ETHUSD">ETHUSD</option>
                            <option value="EURUSD">EURUSD</option>
                            <option value="GBPUSD">GBPUSD</option>
                            <option value="USDJPY">USDJPY</option>
                        </select>
                        <select class="timeframe-select" id="history-result-filter" onchange="loadPredictionHistory()">
                            <option value="">Alle Ergebnisse</option>
                            <option value="correct">Korrekt</option>
                            <option value="wrong">Falsch</option>
                            <option value="pending">Ausstehend</option>
                        </select>
                        <button class="btn btn-primary" onclick="loadPredictionHistory()">&#128260; Laden</button>
                    </div>
                </div>
                <div id="prediction-history-content">
                    <div class="empty-state">
                        <div class="empty-state-icon">&#128203;</div>
                        <p>Klicke auf "Laden" um die Prediction-History anzuzeigen</p>
                    </div>
                </div>
            </div>

            <!-- Feedback Section -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">&#128221; Feedback &amp; Revalidierung</h2>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="loadPendingRevalidation()">&#128260; Pending laden</button>
                        <button class="btn btn-warning" onclick="resetRevalidation()">&#128260; Reset nach Training</button>
                    </div>
                </div>
                <div class="stats-grid" id="feedback-stats">
                    <div class="stat-card">
                        <div class="stat-value" id="stat-feedback-total">-</div>
                        <div class="stat-label">Total Feedback</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value warning" id="stat-pending-reval">-</div>
                        <div class="stat-label">Pending Revalidation</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value success" id="stat-improvement-rate">-</div>
                        <div class="stat-label">Verbesserungsrate</div>
                    </div>
                </div>
                <div id="pending-revalidation-content">
                    <div class="empty-state">
                        <p>Klicke auf "Pending laden" um Predictions zur Revalidierung anzuzeigen</p>
                    </div>
                </div>
            </div>

            <!-- Backtesting Section -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">&#128200; Backtesting</h2>
                    <div class="btn-group">
                        <button class="btn btn-success" onclick="runBacktests()">&#9654; Backtests starten</button>
                        <button class="btn btn-primary" onclick="loadBacktestSummary()">&#128202; Summary</button>
                        <button class="btn btn-danger" onclick="clearBacktests()">&#128465; Löschen</button>
                    </div>
                </div>
                <p class="card-description">
                    Automatischer Vergleich von Predictions mit echten Marktdaten.
                </p>
                <div class="stats-grid" id="backtest-stats">
                    <div class="stat-card">
                        <div class="stat-value" id="stat-backtest-total">-</div>
                        <div class="stat-label">Backtests</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value success" id="stat-direction-accuracy">-</div>
                        <div class="stat-label">Direction Accuracy</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value purple" id="stat-regime-accuracy">-</div>
                        <div class="stat-label">Regime Accuracy</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="stat-mae-1d">-</div>
                        <div class="stat-label">MAE 1d (%)</div>
                    </div>
                </div>
                <div id="backtest-results-content">
                    <div class="empty-state">
                        <p>Klicke auf "Summary" um Backtest-Ergebnisse anzuzeigen</p>
                    </div>
                </div>
            </div>

            <!-- Claude Validation Section -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">&#129302; Claude Vision Validierung</h2>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="loadClaudeValidationStats()">&#128202; Statistiken</button>
                        <button class="btn btn-purple" onclick="checkClaudeStatus()">&#128161; Status</button>
                    </div>
                </div>
                <p class="card-description">
                    KI-gestützte Validierung von Predictions durch Claude Vision API.
                </p>
                <div class="stats-grid" id="claude-stats">
                    <div class="stat-card">
                        <div class="stat-value" id="stat-claude-total">-</div>
                        <div class="stat-label">Validierungen</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value success" id="stat-claude-agreement">-</div>
                        <div class="stat-label">Agreement Rate</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="stat-claude-status">-</div>
                        <div class="stat-label">API Status</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Self-Learning Tab -->
        <div id="tab-selflearning" class="tab-content">
            <!-- Closed-Loop Visualization -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">&#129302; Self-Learning System</h2>
                    <div class="btn-group">
                        <button class="btn btn-purple" id="retrain-toggle-btn" onclick="toggleSelfLearning()">&#9989; Aktiviert</button>
                        <button class="btn btn-warning" id="manual-retrain-btn" onclick="triggerManualRetrain()">&#9881; Manuell trainieren</button>
                    </div>
                </div>

                <!-- Manual Retrain Progress -->
                <div id="manual-retrain-progress" style="margin: 1rem 0; display: none;">
                    <div style="background: rgba(0,0,0,0.2); border-radius: 8px; padding: 1rem;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                            <span id="manual-retrain-status">Training läuft...</span>
                            <span id="manual-retrain-progress-text">0%</span>
                        </div>
                        <div style="background: rgba(255,255,255,0.1); height: 8px; border-radius: 4px; overflow: hidden;">
                            <div id="manual-retrain-progress-bar" style="background: #ffb74d; height: 100%; width: 0%; transition: width 0.3s;"></div>
                        </div>
                        <div id="manual-retrain-details" style="margin-top: 0.5rem; font-size: 0.8rem; color: #888;"></div>
                    </div>
                </div>

                <p class="card-description">
                    Das System lernt kontinuierlich aus seinen Fehlern durch einen geschlossenen Feedback-Loop.
                    Bei schlechter Performance wird automatisch ein Re-Training getriggert.
                </p>

                <!-- Closed-Loop Diagram -->
                <div style="background: rgba(167, 139, 250, 0.1); border-radius: 12px; padding: 1.5rem; margin-bottom: 1.5rem;">
                    <h3 style="color: #a78bfa; margin-bottom: 1rem; font-size: 1rem;">Closed-Loop Feedback</h3>
                    <div style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; gap: 1rem;">
                        <div style="text-align: center;">
                            <div style="width: 80px; height: 80px; border-radius: 50%; background: rgba(100, 200, 255, 0.2); display: flex; align-items: center; justify-content: center; margin: 0 auto 0.5rem; font-size: 1.8rem;">&#127919;</div>
                            <div style="font-size: 0.85rem; color: #64c8ff;">1. Prediction</div>
                        </div>
                        <div style="color: #666; font-size: 1.5rem;">→</div>
                        <div style="text-align: center;">
                            <div style="width: 80px; height: 80px; border-radius: 50%; background: rgba(129, 199, 132, 0.2); display: flex; align-items: center; justify-content: center; margin: 0 auto 0.5rem; font-size: 1.8rem;">&#9989;</div>
                            <div style="font-size: 0.85rem; color: #81c784;">2. Backtest</div>
                        </div>
                        <div style="color: #666; font-size: 1.5rem;">→</div>
                        <div style="text-align: center;">
                            <div style="width: 80px; height: 80px; border-radius: 50%; background: rgba(255, 183, 77, 0.2); display: flex; align-items: center; justify-content: center; margin: 0 auto 0.5rem; font-size: 1.8rem;">&#128202;</div>
                            <div style="font-size: 0.85rem; color: #ffb74d;">3. Analyse</div>
                        </div>
                        <div style="color: #666; font-size: 1.5rem;">→</div>
                        <div style="text-align: center;">
                            <div style="width: 80px; height: 80px; border-radius: 50%; background: rgba(167, 139, 250, 0.2); display: flex; align-items: center; justify-content: center; margin: 0 auto 0.5rem; font-size: 1.8rem;">&#129302;</div>
                            <div style="font-size: 0.85rem; color: #a78bfa;">4. Re-Train</div>
                        </div>
                        <div style="color: #666; font-size: 1.5rem;">↩</div>
                    </div>
                </div>

                <!-- Stats Grid -->
                <div class="stats-grid" id="retrain-stats">
                    <div class="stat-card">
                        <div class="stat-value purple" id="stat-retrain-threshold">60%</div>
                        <div class="stat-label">Accuracy-Schwelle</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="stat-retrain-total">0</div>
                        <div class="stat-label">Re-Trainings</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value success" id="stat-retrain-improvement">-</div>
                        <div class="stat-label">Avg. Verbesserung</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="stat-retrain-cooldown">-</div>
                        <div class="stat-label">Cooldown</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="stat-retrain-successful">0</div>
                        <div class="stat-label">Erfolgreich</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value error" id="stat-retrain-failed">0</div>
                        <div class="stat-label">Fehlgeschlagen</div>
                    </div>
                </div>
            </div>

            <!-- Configuration Card -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">&#9881; Konfiguration</h2>
                </div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem;">
                    <div>
                        <label style="color: #aaa; display: block; margin-bottom: 0.5rem;">Accuracy-Schwelle</label>
                        <select class="timeframe-select" id="retrain-threshold-select" onchange="updateRetrainConfig()" style="width: 100%;">
                            <option value="50">50% (Niedrig)</option>
                            <option value="55">55%</option>
                            <option value="60" selected>60% (Standard)</option>
                            <option value="65">65%</option>
                            <option value="70">70% (Hoch)</option>
                        </select>
                        <small style="color: #666; display: block; margin-top: 0.3rem;">Re-Training wenn Accuracy darunter fällt</small>
                    </div>
                    <div>
                        <label style="color: #aaa; display: block; margin-bottom: 0.5rem;">Cooldown-Periode</label>
                        <select class="timeframe-select" id="retrain-cooldown-select" onchange="updateRetrainConfig()" style="width: 100%;">
                            <option value="6">6 Stunden</option>
                            <option value="12">12 Stunden</option>
                            <option value="24" selected>24 Stunden (Standard)</option>
                            <option value="48">48 Stunden</option>
                            <option value="72">72 Stunden</option>
                        </select>
                        <small style="color: #666; display: block; margin-top: 0.3rem;">Mindestwartezeit zwischen Trainings</small>
                    </div>
                    <div>
                        <label style="color: #aaa; display: block; margin-bottom: 0.5rem;">Min. Backtests</label>
                        <select class="timeframe-select" id="retrain-min-samples-select" onchange="updateRetrainConfig()" style="width: 100%;">
                            <option value="10">10</option>
                            <option value="20" selected>20 (Standard)</option>
                            <option value="30">30</option>
                            <option value="50">50</option>
                        </select>
                        <small style="color: #666; display: block; margin-top: 0.3rem;">Mindestanzahl Backtests für Trigger</small>
                    </div>
                    <div>
                        <label style="color: #aaa; display: block; margin-bottom: 0.5rem;">Training-Fokus</label>
                        <div style="padding: 0.6rem; background: rgba(0,0,0,0.2); border-radius: 6px;">
                            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                                <input type="checkbox" id="retrain-focus-errors" checked onchange="updateRetrainConfig()">
                                <span>Fehler-fokussiertes Training</span>
                            </label>
                            <small style="color: #666; display: block; margin-top: 0.3rem;">Trainiert gezielt auf schwachen Symbolen</small>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Retrain History Table -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">&#128203; Re-Training History</h2>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="loadRetrainHistory()">&#128260; Aktualisieren</button>
                    </div>
                </div>
                <div class="table-container" id="retrain-history-container">
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Zeitpunkt</th>
                                <th>Auslöser</th>
                                <th>Accuracy vorher</th>
                                <th>Accuracy nachher</th>
                                <th>Verbesserung</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody id="retrain-history-body">
                            <tr>
                                <td colspan="6" style="text-align: center; padding: 2rem; color: #666;">
                                    Noch keine Re-Trainings durchgeführt
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Current Accuracy Card -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">&#128200; Aktuelle Performance</h2>
                </div>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="stat-current-accuracy">-</div>
                        <div class="stat-label">Aktuelle Accuracy</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="stat-backtest-count">-</div>
                        <div class="stat-label">Backtests gesamt</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="stat-trigger-status">-</div>
                        <div class="stat-label">Trigger-Status</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="stat-next-check">-</div>
                        <div class="stat-label">Nächster Check</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Training Tab -->
        <div id="tab-training" class="tab-content">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">&#128203; Training starten</h2>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="checkTrainingStatus()">&#128260; Status</button>
                    </div>
                </div>

                <div class="training-status" id="training-status">
                    <div class="status-indicator idle" id="training-indicator"></div>
                    <div>
                        <strong>Status:</strong> <span id="training-status-text">Idle</span>
                    </div>
                </div>

                <div class="training-form">
                    <div class="form-group" style="grid-column: span 2;">
                        <label class="form-label">Symbol-Set</label>
                        <select class="form-select" id="train-symbol-set" onchange="applySymbolSet()">
                            <option value="custom">Benutzerdefiniert</option>
                            <option value="core" selected>Kern (Krypto + Forex)</option>
                            <option value="crypto">Krypto Top 5</option>
                            <option value="forex">Forex Majors</option>
                            <option value="mixed">Gemischt (Maximum)</option>
                            <option value="stocks">US Aktien</option>
                        </select>
                    </div>
                    <div class="form-group" style="grid-column: span 2;">
                        <label class="form-label">Symbole (kommagetrennt)</label>
                        <input type="text" class="form-input" id="train-symbols" value="BTCUSD,ETHUSD,EURUSD,GBPUSD,USDJPY" placeholder="BTCUSD,EURUSD">
                        <small style="color: #888; font-size: 0.75rem; margin-top: 0.25rem; display: block;" id="symbol-set-description">
                            2 Krypto + 3 Forex Major Pairs - gute Datenverfügbarkeit
                        </small>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Timeframes</label>
                        <select class="form-select" id="train-timeframe">
                            <option value="M5">M5 (5 Minuten)</option>
                            <option value="M15">M15 (15 Minuten)</option>
                            <option value="M30">M30 (30 Minuten)</option>
                            <option value="H1" selected>H1 (1 Stunde)</option>
                            <option value="H4">H4 (4 Stunden)</option>
                            <option value="D1">D1 (1 Tag)</option>
                            <option value="W1">W1 (1 Woche)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Epochen</label>
                        <input type="number" class="form-input" id="train-epochs" value="50" min="1" max="500">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Batch Size</label>
                        <select class="form-select" id="train-batch-size">
                            <option value="16">16</option>
                            <option value="32" selected>32</option>
                            <option value="64">64</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Sets verwalten</label>
                        <button class="btn btn-primary" onclick="openSymbolSetManager()" style="width: 100%;">
                            &#9881; Bearbeiten
                        </button>
                    </div>
                </div>

                <div class="btn-group">
                    <button class="btn btn-success" onclick="startTraining()">&#9654; Training starten</button>
                    <button class="btn btn-danger" onclick="cancelTraining()">&#9632; Abbrechen</button>
                </div>

                <div id="training-progress" style="margin-top: 1rem; display: none;">
                    <div style="background: rgba(0,0,0,0.2); border-radius: 8px; padding: 1rem;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                            <span>Fortschritt</span>
                            <span id="training-progress-text">0%</span>
                        </div>
                        <div style="background: rgba(255,255,255,0.1); height: 8px; border-radius: 4px; overflow: hidden;">
                            <div id="training-progress-bar" style="background: #a78bfa; height: 100%; width: 0%; transition: width 0.3s;"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">&#128202; Training-Historie</h2>
                    <button class="btn btn-primary" onclick="loadTrainingHistory()">&#128260; Laden</button>
                </div>
                <div id="training-history">
                    <div class="empty-state">
                        <p>Klicke auf "Laden" um die Training-Historie anzuzeigen</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Features Tab -->
        <div id="tab-features" class="tab-content active">
            <!-- Learning Progress Chart -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">&#128200; Lernfortschritt</h2>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <select class="timeframe-select" id="cnn-lstm-metrics-training-type" style="padding: 0.4rem 0.8rem; font-size: 0.85rem;" onchange="loadCnnLstmMetricsHistory()">
                            <option value="all">Alle Trainings</option>
                            <option value="full">Vollständige Trainings</option>
                            <option value="incremental">Inkrementelle</option>
                        </select>
                        <button class="btn btn-primary" onclick="loadCnnLstmMetricsHistory()" style="padding: 0.4rem 0.6rem;">&#8635;</button>
                    </div>
                </div>
                <div style="position: relative; height: 220px; padding: 0.5rem;">
                    <canvas id="cnn-lstm-metrics-chart"></canvas>
                </div>
                <div id="cnn-lstm-metrics-summary" style="padding: 0.75rem 1rem; font-size: 0.85rem; color: #888; border-top: 1px solid rgba(255,255,255,0.05); display: flex; gap: 1.5rem; flex-wrap: wrap;">
                    Lade Metriken...
                </div>
            </div>

            <!-- Modell-Architektur -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">&#129516; Modell-Architektur</h2>
                    <button class="btn btn-primary" onclick="loadModelInfo()">&#128260; Aktualisieren</button>
                </div>

                <div id="model-info-content-features">
                    <div class="model-info-grid">
                        <div class="model-info-item">
                            <span class="model-info-label">CNN Encoder</span>
                            <span class="model-info-value">3 Conv1d Layers</span>
                        </div>
                        <div class="model-info-item">
                            <span class="model-info-label">CNN Channels</span>
                            <span class="model-info-value">25 → 64 → 128 → 256</span>
                        </div>
                        <div class="model-info-item">
                            <span class="model-info-label">LSTM Typ</span>
                            <span class="model-info-value">Bidirectional</span>
                        </div>
                        <div class="model-info-item">
                            <span class="model-info-label">LSTM Hidden</span>
                            <span class="model-info-value">128 × 2 = 256</span>
                        </div>
                        <div class="model-info-item">
                            <span class="model-info-label">LSTM Layers</span>
                            <span class="model-info-value">2</span>
                        </div>
                        <div class="model-info-item">
                            <span class="model-info-label">Attention</span>
                            <span class="model-info-value">Self-Attention</span>
                        </div>
                        <div class="model-info-item">
                            <span class="model-info-label">Price Head</span>
                            <span class="model-info-value">256 → 128 → 4</span>
                        </div>
                        <div class="model-info-item">
                            <span class="model-info-label">Pattern Head</span>
                            <span class="model-info-value">256 → 128 → 16</span>
                        </div>
                        <div class="model-info-item">
                            <span class="model-info-label">Regime Head</span>
                            <span class="model-info-value">256 → 128 → 4</span>
                        </div>
                        <div class="model-info-item">
                            <span class="model-info-label">Dropout</span>
                            <span class="model-info-value">0.2 (CNN) / 0.3 (LSTM)</span>
                        </div>
                    </div>
                </div>

                <div style="margin-top: 1.5rem; padding: 1rem; background: rgba(167, 139, 250, 0.1); border-left: 3px solid #a78bfa; border-radius: 0 8px 8px 0;">
                    <strong style="color: #a78bfa;">Multi-Task Loss:</strong>
                    <code style="margin-left: 0.5rem;">Total = 0.4×Price_MSE + 0.35×Pattern_BCE + 0.25×Regime_CE</code>
                </div>
            </div>

            <!-- Verfügbare Modelle (aufklappbar) -->
            <div class="card collapsible-card">
                <div class="card-header collapsible-header" onclick="toggleModelsSection()" style="cursor: pointer;">
                    <h2 class="card-title">
                        <span id="models-toggle-icon" style="display: inline-block; transition: transform 0.2s;">&#9654;</span>
                        &#128279; Verfügbare Modelle
                    </h2>
                    <span id="models-count-badge" class="badge" style="background: rgba(100, 200, 255, 0.2); color: #64c8ff; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.8rem;">-</span>
                </div>
                <div id="models-section-content" style="display: none; padding-top: 1rem;">
                    <div id="models-list-overview">
                        <div class="loading"><div class="spinner"></div><p>Lade Modelle...</p></div>
                    </div>
                </div>
            </div>

            <!-- Input-Features (aufklappbar) -->
            <div class="card collapsible-card">
                <div class="card-header collapsible-header" onclick="toggleFeaturesSection()" style="cursor: pointer;">
                    <h2 class="card-title">
                        <span id="features-toggle-icon" style="display: inline-block; transition: transform 0.2s;">&#9654;</span>
                        &#128200; Input-Features (25 Dimensionen)
                    </h2>
                    <span class="badge" style="background: rgba(100, 200, 255, 0.2); color: #64c8ff; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.8rem;">25</span>
                </div>
                <div id="features-section-content" style="display: none; padding-top: 1rem;">
                    <p class="card-description">
                        Das CNN-LSTM Modell verarbeitet 25 technische Features als Input.
                    </p>

                    <table class="feature-table">
                    <thead>
                        <tr>
                            <th>Kategorie</th>
                            <th>Feature</th>
                            <th>Beschreibung</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr><td><span class="feature-category ohlcv">OHLCV</span></td><td>Open</td><td>Eröffnungspreis</td></tr>
                        <tr><td><span class="feature-category ohlcv">OHLCV</span></td><td>High</td><td>Höchstpreis</td></tr>
                        <tr><td><span class="feature-category ohlcv">OHLCV</span></td><td>Low</td><td>Tiefstpreis</td></tr>
                        <tr><td><span class="feature-category ohlcv">OHLCV</span></td><td>Close</td><td>Schlusspreis</td></tr>
                        <tr><td><span class="feature-category ohlcv">OHLCV</span></td><td>Volume</td><td>Handelsvolumen</td></tr>
                        <tr><td><span class="feature-category returns">Returns</span></td><td>Log Return</td><td>Logarithmische Rendite</td></tr>
                        <tr><td><span class="feature-category returns">Returns</span></td><td>Volatility 20</td><td>20-Perioden Volatilität</td></tr>
                        <tr><td><span class="feature-category trend">Trend</span></td><td>SMA 20</td><td>Simple Moving Average (20)</td></tr>
                        <tr><td><span class="feature-category trend">Trend</span></td><td>EMA 12</td><td>Exponential MA (12)</td></tr>
                        <tr><td><span class="feature-category trend">Trend</span></td><td>EMA 26</td><td>Exponential MA (26)</td></tr>
                        <tr><td><span class="feature-category trend">Trend</span></td><td>MACD</td><td>Moving Average Convergence</td></tr>
                        <tr><td><span class="feature-category trend">Trend</span></td><td>MACD Signal</td><td>MACD Signal Line</td></tr>
                        <tr><td><span class="feature-category momentum">Momentum</span></td><td>RSI 14</td><td>Relative Strength Index</td></tr>
                        <tr><td><span class="feature-category momentum">Momentum</span></td><td>Stochastic K</td><td>Stochastic %K</td></tr>
                        <tr><td><span class="feature-category momentum">Momentum</span></td><td>Stochastic D</td><td>Stochastic %D</td></tr>
                        <tr><td><span class="feature-category momentum">Momentum</span></td><td>CCI 14</td><td>Commodity Channel Index</td></tr>
                        <tr><td><span class="feature-category volatility">Volatility</span></td><td>ATR 14</td><td>Average True Range</td></tr>
                        <tr><td><span class="feature-category volatility">Volatility</span></td><td>BB Upper</td><td>Bollinger Band Oben</td></tr>
                        <tr><td><span class="feature-category volatility">Volatility</span></td><td>BB Middle</td><td>Bollinger Band Mitte</td></tr>
                        <tr><td><span class="feature-category volatility">Volatility</span></td><td>BB Lower</td><td>Bollinger Band Unten</td></tr>
                        <tr><td><span class="feature-category volume">Volume</span></td><td>OBV</td><td>On-Balance Volume (norm.)</td></tr>
                        <tr><td><span class="feature-category volume">Volume</span></td><td>A/D Line</td><td>Accumulation/Distribution</td></tr>
                        <tr><td><span class="feature-category position">Position</span></td><td>Price vs SMA</td><td>Preis relativ zu SMA</td></tr>
                        <tr><td><span class="feature-category position">Position</span></td><td>BB Position</td><td>Position in Bollinger (0-1)</td></tr>
                        <tr><td><span class="feature-category meta">Meta</span></td><td>Timeframe Enc</td><td>Timeframe-Kodierung</td></tr>
                    </tbody>
                </table>
                </div>
            </div>

            <!-- Sequenzlängen (aufklappbar) -->
            <div class="card collapsible-card">
                <div class="card-header collapsible-header" onclick="toggleSequenceSection()" style="cursor: pointer;">
                    <h2 class="card-title">
                        <span id="sequence-toggle-icon" style="display: inline-block; transition: transform 0.2s;">&#9654;</span>
                        &#128337; Sequenzlängen pro Timeframe
                    </h2>
                    <span class="badge" style="background: rgba(100, 200, 255, 0.2); color: #64c8ff; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.8rem;">9</span>
                </div>
                <div id="sequence-section-content" style="display: none; padding-top: 1rem;">
                    <table class="timeframe-table">
                    <thead>
                        <tr>
                            <th>Timeframe</th>
                            <th>Sequenz</th>
                            <th>Entspricht</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr><td>M1</td><td>480</td><td>8 Stunden</td></tr>
                        <tr><td>M5</td><td>288</td><td>24 Stunden</td></tr>
                        <tr><td>M15</td><td>192</td><td>48 Stunden</td></tr>
                        <tr><td>M30</td><td>192</td><td>4 Tage</td></tr>
                        <tr><td>H1</td><td>168</td><td>1 Woche</td></tr>
                        <tr><td>H4</td><td>168</td><td>4 Wochen</td></tr>
                        <tr><td>D1</td><td>120</td><td>~6 Monate</td></tr>
                        <tr><td>W1</td><td>52</td><td>1 Jahr</td></tr>
                        <tr><td>MN</td><td>24</td><td>2 Jahre</td></tr>
                    </tbody>
                </table>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <script>
        // Tab Switching
        function switchTab(tabId) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

            document.querySelector(`[onclick="switchTab('${tabId}')"]`).classList.add('active');
            document.getElementById(`tab-${tabId}`).classList.add('active');

            // Load tab-specific content
            if (tabId === 'features') {
                loadCnnLstmMetricsHistory();
            } else if (tabId === 'selflearning') {
                loadSelfLearningStatus();
            }
        }

        // Toast Notifications
        function showToast(message, type = 'info') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast toast-${type} show`;
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        // Load Prediction
        async function loadPrediction() {
            const symbol = document.getElementById('prediction-symbol').value;
            const timeframe = document.getElementById('prediction-timeframe').value;
            const container = document.getElementById('prediction-content');

            if (!symbol) {
                showToast('Bitte Symbol eingeben', 'error');
                return;
            }

            container.innerHTML = '<div class="loading"><div class="spinner"></div><p>Lade Vorhersage...</p></div>';

            try {
                const response = await fetch(`/cnn-lstm/api/v1/predict/${symbol}?timeframe=${timeframe}`);

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Prediction failed');
                }

                const data = await response.json();
                renderPrediction(data);

            } catch (error) {
                container.innerHTML = `<div class="empty-state"><div class="empty-state-icon">&#9888;</div><p>${error.message}</p></div>`;
                showToast(error.message, 'error');
            }
        }

        // Render Prediction
        function renderPrediction(data) {
            const container = document.getElementById('prediction-content');
            const { predictions } = data;
            const { price, patterns, regime } = predictions;

            const directionClass = price.direction === 'bullish' ? 'bullish' :
                                   price.direction === 'bearish' ? 'bearish' : 'neutral';

            const regimeIcons = {
                'bull_trend': '&#128200;',
                'bear_trend': '&#128201;',
                'sideways': '&#8596;',
                'high_volatility': '&#9889;'
            };

            const regimeNames = {
                'bull_trend': 'Aufwärtstrend',
                'bear_trend': 'Abwärtstrend',
                'sideways': 'Seitwärts',
                'high_volatility': 'Hohe Volatilität'
            };

            container.innerHTML = `
                <div class="prediction-grid">
                    <!-- Price Prediction -->
                    <div class="prediction-card">
                        <div class="prediction-card-header">
                            <span class="prediction-card-title">&#128176; Preis-Vorhersage</span>
                            <span class="prediction-badge ${directionClass}">${price.direction.toUpperCase()}</span>
                        </div>
                        <div class="price-forecasts">
                            <div class="forecast-item">
                                <div class="forecast-label">Aktuell</div>
                                <div class="forecast-value">${formatPrice(price.current)}</div>
                            </div>
                            <div class="forecast-item">
                                <div class="forecast-label">1h</div>
                                <div class="forecast-value">${formatPrice(price.forecast_1h)}</div>
                                <div class="forecast-change ${price.change_percent_1h >= 0 ? 'positive' : 'negative'}">
                                    ${price.change_percent_1h >= 0 ? '+' : ''}${price.change_percent_1h?.toFixed(2) || '0'}%
                                </div>
                            </div>
                            <div class="forecast-item">
                                <div class="forecast-label">4h</div>
                                <div class="forecast-value">${formatPrice(price.forecast_4h)}</div>
                            </div>
                            <div class="forecast-item">
                                <div class="forecast-label">1d</div>
                                <div class="forecast-value">${formatPrice(price.forecast_1d)}</div>
                                <div class="forecast-change ${price.change_percent_1d >= 0 ? 'positive' : 'negative'}">
                                    ${price.change_percent_1d >= 0 ? '+' : ''}${price.change_percent_1d?.toFixed(2) || '0'}%
                                </div>
                            </div>
                        </div>
                        <div style="text-align: center; padding: 0.5rem; background: rgba(0,0,0,0.2); border-radius: 6px;">
                            <span style="color: #888;">Konfidenz:</span>
                            <strong style="color: #a78bfa; margin-left: 0.5rem;">${(price.confidence * 100).toFixed(0)}%</strong>
                        </div>
                    </div>

                    <!-- Pattern Detection -->
                    <div class="prediction-card">
                        <div class="prediction-card-header">
                            <span class="prediction-card-title">&#128202; Erkannte Patterns</span>
                            <span class="prediction-badge neutral">${patterns.length} gefunden</span>
                        </div>
                        <div class="patterns-list">
                            ${patterns.length > 0 ? patterns.map(p => `
                                <div class="pattern-item">
                                    <span class="pattern-name">${formatPatternName(p.type)}</span>
                                    <div class="pattern-confidence">
                                        <span class="prediction-badge ${p.direction}">${p.direction}</span>
                                        <div class="confidence-bar">
                                            <div class="confidence-fill" style="width: ${p.confidence * 100}%"></div>
                                        </div>
                                        <span class="confidence-value">${(p.confidence * 100).toFixed(0)}%</span>
                                    </div>
                                </div>
                            `).join('') : '<div style="text-align: center; padding: 1rem; color: #888;">Keine Patterns erkannt (Konfidenz &lt; 50%)</div>'}
                        </div>
                    </div>

                    <!-- Regime Prediction -->
                    <div class="prediction-card">
                        <div class="prediction-card-header">
                            <span class="prediction-card-title">&#127919; Markt-Regime</span>
                        </div>
                        <div class="regime-display">
                            <div class="regime-current">
                                <div class="regime-icon">${regimeIcons[regime.current] || '?'}</div>
                                <div class="regime-info">
                                    <div class="regime-name">${regimeNames[regime.current] || regime.current}</div>
                                    <div class="regime-probability">Wahrscheinlichkeit: ${(regime.probability * 100).toFixed(0)}%</div>
                                </div>
                            </div>
                            <div class="regime-transitions">
                                <div class="transition-item">
                                    <div class="transition-label">Bull</div>
                                    <div class="transition-value" style="color: #81c784;">${(regime.transition_probs.bull_trend * 100).toFixed(0)}%</div>
                                </div>
                                <div class="transition-item">
                                    <div class="transition-label">Bear</div>
                                    <div class="transition-value" style="color: #e57373;">${(regime.transition_probs.bear_trend * 100).toFixed(0)}%</div>
                                </div>
                                <div class="transition-item">
                                    <div class="transition-label">Sideways</div>
                                    <div class="transition-value" style="color: #ffb74d;">${(regime.transition_probs.sideways * 100).toFixed(0)}%</div>
                                </div>
                                <div class="transition-item">
                                    <div class="transition-label">High Vol</div>
                                    <div class="transition-value" style="color: #64b5f6;">${(regime.transition_probs.high_volatility * 100).toFixed(0)}%</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Load Analysis
        async function loadAnalysis() {
            const symbol = document.getElementById('prediction-symbol').value;
            const timeframe = document.getElementById('prediction-timeframe').value;

            if (!symbol) {
                showToast('Bitte Symbol eingeben', 'error');
                return;
            }

            try {
                const response = await fetch(`/cnn-lstm/api/v1/analysis/${symbol}?timeframe=${timeframe}`);

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Analysis failed');
                }

                const data = await response.json();
                renderAnalysis(data);
                showToast('Analyse geladen', 'success');

            } catch (error) {
                showToast(error.message, 'error');
            }
        }

        // Render Analysis with Recommendation
        function renderAnalysis(data) {
            const container = document.getElementById('prediction-content');
            const { recommendation, insights } = data;

            const actionColors = {
                'STRONG_BUY': 'buy',
                'BUY': 'buy',
                'HOLD': 'hold',
                'SELL': 'sell',
                'STRONG_SELL': 'sell'
            };

            const actionIcons = {
                'STRONG_BUY': '&#128640;',
                'BUY': '&#128200;',
                'HOLD': '&#9202;',
                'SELL': '&#128201;',
                'STRONG_SELL': '&#128683;'
            };

            const existingContent = container.innerHTML;

            container.innerHTML = existingContent + `
                <div class="recommendation-box ${actionColors[recommendation.action]}">
                    <div class="recommendation-icon">${actionIcons[recommendation.action]}</div>
                    <div class="recommendation-info">
                        <div class="recommendation-action">${recommendation.action.replace('_', ' ')}</div>
                        <div class="recommendation-score">Score: ${recommendation.score} | Konfidenz: ${(recommendation.confidence * 100).toFixed(0)}% | Risiko: ${recommendation.risk_level}</div>
                    </div>
                </div>
                <div style="margin-top: 1rem; padding: 1rem; background: rgba(0,0,0,0.2); border-radius: 8px;">
                    <strong style="color: #64c8ff;">Insights:</strong>
                    <ul style="margin-top: 0.5rem; padding-left: 1.5rem;">
                        ${insights.map(i => `<li style="margin-bottom: 0.25rem;">${i}</li>`).join('')}
                    </ul>
                </div>
            `;
        }

        // Training Functions
        async function startTraining() {
            const symbols = document.getElementById('train-symbols').value.split(',').map(s => s.trim());
            const timeframe = document.getElementById('train-timeframe').value;
            const epochs = parseInt(document.getElementById('train-epochs').value);
            const batchSize = parseInt(document.getElementById('train-batch-size').value);

            try {
                const response = await fetch('/cnn-lstm-train/api/v1/train', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        symbols: symbols,
                        timeframes: [timeframe],
                        epochs: epochs,
                        batch_size: batchSize
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Training start failed');
                }

                showToast('Training gestartet', 'success');
                document.getElementById('training-progress').style.display = 'block';
                startTrainingPolling();

            } catch (error) {
                showToast(error.message, 'error');
            }
        }

        async function cancelTraining() {
            try {
                const response = await fetch('/cnn-lstm-train/api/v1/train/cancel', { method: 'POST' });
                if (response.ok) {
                    showToast('Training abgebrochen', 'info');
                    document.getElementById('training-indicator').className = 'status-indicator idle';
                    document.getElementById('training-status-text').textContent = 'Abgebrochen';
                }
            } catch (error) {
                showToast(error.message, 'error');
            }
        }

        let trainingPollingInterval = null;

        async function checkTrainingStatus(showToastMessage = true) {
            try {
                const response = await fetch('/cnn-lstm-train/api/v1/train/status');
                const data = await response.json();

                const indicator = document.getElementById('training-indicator');
                const statusText = document.getElementById('training-status-text');
                const progressContainer = document.getElementById('training-progress');
                const progressBar = document.getElementById('training-progress-bar');
                const progressText = document.getElementById('training-progress-text');

                // Check if training is active based on status field
                const activeStatuses = ['pending', 'preparing', 'training', 'validating', 'saving'];
                const isTraining = activeStatuses.includes(data.status);

                if (isTraining) {
                    indicator.className = 'status-indicator running';

                    // Get progress from nested progress object
                    const progress = data.progress || {};
                    const currentEpoch = progress.current_epoch || 0;
                    const totalEpochs = progress.total_epochs || 0;
                    const currentSymbol = progress.current_symbol || '';
                    const symbolsCompleted = progress.symbols_completed || 0;
                    const totalSymbols = progress.total_symbols || 0;

                    // Build status message
                    let statusMsg = `Training läuft`;
                    if (data.status === 'preparing') {
                        statusMsg = 'Vorbereitung...';
                    } else if (data.status === 'saving') {
                        statusMsg = 'Speichere Modell...';
                    } else if (data.status === 'validating') {
                        statusMsg = 'Validierung...';
                    } else {
                        if (currentSymbol) statusMsg += ` - ${currentSymbol}`;
                        if (totalSymbols > 1) statusMsg += ` (${symbolsCompleted + 1}/${totalSymbols})`;
                        if (totalEpochs > 0) statusMsg += ` - Epoche ${currentEpoch}/${totalEpochs}`;
                    }

                    statusText.textContent = statusMsg;
                    progressContainer.style.display = 'block';

                    // Calculate progress percentage
                    const progressPercent = totalEpochs > 0 ? (currentEpoch / totalEpochs * 100) : 0;
                    progressBar.style.width = progressPercent + '%';
                    progressText.textContent = progressPercent.toFixed(0) + '%';

                    // Start polling if not already running
                    if (!trainingPollingInterval) {
                        startTrainingPolling();
                    }
                } else {
                    indicator.className = 'status-indicator idle';

                    // Show appropriate status message
                    const statusMessages = {
                        'idle': 'Bereit',
                        'completed': 'Abgeschlossen',
                        'failed': 'Fehlgeschlagen',
                        'cancelled': 'Abgebrochen'
                    };
                    statusText.textContent = statusMessages[data.status] || data.status || 'Bereit';

                    // If completed, show 100%
                    if (data.status === 'completed') {
                        progressContainer.style.display = 'block';
                        progressBar.style.width = '100%';
                        progressText.textContent = '100%';
                    } else {
                        progressContainer.style.display = 'none';
                    }

                    // Stop polling if running
                    if (trainingPollingInterval) {
                        clearInterval(trainingPollingInterval);
                        trainingPollingInterval = null;
                    }
                }

                if (showToastMessage) {
                    showToast('Status aktualisiert', 'info');
                }

                return isTraining;
            } catch (error) {
                if (showToastMessage) {
                    showToast(error.message, 'error');
                }
                console.error('Training status check failed:', error);
                return false;
            }
        }

        function startTrainingPolling() {
            if (trainingPollingInterval) {
                clearInterval(trainingPollingInterval);
            }

            trainingPollingInterval = setInterval(async () => {
                const isTraining = await checkTrainingStatus(false);
                if (!isTraining) {
                    clearInterval(trainingPollingInterval);
                    trainingPollingInterval = null;
                    showToast('Training abgeschlossen!', 'success');
                    loadTrainingHistory(); // Reload history when done
                }
            }, 3000); // Poll every 3 seconds
        }

        async function loadTrainingHistory() {
            const container = document.getElementById('training-history');
            container.innerHTML = '<div class="loading"><div class="spinner"></div><p>Lade Historie...</p></div>';

            try {
                const response = await fetch('/cnn-lstm-train/api/v1/train/history');

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();

                if (!data.history || data.history.length === 0) {
                    container.innerHTML = '<div class="empty-state"><p>Keine Training-Historie vorhanden</p></div>';
                    return;
                }

                container.innerHTML = `
                    <div style="margin-bottom: 0.5rem; font-size: 0.8rem; color: #888;">
                        Gesamt: ${data.total_jobs || 0} Jobs | Erfolgreich: ${data.successful_jobs || 0} | Fehlgeschlagen: ${data.failed_jobs || 0}
                    </div>
                    <table class="feature-table">
                        <thead>
                            <tr>
                                <th>Datum</th>
                                <th>Job-ID</th>
                                <th>Symbole</th>
                                <th>TF</th>
                                <th>Epochen</th>
                                <th>Loss</th>
                                <th>Dauer</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${data.history.map(h => `
                                <tr>
                                    <td>${new Date(h.started_at).toLocaleString('de-DE', {dateStyle: 'short', timeStyle: 'short'})}</td>
                                    <td style="font-size: 0.7rem; font-family: monospace;">${(h.job_id || '').slice(-12)}</td>
                                    <td>${h.symbols?.join(', ') || '-'}</td>
                                    <td>${h.timeframes?.join(', ') || '-'}</td>
                                    <td>${h.epochs_completed || h.epochs || '-'}</td>
                                    <td>${h.final_loss != null ? h.final_loss.toFixed(4) : '-'}</td>
                                    <td>${h.duration_seconds ? Math.round(h.duration_seconds) + 's' : '-'}</td>
                                    <td><span class="prediction-badge ${h.status === 'completed' ? 'bullish' : h.status === 'running' ? 'neutral' : 'bearish'}">${h.status}</span></td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
            } catch (error) {
                container.innerHTML = `<div class="empty-state"><p style="color: #e57373;">Fehler: ${error.message}</p></div>`;
                showToast('Training-Historie konnte nicht geladen werden: ' + error.message, 'error');
            }
        }

        // Model Functions
        let modelsLoaded = false;

        function toggleModelsSection() {
            const content = document.getElementById('models-section-content');
            const icon = document.getElementById('models-toggle-icon');
            const isHidden = content.style.display === 'none';

            if (isHidden) {
                content.style.display = 'block';
                icon.style.transform = 'rotate(90deg)';
                // Auto-load models on first expand
                if (!modelsLoaded) {
                    loadModelsOverview();
                }
            } else {
                content.style.display = 'none';
                icon.style.transform = 'rotate(0deg)';
            }
        }

        async function loadModelsOverview() {
            const container = document.getElementById('models-list-overview');
            const badge = document.getElementById('models-count-badge');

            try {
                const response = await fetch('/cnn-lstm/api/v1/models');
                const data = await response.json();

                if (!data.models || data.models.length === 0) {
                    container.innerHTML = '<div class="empty-state"><p>Keine Modelle verfügbar. Starte ein Training!</p></div>';
                    badge.textContent = '0';
                    return;
                }

                modelsLoaded = true;
                badge.textContent = data.models.length;

                container.innerHTML = `
                    <table class="feature-table">
                        <thead>
                            <tr>
                                <th>Modell-ID</th>
                                <th>Version</th>
                                <th>Erstellt</th>
                                <th>Parameter</th>
                                <th>Aktiv</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${data.models.map(m => `
                                <tr>
                                    <td>${m.model_id}</td>
                                    <td>${m.version}</td>
                                    <td>${new Date(m.created_at).toLocaleString('de-DE')}</td>
                                    <td>${m.total_parameters?.toLocaleString() || '-'}</td>
                                    <td>${m.is_active ? '<span style="color: #81c784;">&#10003;</span>' : ''}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
            } catch (error) {
                container.innerHTML = '<div class="empty-state"><p>Fehler beim Laden der Modelle</p></div>';
                showToast(error.message, 'error');
            }
        }

        async function loadModels() {
            await loadModelsOverview();
        }

        // Toggle Features Section
        function toggleFeaturesSection() {
            const content = document.getElementById('features-section-content');
            const icon = document.getElementById('features-toggle-icon');
            const isHidden = content.style.display === 'none';

            if (isHidden) {
                content.style.display = 'block';
                icon.style.transform = 'rotate(90deg)';
            } else {
                content.style.display = 'none';
                icon.style.transform = 'rotate(0deg)';
            }
        }

        // Toggle Sequence Section
        function toggleSequenceSection() {
            const content = document.getElementById('sequence-section-content');
            const icon = document.getElementById('sequence-toggle-icon');
            const isHidden = content.style.display === 'none';

            if (isHidden) {
                content.style.display = 'block';
                icon.style.transform = 'rotate(90deg)';
            } else {
                content.style.display = 'none';
                icon.style.transform = 'rotate(0deg)';
            }
        }

        // Format uptime from seconds
        function formatUptimeSeconds(seconds) {
            if (!seconds) return '-';
            const days = Math.floor(seconds / (60 * 60 * 24));
            const hours = Math.floor((seconds % (60 * 60 * 24)) / (60 * 60));
            const minutes = Math.floor((seconds % (60 * 60)) / 60);

            if (days > 0) {
                return `${days}d ${hours}h ${minutes}m`;
            } else if (hours > 0) {
                return `${hours}h ${minutes}m`;
            } else {
                return `${minutes}m`;
            }
        }

        // Update header status bar
        async function updateHeaderStatus() {
            try {
                const response = await fetch('/cnn-lstm/api/v1/info');

                if (response.ok) {
                    const data = await response.json();
                    document.getElementById('headerStatus').textContent = 'Online';
                    document.getElementById('headerStatus').style.color = '#4caf50';
                    document.getElementById('headerVersion').textContent = data.model?.version || '-';
                    document.getElementById('headerUptime').textContent = formatUptimeSeconds(data.runtime?.uptime_seconds);
                    document.getElementById('serviceStatus').textContent = 'Online';
                    document.getElementById('serviceStatus').style.background = 'rgba(76, 175, 80, 0.2)';
                    document.getElementById('serviceStatus').style.color = '#81c784';
                } else {
                    document.getElementById('headerStatus').textContent = 'Offline';
                    document.getElementById('headerStatus').style.color = '#f44336';
                    document.getElementById('serviceStatus').textContent = 'Offline';
                    document.getElementById('serviceStatus').style.background = 'rgba(244, 67, 54, 0.2)';
                    document.getElementById('serviceStatus').style.color = '#e57373';
                }
            } catch (error) {
                console.error('Header status update failed:', error);
                document.getElementById('headerStatus').textContent = 'Offline';
                document.getElementById('headerStatus').style.color = '#f44336';
                document.getElementById('serviceStatus').textContent = 'Offline';
                document.getElementById('serviceStatus').style.background = 'rgba(244, 67, 54, 0.2)';
                document.getElementById('serviceStatus').style.color = '#e57373';
            }
        }

        // Utility Functions
        function formatPrice(value) {
            if (value == null) return '-';
            if (value >= 1000) return value.toFixed(0);
            if (value >= 1) return value.toFixed(2);
            return value.toFixed(5);
        }

        function formatPatternName(type) {
            return type.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
        }

        // =====================================================
        // Revalidierung Functions
        // =====================================================

        // Load History Statistics
        async function loadHistoryStats() {
            try {
                const response = await fetch('/cnn-lstm/api/v1/history/statistics');
                const data = await response.json();

                document.getElementById('stat-total-predictions').textContent = data.total_predictions || 0;
                document.getElementById('stat-symbols').textContent = data.symbols_count || 0;
                document.getElementById('stat-confirmed').textContent = data.by_feedback_status?.confirmed || 0;
                document.getElementById('stat-corrected').textContent =
                    (data.by_feedback_status?.corrected || 0) + (data.by_feedback_status?.rejected || 0);
                document.getElementById('stat-avg-confidence').textContent =
                    data.avg_confidence ? (data.avg_confidence * 100).toFixed(0) + '%' : '-';
                document.getElementById('stat-scan-status').textContent = data.scan_running ? 'Aktiv' : 'Inaktiv';
                document.getElementById('stat-scan-status').style.color = data.scan_running ? '#81c784' : '#888';

                // Load feedback stats too
                loadFeedbackStats();

            } catch (error) {
                showToast('Fehler beim Laden der Statistiken: ' + error.message, 'error');
            }
        }

        // Trigger Prediction Scan with Progress
        let scanPollingInterval = null;

        async function triggerPredictionScan() {
            const scanBtn = document.querySelector('button[onclick="triggerPredictionScan()"]');
            const progressContainer = document.getElementById('scan-progress-container');
            const progressBar = document.getElementById('scan-progress-bar');
            const progressStats = document.getElementById('scan-progress-stats');
            const currentSymbol = document.getElementById('scan-current-symbol');
            const newPredictions = document.getElementById('scan-new-predictions');
            const scanStatus = document.getElementById('stat-scan-status');

            try {
                // Disable button and show progress
                scanBtn.disabled = true;
                scanBtn.innerHTML = '&#9203; Läuft...';
                progressContainer.classList.add('active');
                progressBar.style.width = '0%';
                scanStatus.textContent = 'Läuft';
                scanStatus.style.color = '#64c8ff';

                // Start scan (async)
                const response = await fetch('/cnn-lstm/api/v1/history/scan', { method: 'POST' });

                if (!response.ok) {
                    throw new Error('Scan konnte nicht gestartet werden');
                }

                // Start polling for progress
                let completed = false;
                let pollCount = 0;
                const maxPolls = 120; // Max 2 minutes

                scanPollingInterval = setInterval(async () => {
                    try {
                        pollCount++;

                        // Get scan status
                        const statusResponse = await fetch('/cnn-lstm/api/v1/history/scan/status');
                        const status = await statusResponse.json();

                        // Update progress UI
                        if (status.scan_running) {
                            const progress = status.total_symbols > 0
                                ? Math.round((status.processed_symbols / status.total_symbols) * 100)
                                : 0;

                            progressBar.style.width = progress + '%';
                            progressStats.textContent = `${status.processed_symbols || 0} / ${status.total_symbols || 0} Symbole`;
                            currentSymbol.textContent = status.current_symbol
                                ? `Scanne: ${status.current_symbol}`
                                : 'Verarbeite...';
                            newPredictions.textContent = `Neue Predictions: ${status.new_predictions || 0}`;
                        } else if (status.last_scan_completed || pollCount >= maxPolls) {
                            // Scan completed or timeout
                            completed = true;
                            clearInterval(scanPollingInterval);
                            scanPollingInterval = null;

                            // Final update
                            progressBar.style.width = '100%';
                            progressStats.textContent = 'Abgeschlossen';
                            currentSymbol.textContent = 'Scan beendet';
                            newPredictions.textContent = `Neue Predictions: ${status.total_new_predictions || 0}`;

                            // Hide progress after delay
                            setTimeout(() => {
                                progressContainer.classList.remove('active');
                                scanBtn.disabled = false;
                                scanBtn.innerHTML = '&#128269; Scan starten';
                                scanStatus.textContent = 'Inaktiv';
                                scanStatus.style.color = '#888';
                            }, 2000);

                            showToast(`Scan abgeschlossen: ${status.total_new_predictions || 0} neue Predictions`, 'success');
                            loadHistoryStats();
                        }

                    } catch (pollError) {
                        console.error('Polling error:', pollError);
                    }
                }, 1000); // Poll every second

            } catch (error) {
                // Reset UI on error
                progressContainer.classList.remove('active');
                scanBtn.disabled = false;
                scanBtn.innerHTML = '&#128269; Scan starten';
                scanStatus.textContent = 'Fehler';
                scanStatus.style.color = '#e57373';

                if (scanPollingInterval) {
                    clearInterval(scanPollingInterval);
                    scanPollingInterval = null;
                }

                showToast('Fehler beim Scan: ' + error.message, 'error');
            }
        }

        // Load Prediction History
        async function loadPredictionHistory() {
            const container = document.getElementById('prediction-history-content');
            const symbolFilter = document.getElementById('history-symbol-filter').value;
            const resultFilter = document.getElementById('history-result-filter').value;

            container.innerHTML = '<div class="loading"><div class="spinner"></div><p>Lade History...</p></div>';

            try {
                // Fetch predictions and backtest results in parallel
                let historyUrl = '/cnn-lstm/api/v1/history?limit=50';
                if (symbolFilter) historyUrl += `&symbol=${symbolFilter}`;

                const [historyResponse, backtestResponse] = await Promise.all([
                    fetch(historyUrl),
                    fetch('/cnn-lstm/api/v1/backtest/results?limit=200')
                ]);

                const data = await historyResponse.json();
                const backtestData = await backtestResponse.json();

                // Create lookup map for backtest results by prediction_id
                const backtestMap = {};
                if (backtestData.results) {
                    backtestData.results.forEach(bt => {
                        backtestMap[bt.prediction_id] = bt;
                    });
                }

                // Merge backtest results into predictions
                let predictions = data.predictions || [];
                predictions = predictions.map(p => ({
                    ...p,
                    backtest_result: backtestMap[p.id] || null
                }));

                // Apply result filter
                if (resultFilter === 'correct') {
                    predictions = predictions.filter(p => p.backtest_result?.price_direction_correct === true);
                } else if (resultFilter === 'wrong') {
                    predictions = predictions.filter(p => p.backtest_result?.price_direction_correct === false);
                } else if (resultFilter === 'pending') {
                    predictions = predictions.filter(p => !p.backtest_result);
                }

                if (predictions.length === 0) {
                    container.innerHTML = '<div class="empty-state"><p>Keine Predictions gefunden</p></div>';
                    return;
                }

                container.innerHTML = `
                    <table class="feature-table">
                        <thead>
                            <tr>
                                <th>Zeitpunkt</th>
                                <th>Symbol</th>
                                <th>TF</th>
                                <th>Richtung</th>
                                <th>Konfidenz</th>
                                <th>Regime</th>
                                <th>Ergebnis</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${predictions.map(p => `
                                <tr>
                                    <td>${new Date(p.timestamp).toLocaleString('de-DE', {dateStyle: 'short', timeStyle: 'short'})}</td>
                                    <td><strong>${p.symbol}</strong></td>
                                    <td>${p.timeframe}</td>
                                    <td><span class="prediction-badge ${p.price_direction}">${p.price_direction}</span></td>
                                    <td>${((p.price_confidence || 0) * 100).toFixed(0)}%</td>
                                    <td>${formatRegimeName(p.regime_current)}</td>
                                    <td>${formatBacktestResult(p)}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                    <div style="margin-top: 0.5rem; font-size: 0.8rem; color: #888;">
                        Zeige ${predictions.length} von ${data.count || predictions.length} Predictions
                    </div>
                `;

            } catch (error) {
                container.innerHTML = `<div class="empty-state"><p>Fehler: ${error.message}</p></div>`;
            }
        }

        // Format backtest result for display
        function formatBacktestResult(prediction) {
            // Check if backtest data is available
            if (prediction.backtest_result) {
                const bt = prediction.backtest_result;
                if (bt.price_direction_correct) {
                    return '<span class="prediction-badge bullish" title="Richtung korrekt">&#10003; Korrekt</span>';
                } else {
                    return '<span class="prediction-badge bearish" title="Richtung falsch">&#10007; Falsch</span>';
                }
            }

            // Check based on feedback_status (for backward compatibility)
            if (prediction.feedback_status === 'confirmed') {
                return '<span class="prediction-badge bullish">&#10003; Korrekt</span>';
            } else if (prediction.feedback_status === 'rejected') {
                return '<span class="prediction-badge bearish">&#10007; Falsch</span>';
            }

            // Check if enough time has passed for backtest (based on timeframe)
            const predTime = new Date(prediction.timestamp);
            const now = new Date();
            const hoursPassed = (now - predTime) / (1000 * 60 * 60);

            // Minimum wait times per timeframe
            const waitHours = {
                'M5': 0.5, 'M15': 1, 'M30': 2, 'H1': 4, 'H4': 12, 'D1': 48, 'W1': 336
            };
            const minWait = waitHours[prediction.timeframe] || 4;

            if (hoursPassed < minWait) {
                return `<span class="prediction-badge neutral" title="Warte auf Validierung">&#8987; Ausstehend</span>`;
            }

            return '<span class="prediction-badge neutral" title="Noch nicht validiert">- Offen</span>';
        }

        // Run Auto-Backtest - validates predictions against real market data
        async function runAutoBacktest() {
            const btn = event.target;
            const originalText = btn.innerHTML;
            btn.innerHTML = '&#8987; Läuft...';
            btn.disabled = true;

            try {
                // Start backtest
                const response = await fetch('/cnn-lstm/api/v1/backtest/run', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        symbols: [], // Empty = all symbols
                        timeframes: [], // Empty = all timeframes
                        days_back: 7
                    })
                });

                if (!response.ok) {
                    throw new Error('Backtest fehlgeschlagen');
                }

                const result = await response.json();

                showToast(`Backtest abgeschlossen: ${result.backtested || 0} Predictions validiert`, 'success');

                // Reload history to show updated results
                loadPredictionHistory();
                loadHistoryStats();
                loadBacktestSummary();

            } catch (error) {
                showToast('Fehler beim Backtest: ' + error.message, 'error');
            } finally {
                btn.innerHTML = originalText;
                btn.disabled = false;
            }
        }

        // Load Backtest Summary
        async function loadBacktestSummary() {
            try {
                const response = await fetch('/cnn-lstm/api/v1/backtest/summary');
                const data = await response.json();

                // Update stats
                document.getElementById('stat-backtest-total').textContent = data.backtested || 0;
                document.getElementById('stat-backtest-accuracy').textContent =
                    data.price_direction_accuracy ? data.price_direction_accuracy.toFixed(1) + '%' : '-';
                document.getElementById('stat-backtest-regime').textContent =
                    data.regime_accuracy ? data.regime_accuracy.toFixed(1) + '%' : '-';

            } catch (error) {
                console.error('Backtest summary error:', error);
            }
        }

        // Toggle Backtest Scheduler
        async function toggleBacktestScheduler() {
            const btn = document.getElementById('scheduler-toggle-btn');
            const configDiv = document.getElementById('scheduler-config');

            try {
                // Check current status first
                const statusResponse = await fetch('/cnn-lstm/api/v1/backtest/scheduler/status');
                const status = await statusResponse.json();

                if (status.running) {
                    // Stop scheduler
                    const response = await fetch('/cnn-lstm/api/v1/backtest/scheduler/stop', {
                        method: 'POST'
                    });

                    if (!response.ok) throw new Error('Scheduler stoppen fehlgeschlagen');

                    btn.innerHTML = '&#9202; Scheduler starten';
                    btn.classList.remove('btn-warning');
                    btn.classList.add('btn-primary');
                    configDiv.style.display = 'none';
                    document.getElementById('stat-scheduler-status').textContent = 'Inaktiv';
                    showToast('Auto-Backtest Scheduler gestoppt', 'info');

                } else {
                    // Start scheduler
                    const intervalHours = parseFloat(document.getElementById('scheduler-interval').value);

                    const response = await fetch('/cnn-lstm/api/v1/backtest/scheduler/start', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ interval_hours: intervalHours })
                    });

                    if (!response.ok) throw new Error('Scheduler starten fehlgeschlagen');

                    btn.innerHTML = '&#9209; Scheduler stoppen';
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-warning');
                    configDiv.style.display = 'block';
                    document.getElementById('stat-scheduler-status').textContent = `Aktiv (${intervalHours}h)`;
                    showToast(`Auto-Backtest Scheduler gestartet (Intervall: ${intervalHours}h)`, 'success');

                    // Start polling for status updates
                    startSchedulerStatusPolling();
                }

            } catch (error) {
                showToast('Fehler: ' + error.message, 'error');
            }
        }

        // Load scheduler status
        async function loadSchedulerStatus() {
            try {
                const response = await fetch('/cnn-lstm/api/v1/backtest/scheduler/status');
                const status = await response.json();

                const btn = document.getElementById('scheduler-toggle-btn');
                const configDiv = document.getElementById('scheduler-config');

                if (status.running) {
                    btn.innerHTML = '&#9209; Scheduler stoppen';
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-warning');
                    configDiv.style.display = 'block';
                    document.getElementById('stat-scheduler-status').textContent = `Aktiv (${status.interval_hours}h)`;

                    // Update next run info
                    if (status.next_run_in_seconds !== null) {
                        const mins = Math.floor(status.next_run_in_seconds / 60);
                        document.getElementById('scheduler-next-run').textContent =
                            `Nächster Backtest in ${mins} Minuten`;
                    }

                    // Show auto-start info
                    const autoStartSpan = document.getElementById('scheduler-auto-start');
                    if (status.auto_start_enabled) {
                        autoStartSpan.innerHTML = '&#x2705; Auto-Start aktiviert';
                    } else {
                        autoStartSpan.textContent = '';
                    }
                } else {
                    btn.innerHTML = '&#9202; Scheduler starten';
                    btn.classList.remove('btn-warning');
                    btn.classList.add('btn-primary');
                    configDiv.style.display = 'none';

                    // Show hint if auto-start is enabled
                    if (status.auto_start_enabled) {
                        document.getElementById('stat-scheduler-status').innerHTML =
                            `<span style="color: #81c784;">Auto-Start (${status.auto_start_interval}h)</span>`;
                    } else {
                        document.getElementById('stat-scheduler-status').textContent = 'Inaktiv';
                    }
                }

            } catch (error) {
                console.error('Scheduler status error:', error);
            }
        }

        let schedulerPollingInterval = null;

        function startSchedulerStatusPolling() {
            if (schedulerPollingInterval) return;

            schedulerPollingInterval = setInterval(async () => {
                try {
                    const response = await fetch('/cnn-lstm/api/v1/backtest/scheduler/status');
                    const status = await response.json();

                    if (!status.running) {
                        clearInterval(schedulerPollingInterval);
                        schedulerPollingInterval = null;
                        loadSchedulerStatus();
                        return;
                    }

                    // Update next run info
                    if (status.next_run_in_seconds !== null) {
                        const mins = Math.floor(status.next_run_in_seconds / 60);
                        document.getElementById('scheduler-next-run').textContent =
                            `Nächster Backtest in ${mins} Minuten`;
                    }

                    // If a backtest just completed, reload data
                    if (status.last_result && status.last_result.new_backtests > 0) {
                        loadBacktestSummary();
                        loadPredictionHistory();
                    }

                } catch (error) {
                    console.error('Scheduler polling error:', error);
                }
            }, 30000); // Poll every 30 seconds
        }

        // Load Feedback Statistics
        async function loadFeedbackStats() {
            try {
                const response = await fetch('/cnn-lstm/api/v1/feedback/statistics');
                const data = await response.json();

                document.getElementById('stat-feedback-total').textContent = data.total_feedback || 0;
                document.getElementById('stat-pending-reval').textContent = data.pending_revalidation || 0;
                document.getElementById('stat-improvement-rate').textContent =
                    data.improvement_rate ? data.improvement_rate.toFixed(1) + '%' : '-';

            } catch (error) {
                console.error('Feedback stats error:', error);
            }
        }

        // Load Pending Revalidation
        async function loadPendingRevalidation() {
            const container = document.getElementById('pending-revalidation-content');
            container.innerHTML = '<div class="loading"><div class="spinner"></div><p>Lade...</p></div>';

            try {
                const response = await fetch('/cnn-lstm/api/v1/feedback/pending-revalidation');
                const data = await response.json();

                if (!data.pending || data.pending.length === 0) {
                    container.innerHTML = '<div class="empty-state"><p>Keine Predictions zur Revalidierung</p></div>';
                    return;
                }

                container.innerHTML = `
                    <table class="feature-table">
                        <thead>
                            <tr>
                                <th>Symbol</th>
                                <th>Timeframe</th>
                                <th>Feedback Typ</th>
                                <th>Grund</th>
                                <th>Feedback Datum</th>
                                <th>Aktionen</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${data.pending.map(p => `
                                <tr>
                                    <td><strong>${p.symbol}</strong></td>
                                    <td>${p.timeframe}</td>
                                    <td><span class="prediction-badge ${getFeedbackClass(p.feedback_type)}">${p.feedback_type}</span></td>
                                    <td>${p.reason_category || '-'}</td>
                                    <td>${new Date(p.feedback_timestamp).toLocaleString('de-DE', {dateStyle: 'short'})}</td>
                                    <td>
                                        <button class="btn btn-success" style="padding: 0.25rem 0.5rem; font-size: 0.75rem;"
                                            onclick="markRevalidated('${p.id}', 'correct')">Korrekt</button>
                                        <button class="btn btn-warning" style="padding: 0.25rem 0.5rem; font-size: 0.75rem;"
                                            onclick="markRevalidated('${p.id}', 'now_correct')">Jetzt OK</button>
                                        <button class="btn btn-danger" style="padding: 0.25rem 0.5rem; font-size: 0.75rem;"
                                            onclick="markRevalidated('${p.id}', 'still_wrong')">Noch falsch</button>
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;

            } catch (error) {
                container.innerHTML = `<div class="empty-state"><p>Fehler: ${error.message}</p></div>`;
            }
        }

        // Mark as Revalidated
        async function markRevalidated(feedbackId, result) {
            try {
                const response = await fetch('/cnn-lstm/api/v1/feedback/revalidate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        feedback_id: feedbackId,
                        validation_result: result
                    })
                });

                if (!response.ok) throw new Error('Revalidierung fehlgeschlagen');

                showToast(`Revalidiert: ${result}`, 'success');
                loadPendingRevalidation();
                loadFeedbackStats();

            } catch (error) {
                showToast('Fehler: ' + error.message, 'error');
            }
        }

        // Reset Revalidation
        async function resetRevalidation() {
            if (!confirm('Alle Revalidierungsstatus zurücksetzen? (Nach neuem Training)')) return;

            try {
                const response = await fetch('/cnn-lstm/api/v1/feedback/reset-revalidation', { method: 'POST' });
                const data = await response.json();

                showToast(`Reset: ${data.reset_count} Einträge zurückgesetzt`, 'success');
                loadFeedbackStats();

            } catch (error) {
                showToast('Fehler: ' + error.message, 'error');
            }
        }

        // Run Backtests
        async function runBacktests() {
            try {
                showToast('Starte Backtests...', 'info');
                const response = await fetch('/cnn-lstm/api/v1/backtest/run', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ max_backtests: 50 })
                });
                const data = await response.json();

                showToast(`Backtests: ${data.new_backtests} neu, ${data.skipped} übersprungen`, 'success');
                loadBacktestSummary();

            } catch (error) {
                showToast('Fehler: ' + error.message, 'error');
            }
        }

        // Load Backtest Summary
        async function loadBacktestSummary() {
            try {
                const response = await fetch('/cnn-lstm/api/v1/backtest/summary');
                const data = await response.json();

                document.getElementById('stat-backtest-total').textContent = data.backtested || 0;
                document.getElementById('stat-direction-accuracy').textContent =
                    data.price_direction_accuracy ? data.price_direction_accuracy.toFixed(1) + '%' : '-';
                document.getElementById('stat-regime-accuracy').textContent =
                    data.regime_accuracy ? data.regime_accuracy.toFixed(1) + '%' : '-';
                document.getElementById('stat-mae-1d').textContent =
                    data.price_mae_1d ? data.price_mae_1d.toFixed(2) : '-';

                // Show by symbol breakdown
                const container = document.getElementById('backtest-results-content');
                if (data.by_symbol && Object.keys(data.by_symbol).length > 0) {
                    container.innerHTML = `
                        <table class="feature-table">
                            <thead>
                                <tr>
                                    <th>Symbol</th>
                                    <th>Tests</th>
                                    <th>Direction Correct</th>
                                    <th>Accuracy</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${Object.entries(data.by_symbol).map(([symbol, stats]) => `
                                    <tr>
                                        <td><strong>${symbol}</strong></td>
                                        <td>${stats.total}</td>
                                        <td>${stats.direction_correct}</td>
                                        <td><span class="prediction-badge ${stats.accuracy >= 50 ? 'bullish' : 'bearish'}">${stats.accuracy}%</span></td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    `;
                } else {
                    container.innerHTML = '<div class="empty-state"><p>Noch keine Backtest-Ergebnisse</p></div>';
                }

            } catch (error) {
                showToast('Fehler: ' + error.message, 'error');
            }
        }

        // Clear Backtests
        async function clearBacktests() {
            if (!confirm('Alle Backtest-Ergebnisse löschen?')) return;

            try {
                await fetch('/cnn-lstm/api/v1/backtest/clear', { method: 'POST' });
                showToast('Backtest-Ergebnisse gelöscht', 'success');
                loadBacktestSummary();
            } catch (error) {
                showToast('Fehler: ' + error.message, 'error');
            }
        }

        // Load Claude Validation Statistics
        async function loadClaudeValidationStats() {
            try {
                const response = await fetch('/cnn-lstm/api/v1/validate/claude/statistics');
                const data = await response.json();

                document.getElementById('stat-claude-total').textContent = data.total_validations || 0;
                document.getElementById('stat-claude-agreement').textContent =
                    data.agreement_rate ? data.agreement_rate.toFixed(1) + '%' : '-';

            } catch (error) {
                showToast('Fehler: ' + error.message, 'error');
            }
        }

        // Check Claude Status
        async function checkClaudeStatus() {
            try {
                const response = await fetch('/cnn-lstm/api/v1/validate/claude/status');
                const data = await response.json();

                const statusEl = document.getElementById('stat-claude-status');
                if (data.enabled && data.api_configured) {
                    statusEl.textContent = 'Aktiv';
                    statusEl.style.color = '#81c784';
                } else {
                    statusEl.textContent = 'Inaktiv';
                    statusEl.style.color = '#e57373';
                }

                showToast(`Claude API: ${data.api_configured ? 'Konfiguriert' : 'Nicht konfiguriert'}`,
                    data.api_configured ? 'success' : 'warning');

            } catch (error) {
                showToast('Fehler: ' + error.message, 'error');
            }
        }

        // Helper Functions
        function formatRegimeName(regime) {
            const names = {
                'bull_trend': 'Bull',
                'bear_trend': 'Bear',
                'sideways': 'Sideways',
                'high_volatility': 'High Vol'
            };
            return names[regime] || regime;
        }

        function getFeedbackClass(status) {
            const classes = {
                'pending': 'neutral',
                'confirmed': 'bullish',
                'corrected': 'bearish',
                'rejected': 'bearish'
            };
            return classes[status] || 'neutral';
        }

        // =====================================================
        // Symbol Set Management
        // =====================================================

        // Default Symbol Sets (can be customized)
        const defaultSymbolSets = {
            core: {
                name: 'Kern (Krypto + Forex)',
                symbols: 'BTCUSD,ETHUSD,EURUSD,GBPUSD,USDJPY',
                description: '2 Krypto + 3 Forex Major Pairs - gute Datenverfügbarkeit'
            },
            crypto: {
                name: 'Krypto Top 5',
                symbols: 'BTCUSD,ETHUSD,SOLUSD,XRPUSD,BNBUSD',
                description: 'Top 5 Kryptowährungen nach Marktkapitalisierung'
            },
            forex: {
                name: 'Forex Majors',
                symbols: 'EURUSD,GBPUSD,USDJPY,USDCHF,AUDUSD,USDCAD',
                description: '6 Major Forex Pairs mit hoher Liquidität'
            },
            mixed: {
                name: 'Gemischt (Maximum)',
                symbols: 'BTCUSD,ETHUSD,EURUSD,GBPUSD,USDJPY,XAUUSD,SPX500',
                description: 'Krypto + Forex + Gold + Index - maximale Diversifikation'
            },
            stocks: {
                name: 'US Aktien',
                symbols: 'AAPL,MSFT,GOOGL,AMZN,NVDA',
                description: 'Top 5 US Tech-Aktien'
            }
        };

        // Load symbol sets from localStorage or use defaults
        function loadSymbolSets() {
            const saved = localStorage.getItem('cnnLstmSymbolSets');
            if (saved) {
                return JSON.parse(saved);
            }
            return { ...defaultSymbolSets };
        }

        // Save symbol sets to localStorage
        function saveSymbolSets(sets) {
            localStorage.setItem('cnnLstmSymbolSets', JSON.stringify(sets));
        }

        let symbolSets = loadSymbolSets();

        // Apply selected symbol set to the form
        function applySymbolSet() {
            const select = document.getElementById('train-symbol-set');
            const symbolsInput = document.getElementById('train-symbols');
            const description = document.getElementById('symbol-set-description');
            const setKey = select.value;

            if (setKey === 'custom') {
                description.textContent = 'Eigene Symbole eingeben';
                return;
            }

            const set = symbolSets[setKey];
            if (set) {
                symbolsInput.value = set.symbols;
                description.textContent = set.description;
            }
        }

        // Open Symbol Set Manager Modal
        function openSymbolSetManager() {
            renderSymbolSetList();
            document.getElementById('symbol-set-modal').classList.add('active');
        }

        // Close Symbol Set Manager Modal
        function closeSymbolSetManager() {
            document.getElementById('symbol-set-modal').classList.remove('active');
        }

        // Render the list of symbol sets in the modal
        function renderSymbolSetList() {
            const container = document.getElementById('symbol-set-list');
            let html = '';

            for (const [key, set] of Object.entries(symbolSets)) {
                html += `
                    <div class="symbol-set-item" id="symbol-set-${key}">
                        <div class="symbol-set-header">
                            <span class="symbol-set-name">${set.name}</span>
                            <div class="btn-group">
                                <button class="btn btn-primary" onclick="editSymbolSet('${key}')" style="padding: 0.25rem 0.5rem; font-size: 0.75rem;">
                                    &#9998; Bearbeiten
                                </button>
                                <button class="btn btn-danger" onclick="resetSymbolSet('${key}')" style="padding: 0.25rem 0.5rem; font-size: 0.75rem;">
                                    &#8635; Reset
                                </button>
                            </div>
                        </div>
                        <div class="symbol-set-symbols">${set.symbols}</div>
                        <small style="color: #666; font-size: 0.7rem;">${set.description}</small>
                        <div id="symbol-set-edit-${key}" style="display: none; margin-top: 0.5rem;">
                            <input type="text" class="symbol-set-input" id="symbol-set-input-${key}" value="${set.symbols}" placeholder="Symbole kommagetrennt">
                            <input type="text" class="symbol-set-input" id="symbol-set-desc-${key}" value="${set.description}" placeholder="Beschreibung" style="margin-top: 0.25rem;">
                            <div class="btn-group" style="margin-top: 0.5rem;">
                                <button class="btn btn-success" onclick="saveSymbolSetEdit('${key}')" style="padding: 0.25rem 0.5rem; font-size: 0.75rem;">
                                    &#10003; Speichern
                                </button>
                                <button class="btn btn-warning" onclick="cancelSymbolSetEdit('${key}')" style="padding: 0.25rem 0.5rem; font-size: 0.75rem;">
                                    &#10007; Abbrechen
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        // Edit a symbol set
        function editSymbolSet(key) {
            document.getElementById(`symbol-set-${key}`).classList.add('editing');
            document.getElementById(`symbol-set-edit-${key}`).style.display = 'block';
        }

        // Cancel editing a symbol set
        function cancelSymbolSetEdit(key) {
            document.getElementById(`symbol-set-${key}`).classList.remove('editing');
            document.getElementById(`symbol-set-edit-${key}`).style.display = 'none';
            // Reset input values
            document.getElementById(`symbol-set-input-${key}`).value = symbolSets[key].symbols;
            document.getElementById(`symbol-set-desc-${key}`).value = symbolSets[key].description;
        }

        // Save edited symbol set
        function saveSymbolSetEdit(key) {
            const newSymbols = document.getElementById(`symbol-set-input-${key}`).value.trim().toUpperCase();
            const newDesc = document.getElementById(`symbol-set-desc-${key}`).value.trim();

            if (!newSymbols) {
                showToast('Symbole dürfen nicht leer sein', 'error');
                return;
            }

            symbolSets[key].symbols = newSymbols;
            symbolSets[key].description = newDesc || symbolSets[key].description;
            saveSymbolSets(symbolSets);

            document.getElementById(`symbol-set-${key}`).classList.remove('editing');
            document.getElementById(`symbol-set-edit-${key}`).style.display = 'none';

            renderSymbolSetList();
            updateSymbolSetDropdown();
            showToast(`Set "${symbolSets[key].name}" gespeichert`, 'success');
        }

        // Reset a symbol set to default
        function resetSymbolSet(key) {
            if (defaultSymbolSets[key]) {
                symbolSets[key] = { ...defaultSymbolSets[key] };
                saveSymbolSets(symbolSets);
                renderSymbolSetList();
                updateSymbolSetDropdown();
                showToast(`Set "${symbolSets[key].name}" zurückgesetzt`, 'success');
            }
        }

        // Reset all symbol sets to defaults
        function resetAllSymbolSets() {
            if (!confirm('Alle Symbol-Sets auf Standardwerte zurücksetzen?')) return;

            symbolSets = { ...defaultSymbolSets };
            saveSymbolSets(symbolSets);
            renderSymbolSetList();
            updateSymbolSetDropdown();
            showToast('Alle Sets zurückgesetzt', 'success');
        }

        // Update the dropdown options (in case names changed)
        function updateSymbolSetDropdown() {
            const select = document.getElementById('train-symbol-set');
            const currentValue = select.value;

            // Keep custom option, update the rest
            let html = '<option value="custom">Benutzerdefiniert</option>';
            for (const [key, set] of Object.entries(symbolSets)) {
                const selected = key === currentValue ? ' selected' : '';
                html += `<option value="${key}"${selected}>${set.name}</option>`;
            }
            select.innerHTML = html;
        }

        // =================================================================
        // Self-Learning System Functions
        // =================================================================

        async function loadSelfLearningStatus() {
            try {
                const response = await fetch('/cnn-lstm/api/v1/retrain/status');
                const status = await response.json();

                const btn = document.getElementById('retrain-toggle-btn');

                if (status.enabled) {
                    btn.innerHTML = '&#9989; Aktiviert';
                    btn.classList.remove('btn-danger');
                    btn.classList.add('btn-purple');
                } else {
                    btn.innerHTML = '&#10060; Deaktiviert';
                    btn.classList.remove('btn-purple');
                    btn.classList.add('btn-danger');
                }

                // Update stats
                document.getElementById('stat-retrain-threshold').textContent =
                    `${status.config.accuracy_threshold}%`;

                // Update cooldown display
                if (status.cooldown_active && status.cooldown_remaining_seconds) {
                    const hours = Math.floor(status.cooldown_remaining_seconds / 3600);
                    const mins = Math.floor((status.cooldown_remaining_seconds % 3600) / 60);
                    document.getElementById('stat-retrain-cooldown').textContent = `${hours}h ${mins}m`;
                } else {
                    document.getElementById('stat-retrain-cooldown').textContent = 'Bereit';
                }

                // Update selects to match current config
                document.getElementById('retrain-threshold-select').value =
                    status.config.accuracy_threshold.toString();
                document.getElementById('retrain-cooldown-select').value =
                    status.config.cooldown_hours.toString();
                document.getElementById('retrain-focus-errors').checked =
                    status.config.focus_on_errors;

                // Update min_samples select if it exists
                const minSamplesSelect = document.getElementById('retrain-min-samples-select');
                if (minSamplesSelect) {
                    minSamplesSelect.value = status.config.min_samples.toString();
                }

                // Load statistics and history
                await loadRetrainStatistics();
                await loadRetrainHistory();
                await loadCurrentPerformance();

            } catch (error) {
                console.error('Error loading self-learning status:', error);
            }
        }

        async function loadRetrainStatistics() {
            try {
                const response = await fetch('/cnn-lstm/api/v1/retrain/statistics');
                const stats = await response.json();

                document.getElementById('stat-retrain-total').textContent = stats.total_retrains;

                if (stats.average_improvement !== 0) {
                    const sign = stats.average_improvement > 0 ? '+' : '';
                    document.getElementById('stat-retrain-improvement').textContent =
                        `${sign}${stats.average_improvement.toFixed(1)}%`;
                } else {
                    document.getElementById('stat-retrain-improvement').textContent = '-';
                }

                // Update successful/failed counts
                const successfulEl = document.getElementById('stat-retrain-successful');
                const failedEl = document.getElementById('stat-retrain-failed');
                if (successfulEl) successfulEl.textContent = stats.successful || 0;
                if (failedEl) failedEl.textContent = stats.failed || 0;

            } catch (error) {
                console.error('Error loading retrain statistics:', error);
            }
        }

        async function loadRetrainHistory() {
            try {
                const response = await fetch('/cnn-lstm/api/v1/retrain/history?limit=20');
                const data = await response.json();
                const history = data.history || [];

                const tbody = document.getElementById('retrain-history-body');
                if (!tbody) return;

                if (history.length === 0) {
                    tbody.innerHTML = `
                        <tr>
                            <td colspan="6" style="text-align: center; padding: 2rem; color: #666;">
                                Noch keine Re-Trainings durchgeführt
                            </td>
                        </tr>
                    `;
                    return;
                }

                tbody.innerHTML = history.map(event => {
                    const timestamp = new Date(event.timestamp).toLocaleString('de-CH');
                    const accuracyBefore = event.accuracy_before ? `${event.accuracy_before.toFixed(1)}%` : '-';
                    const accuracyAfter = event.accuracy_after ? `${event.accuracy_after.toFixed(1)}%` : '-';

                    let improvement = '-';
                    let improvementClass = '';
                    if (event.improvement !== null && event.improvement !== undefined) {
                        const sign = event.improvement > 0 ? '+' : '';
                        improvement = `${sign}${event.improvement.toFixed(1)}%`;
                        improvementClass = event.improvement > 0 ? 'color: #81c784;' : 'color: #e57373;';
                    }

                    let statusBadge = '';
                    switch (event.training_status) {
                        case 'completed':
                            statusBadge = '<span class="prediction-badge bullish">Abgeschlossen</span>';
                            break;
                        case 'running':
                            statusBadge = '<span class="prediction-badge neutral">Läuft...</span>';
                            break;
                        case 'failed':
                            statusBadge = '<span class="prediction-badge bearish">Fehlgeschlagen</span>';
                            break;
                        case 'skipped':
                            statusBadge = '<span class="prediction-badge neutral">Übersprungen</span>';
                            break;
                        default:
                            statusBadge = '<span class="prediction-badge neutral">Ausstehend</span>';
                    }

                    return `
                        <tr>
                            <td>${timestamp}</td>
                            <td style="max-width: 200px; overflow: hidden; text-overflow: ellipsis;">${event.reason}</td>
                            <td>${accuracyBefore}</td>
                            <td>${accuracyAfter}</td>
                            <td style="${improvementClass}">${improvement}</td>
                            <td>${statusBadge}</td>
                        </tr>
                    `;
                }).join('');

            } catch (error) {
                console.error('Error loading retrain history:', error);
            }
        }

        async function loadCurrentPerformance() {
            try {
                // Load backtest summary for current accuracy
                const backtestResponse = await fetch('/cnn-lstm/api/v1/backtest/summary');
                const backtestData = await backtestResponse.json();

                const currentAccuracyEl = document.getElementById('stat-current-accuracy');
                const backtestCountEl = document.getElementById('stat-backtest-count');
                const triggerStatusEl = document.getElementById('stat-trigger-status');
                const nextCheckEl = document.getElementById('stat-next-check');

                if (currentAccuracyEl) {
                    const accuracy = backtestData.price_direction_accuracy || 0;
                    currentAccuracyEl.textContent = `${accuracy.toFixed(1)}%`;
                    currentAccuracyEl.style.color = accuracy >= 60 ? '#81c784' : '#e57373';
                }

                if (backtestCountEl) {
                    backtestCountEl.textContent = backtestData.backtested || 0;
                }

                // Load retrain status for trigger info
                const retrainResponse = await fetch('/cnn-lstm/api/v1/retrain/status');
                const retrainData = await retrainResponse.json();

                if (triggerStatusEl) {
                    const accuracy = backtestData.price_direction_accuracy || 0;
                    const threshold = retrainData.config.accuracy_threshold || 60;
                    const minSamples = retrainData.config.min_samples || 20;
                    const currentSamples = backtestData.backtested || 0;

                    if (currentSamples < minSamples) {
                        triggerStatusEl.textContent = `${currentSamples}/${minSamples} Samples`;
                        triggerStatusEl.style.color = '#ffb74d';
                    } else if (accuracy < threshold) {
                        triggerStatusEl.textContent = 'Trigger bereit';
                        triggerStatusEl.style.color = '#e57373';
                    } else {
                        triggerStatusEl.textContent = 'OK';
                        triggerStatusEl.style.color = '#81c784';
                    }
                }

                // Load scheduler status for next check
                const schedulerResponse = await fetch('/cnn-lstm/api/v1/backtest/scheduler/status');
                const schedulerData = await schedulerResponse.json();

                if (nextCheckEl) {
                    if (schedulerData.running && schedulerData.next_run_in_seconds !== null) {
                        const mins = Math.floor(schedulerData.next_run_in_seconds / 60);
                        const hours = Math.floor(mins / 60);
                        if (hours > 0) {
                            nextCheckEl.textContent = `${hours}h ${mins % 60}m`;
                        } else {
                            nextCheckEl.textContent = `${mins}m`;
                        }
                    } else {
                        nextCheckEl.textContent = schedulerData.running ? 'Bald' : 'Inaktiv';
                    }
                }

            } catch (error) {
                console.error('Error loading current performance:', error);
            }
        }

        // =================================================================
        // Learning Progress Chart Functions
        // =================================================================

        let cnnLstmMetricsChart = null;

        async function loadCnnLstmMetricsHistory() {
            const trainingType = document.getElementById('cnn-lstm-metrics-training-type')?.value || 'all';
            const summaryEl = document.getElementById('cnn-lstm-metrics-summary');
            const chartCanvas = document.getElementById('cnn-lstm-metrics-chart');

            if (!chartCanvas) return;

            try {
                // Load from CNN-LSTM Train Service
                const response = await fetch('/cnn-lstm-train/api/v1/models/metrics-history?limit=30');

                if (!response.ok) {
                    // Fallback: Try to build from retrain history
                    await loadMetricsFromRetrainHistory();
                    return;
                }

                const data = await response.json();
                let history = data.history || [];

                if (history.length === 0) {
                    // Fallback: Try to build from retrain history
                    await loadMetricsFromRetrainHistory();
                    return;
                }

                renderMetricsChart(history, summaryEl, chartCanvas);

            } catch (error) {
                console.error('Failed to load CNN-LSTM metrics history:', error);
                // Fallback: Try to build from retrain history
                await loadMetricsFromRetrainHistory();
            }
        }

        async function loadMetricsFromRetrainHistory() {
            const summaryEl = document.getElementById('cnn-lstm-metrics-summary');
            const chartCanvas = document.getElementById('cnn-lstm-metrics-chart');

            try {
                // Load backtest summary for accuracy trend
                const backtestResponse = await fetch('/cnn-lstm/api/v1/backtest/results?limit=50');
                const backtestData = await backtestResponse.json();
                const results = backtestData.results || backtestData || [];

                // Load retrain history for training events
                const retrainResponse = await fetch('/cnn-lstm/api/v1/retrain/history?limit=30');
                const retrainData = await retrainResponse.json();
                const retrainHistory = retrainData.history || [];

                if (results.length === 0 && retrainHistory.length === 0) {
                    summaryEl.innerHTML = 'Keine Metriken-Historie verfügbar. Trainieren Sie Modelle und führen Sie Backtests durch.';
                    if (cnnLstmMetricsChart) {
                        cnnLstmMetricsChart.destroy();
                        cnnLstmMetricsChart = null;
                    }
                    return;
                }

                // Build history from backtest results (group by date)
                const historyByDate = {};

                for (const result of results) {
                    const date = result.backtest_timestamp?.split('T')[0] || result.prediction_timestamp?.split('T')[0];
                    if (!date) continue;

                    if (!historyByDate[date]) {
                        historyByDate[date] = {
                            date: date,
                            correct: 0,
                            total: 0,
                            regime_correct: 0
                        };
                    }

                    historyByDate[date].total++;
                    if (result.price_direction_correct) {
                        historyByDate[date].correct++;
                    }
                    if (result.regime_correct) {
                        historyByDate[date].regime_correct++;
                    }
                }

                // Convert to array and sort by date
                const history = Object.values(historyByDate)
                    .sort((a, b) => a.date.localeCompare(b.date))
                    .map(h => ({
                        date: h.date,
                        avg_accuracy: h.total > 0 ? (h.correct / h.total * 100) : 0,
                        avg_f1: h.total > 0 ? (h.regime_correct / h.total * 100) : 0,
                        deploy_rate: 100,
                        deployed: retrainHistory.filter(r => r.training_status === 'completed').length,
                        rejected: retrainHistory.filter(r => r.training_status === 'failed').length
                    }));

                if (history.length === 0) {
                    summaryEl.innerHTML = 'Keine Metriken-Historie verfügbar. Führen Sie Backtests durch, um den Lernfortschritt zu verfolgen.';
                    return;
                }

                renderMetricsChart(history, summaryEl, chartCanvas);

            } catch (error) {
                console.error('Error building metrics from retrain history:', error);
                if (summaryEl) {
                    summaryEl.innerHTML = '<span style="color: #e57373;">Fehler beim Laden der Metriken-Historie</span>';
                }
            }
        }

        function renderMetricsChart(history, summaryEl, chartCanvas) {
            const labels = history.map(h => h.date);
            const accuracyData = history.map(h => h.avg_accuracy || 0);
            const f1Data = history.map(h => h.avg_f1 || 0);
            const deployRateData = history.map(h => h.deploy_rate || 100);

            const ctx = chartCanvas.getContext('2d');

            // Destroy existing chart
            if (cnnLstmMetricsChart) {
                cnnLstmMetricsChart.destroy();
            }

            // Create new chart
            cnnLstmMetricsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Accuracy %',
                            data: accuracyData,
                            borderColor: '#4caf50',
                            backgroundColor: 'rgba(76, 175, 80, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.3,
                            pointRadius: 4
                        },
                        {
                            label: 'Regime-Accuracy %',
                            data: f1Data,
                            borderColor: '#64c8ff',
                            backgroundColor: 'rgba(100, 200, 255, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.3,
                            pointRadius: 4
                        },
                        {
                            label: 'Deploy-Rate %',
                            data: deployRateData,
                            borderColor: '#ffb74d',
                            backgroundColor: 'rgba(255, 183, 77, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.3,
                            pointRadius: 0,
                            borderDash: [5, 5]
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                color: '#888',
                                font: { size: 11 },
                                boxWidth: 12,
                                padding: 10
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(26, 26, 46, 0.95)',
                            titleColor: '#fff',
                            bodyColor: '#ccc',
                            borderColor: 'rgba(100, 200, 255, 0.3)',
                            borderWidth: 1
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: 'rgba(255, 255, 255, 0.05)' },
                            ticks: { color: '#666', font: { size: 10 } }
                        },
                        y: {
                            min: 0,
                            max: 100,
                            grid: { color: 'rgba(255, 255, 255, 0.05)' },
                            ticks: {
                                color: '#666',
                                font: { size: 10 },
                                callback: v => v + '%'
                            }
                        }
                    }
                }
            });

            // Calculate trend
            const latestAcc = accuracyData[accuracyData.length - 1] || 0;
            const firstAcc = accuracyData[0] || 0;
            const accTrend = latestAcc - firstAcc;

            // Get deployed/rejected from retrain history
            const totalDeployed = history.reduce((sum, h) => sum + (h.deployed || 0), 0) ||
                                  history.filter(h => h.avg_accuracy >= 60).length;
            const totalRejected = history.reduce((sum, h) => sum + (h.rejected || 0), 0);

            const trendIcon = accTrend > 0 ? '&#128200;' : accTrend < 0 ? '&#128201;' : '&#8596;';
            const trendColor = accTrend > 0 ? '#4caf50' : accTrend < 0 ? '#f44336' : '#888';

            summaryEl.innerHTML = `
                <span>${trendIcon} Trend: <span style="color: ${trendColor}; font-weight: 600;">${accTrend > 0 ? '+' : ''}${accTrend.toFixed(1)}%</span></span>
                <span>Letzte Accuracy: <strong>${latestAcc.toFixed(1)}%</strong></span>
                <span>Deployed: <span style="color: #4caf50; font-weight: 600;">${totalDeployed}</span></span>
                <span>Rejected: <span style="color: #f44336; font-weight: 600;">${totalRejected}</span></span>
            `;
        }

        async function toggleSelfLearning() {
            try {
                const response = await fetch('/cnn-lstm/api/v1/retrain/status');
                const status = await response.json();

                // Toggle enabled state
                const newEnabled = !status.enabled;

                await fetch('/cnn-lstm/api/v1/retrain/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled: newEnabled })
                });

                await loadSelfLearningStatus();
                showNotification(
                    newEnabled ? 'Self-Learning aktiviert' : 'Self-Learning deaktiviert',
                    newEnabled ? 'success' : 'warning'
                );

            } catch (error) {
                console.error('Error toggling self-learning:', error);
                showNotification('Fehler beim Umschalten', 'error');
            }
        }

        async function updateRetrainConfig() {
            try {
                const threshold = parseFloat(document.getElementById('retrain-threshold-select').value);
                const cooldown = parseFloat(document.getElementById('retrain-cooldown-select').value);
                const focusErrors = document.getElementById('retrain-focus-errors').checked;

                // Get min_samples if element exists
                const minSamplesEl = document.getElementById('retrain-min-samples-select');
                const minSamples = minSamplesEl ? parseInt(minSamplesEl.value) : null;

                const config = {
                    accuracy_threshold: threshold,
                    cooldown_hours: cooldown,
                    focus_on_errors: focusErrors
                };

                if (minSamples !== null) {
                    config.min_samples = minSamples;
                }

                await fetch('/cnn-lstm/api/v1/retrain/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });

                await loadSelfLearningStatus();

            } catch (error) {
                console.error('Error updating retrain config:', error);
            }
        }

        let manualRetrainPolling = null;

        async function triggerManualRetrain() {
            if (!confirm('Manuelles Re-Training starten? Dies kann einige Zeit dauern.')) {
                return;
            }

            const btn = document.getElementById('manual-retrain-btn');
            const progressContainer = document.getElementById('manual-retrain-progress');
            const progressBar = document.getElementById('manual-retrain-progress-bar');
            const progressText = document.getElementById('manual-retrain-progress-text');
            const statusText = document.getElementById('manual-retrain-status');
            const detailsText = document.getElementById('manual-retrain-details');

            try {
                // Show progress bar and disable button
                btn.disabled = true;
                btn.innerHTML = '&#8987; Training läuft...';
                progressContainer.style.display = 'block';
                progressBar.style.width = '0%';
                progressText.textContent = '0%';
                statusText.textContent = 'Training wird gestartet...';
                detailsText.textContent = '';

                const response = await fetch('/cnn-lstm/api/v1/retrain/trigger', {
                    method: 'POST'
                });
                const result = await response.json();

                if (result.status === 'triggered') {
                    showNotification(
                        `Re-Training gestartet: ${result.event.training_job_id}`,
                        'success'
                    );
                    statusText.textContent = 'Training läuft...';

                    // Start polling for progress
                    pollManualRetrainProgress(result.event.training_job_id);
                } else {
                    showNotification(
                        result.message || 'Re-Training konnte nicht gestartet werden',
                        'error'
                    );
                    resetManualRetrainUI();
                }

            } catch (error) {
                console.error('Error triggering manual retrain:', error);
                showNotification('Fehler beim Starten des Re-Trainings', 'error');
                resetManualRetrainUI();
            }
        }

        function pollManualRetrainProgress(jobId) {
            if (manualRetrainPolling) {
                clearInterval(manualRetrainPolling);
            }

            const progressBar = document.getElementById('manual-retrain-progress-bar');
            const progressText = document.getElementById('manual-retrain-progress-text');
            const statusText = document.getElementById('manual-retrain-status');
            const detailsText = document.getElementById('manual-retrain-details');

            let progress = 5;
            progressBar.style.width = '5%';
            progressText.textContent = '5%';

            manualRetrainPolling = setInterval(async () => {
                try {
                    const response = await fetch('/cnn-lstm-train/api/v1/train/status');
                    const status = await response.json();

                    if (status.is_training) {
                        // Update progress (estimate based on time or epochs if available)
                        progress = Math.min(progress + 2, 95);
                        progressBar.style.width = progress + '%';
                        progressText.textContent = progress + '%';
                        statusText.textContent = `Training läuft... (${status.current_epoch || '-'}/${status.total_epochs || '-'} Epochs)`;

                        if (status.current_loss) {
                            detailsText.textContent = `Loss: ${status.current_loss.toFixed(4)}`;
                        }
                    } else {
                        // Training completed or stopped
                        clearInterval(manualRetrainPolling);
                        manualRetrainPolling = null;

                        progressBar.style.width = '100%';
                        progressBar.style.background = '#81c784';
                        progressText.textContent = '100%';
                        statusText.textContent = '✓ Training abgeschlossen';

                        showNotification('Re-Training abgeschlossen', 'success');

                        // Reload status after short delay
                        setTimeout(async () => {
                            await loadSelfLearningStatus();
                            resetManualRetrainUI();
                        }, 2000);
                    }
                } catch (error) {
                    console.error('Error polling retrain status:', error);
                    detailsText.textContent = 'Status-Abfrage fehlgeschlagen';
                }
            }, 3000);
        }

        function resetManualRetrainUI() {
            const btn = document.getElementById('manual-retrain-btn');
            const progressContainer = document.getElementById('manual-retrain-progress');
            const progressBar = document.getElementById('manual-retrain-progress-bar');

            btn.disabled = false;
            btn.innerHTML = '&#9881; Manuell trainieren';
            progressContainer.style.display = 'none';
            progressBar.style.width = '0%';
            progressBar.style.background = '#ffb74d';

            if (manualRetrainPolling) {
                clearInterval(manualRetrainPolling);
                manualRetrainPolling = null;
            }
        }

        // Initial Load
        document.addEventListener('DOMContentLoaded', () => {
            updateHeaderStatus();
            updateSymbolSetDropdown();
            applySymbolSet(); // Apply default set

            // Check if training is already running
            checkTrainingStatus(false);

            // Load backtest stats and scheduler status
            loadBacktestSummary();
            loadSchedulerStatus();

            // Load self-learning status
            loadSelfLearningStatus();

            // Load Lernfortschritt chart (Features tab is default)
            loadCnnLstmMetricsHistory();
        });
    </script>

    <!-- Symbol Set Manager Modal -->
    <div class="modal-overlay" id="symbol-set-modal" onclick="if(event.target === this) closeSymbolSetManager()">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">&#9881; Symbol-Sets verwalten</h3>
                <button class="modal-close" onclick="closeSymbolSetManager()">&times;</button>
            </div>
            <div class="modal-body" id="symbol-set-list">
                <!-- Symbol sets will be rendered here -->
            </div>
            <div class="modal-footer">
                <button class="btn btn-warning" onclick="resetAllSymbolSets()">&#8635; Alle zurücksetzen</button>
                <button class="btn btn-primary" onclick="closeSymbolSetManager()">Schliessen</button>
            </div>
        </div>
    </div>
</body>
</html>
