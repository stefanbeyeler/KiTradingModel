<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Candlestick Pattern Konfiguration - KI Trading Model</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 50%, #16213e 100%);
            color: #e8e8e8;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1.5rem;
        }

        header {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1rem 0;
            margin-bottom: 1.5rem;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        header .container {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #64c8ff;
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .back-link:hover {
            color: #fff;
        }

        .header-title {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .service-badge {
            background: rgba(156, 39, 176, 0.2);
            color: #ce93d8;
            padding: 0.3rem 0.8rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        /* Card */
        .card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 1.5rem;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .card-title {
            font-size: 1.2rem;
            color: #64c8ff;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .card-description {
            color: #888;
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 600;
            color: #64c8ff;
        }

        .stat-value.success { color: #81c784; }
        .stat-value.warning { color: #ffb74d; }
        .stat-value.error { color: #e57373; }

        .stat-label {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-top: 0.25rem;
        }

        /* Buttons */
        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            font-size: 0.85rem;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
        }

        .btn-primary {
            background: rgba(100, 200, 255, 0.2);
            color: #64c8ff;
            border: 1px solid rgba(100, 200, 255, 0.3);
        }

        .btn-primary:hover {
            background: rgba(100, 200, 255, 0.3);
        }

        .btn-success {
            background: rgba(76, 175, 80, 0.2);
            color: #81c784;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .btn-success:hover {
            background: rgba(76, 175, 80, 0.3);
        }

        .btn-danger {
            background: rgba(244, 67, 54, 0.2);
            color: #e57373;
            border: 1px solid rgba(244, 67, 54, 0.3);
        }

        .btn-danger:hover {
            background: rgba(244, 67, 54, 0.3);
        }

        .btn-warning {
            background: rgba(255, 152, 0, 0.2);
            color: #ffb74d;
            border: 1px solid rgba(255, 152, 0, 0.3);
        }

        .btn-warning:hover {
            background: rgba(255, 152, 0, 0.3);
        }

        .btn-secondary {
            background: rgba(128, 128, 128, 0.2);
            color: #aaa;
            border: 1px solid rgba(128, 128, 128, 0.3);
        }

        .btn-secondary:hover {
            background: rgba(128, 128, 128, 0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-group {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        /* Pattern Grid */
        .pattern-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1rem;
        }

        .pattern-card {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 10px;
            padding: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.08);
            transition: all 0.2s;
        }

        .pattern-card:hover {
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .pattern-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .pattern-name {
            font-weight: 600;
            color: #fff;
        }

        .pattern-badges {
            display: flex;
            gap: 0.3rem;
        }

        .pattern-description {
            font-size: 0.85rem;
            color: #888;
            line-height: 1.4;
        }

        /* Pattern Rules */
        .pattern-rules {
            margin-top: 0.75rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 0.5rem;
        }

        .pattern-rules-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 0.4rem 0;
            font-size: 0.8rem;
            color: #64c8ff;
            transition: color 0.2s;
        }

        .pattern-rules-header:hover {
            color: #fff;
        }

        .pattern-rules-toggle {
            font-size: 0.7rem;
            transition: transform 0.2s;
        }

        .pattern-rules-content {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            padding: 0.75rem;
            margin-top: 0.5rem;
        }

        .pattern-rules-meta {
            margin-bottom: 0.5rem;
        }

        .pattern-candles-badge {
            display: inline-block;
            padding: 0.15rem 0.5rem;
            background: rgba(100, 200, 255, 0.15);
            color: #64c8ff;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 500;
        }

        .pattern-rules-list {
            margin: 0;
            padding-left: 1.2rem;
            font-size: 0.75rem;
            color: #bbb;
            line-height: 1.6;
        }

        .pattern-rules-list li {
            margin-bottom: 0.25rem;
        }

        .pattern-rules-list li::marker {
            color: #64c8ff;
        }

        .pattern-rules-confidence {
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px dashed rgba(255, 255, 255, 0.1);
            font-size: 0.75rem;
            color: #888;
        }

        .pattern-rules-confidence strong {
            color: #ffb74d;
        }

        /* Badges */
        .badge {
            padding: 0.2rem 0.5rem;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 500;
        }

        .badge-bullish { background: rgba(76, 175, 80, 0.2); color: #81c784; }
        .badge-bearish { background: rgba(244, 67, 54, 0.2); color: #e57373; }
        .badge-neutral { background: rgba(255, 152, 0, 0.2); color: #ffb74d; }
        .badge-reversal { background: rgba(156, 39, 176, 0.2); color: #ce93d8; }
        .badge-continuation { background: rgba(33, 150, 243, 0.2); color: #64b5f6; }
        .badge-indecision { background: rgba(158, 158, 158, 0.2); color: #bdbdbd; }

        /* Category Section */
        .category-section {
            margin-bottom: 1.5rem;
        }

        .category-title {
            font-size: 1rem;
            color: #ce93d8;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .category-count {
            background: rgba(156, 39, 176, 0.2);
            padding: 0.15rem 0.5rem;
            border-radius: 10px;
            font-size: 0.75rem;
        }

        /* Timeframe Config */
        .timeframe-list {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .timeframe-badge {
            padding: 0.4rem 0.8rem;
            border-radius: 6px;
            font-size: 0.85rem;
            background: rgba(100, 200, 255, 0.1);
            color: #64c8ff;
            border: 1px solid rgba(100, 200, 255, 0.2);
        }

        /* Scan Status */
        .scan-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            font-size: 0.9rem;
        }

        .scan-status.running {
            color: #81c784;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .scan-status.stopped {
            color: #e57373;
            border: 1px solid rgba(244, 67, 54, 0.3);
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-dot.running {
            background: #81c784;
        }

        .status-dot.stopped {
            background: #e57373;
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Info Grid */
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .info-label {
            color: #888;
        }

        .info-value {
            color: #64c8ff;
            font-weight: 500;
        }

        /* Pattern SVG Example */
        .pattern-example {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            gap: 2px;
            height: 50px;
            margin: 0.75rem 0;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
        }

        .pattern-example .candle {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .pattern-example .wick {
            width: 1px;
            background: #888;
        }

        .pattern-example .body {
            width: 8px;
            min-height: 2px;
            border-radius: 1px;
        }

        .pattern-example .body.bullish {
            background: #81c784;
            border: 1px solid #4caf50;
        }

        .pattern-example .body.bearish {
            background: #e57373;
            border: 1px solid #f44336;
        }

        .pattern-example .body.doji {
            background: #888;
            border: 1px solid #666;
            height: 2px !important;
        }

        /* Pattern Chart Container (clickable for API charts) */
        .pattern-chart-container {
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 6px;
            position: relative;
        }

        .pattern-chart-container:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(100, 200, 255, 0.2);
        }

        .pattern-chart-container:hover::after {
            content: 'üîç Klicken f√ºr Chart';
            position: absolute;
            bottom: 4px;
            right: 4px;
            font-size: 0.65rem;
            color: #64c8ff;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .pattern-chart-container img {
            display: block;
            max-width: 100%;
            height: auto;
            border-radius: 6px;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            color: #fff;
            font-size: 0.9rem;
            z-index: 2000;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s;
        }

        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }

        .toast-success { background: #2e7d32; }
        .toast-error { background: #c62828; }
        .toast-info { background: #1565c0; }

        /* Loading */
        .loading {
            text-align: center;
            padding: 2rem;
            color: #888;
        }

        .spinner {
            display: inline-block;
            width: 30px;
            height: 30px;
            border: 3px solid rgba(100, 200, 255, 0.3);
            border-radius: 50%;
            border-top-color: #64c8ff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 0;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .tab {
            padding: 0.75rem 1.5rem;
            background: transparent;
            border: none;
            color: #888;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.2s;
            border-bottom: 2px solid transparent;
            margin-bottom: -1px;
        }

        .tab:hover {
            color: #64c8ff;
            background: rgba(100, 200, 255, 0.05);
        }

        .tab.active {
            color: #64c8ff;
            border-bottom-color: #64c8ff;
            background: rgba(100, 200, 255, 0.1);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .tab-badge {
            background: #f44336;
            color: white;
            padding: 0.1rem 0.4rem;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 600;
            margin-left: 0.3rem;
            vertical-align: middle;
        }

        /* Revalidation specific styles */
        .revalidation-item {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            border-left: 3px solid #ffb74d;
        }

        .revalidation-item.rejected {
            border-left-color: #e57373;
        }

        .revalidation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .revalidation-meta {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            font-size: 0.85rem;
            color: #888;
            margin-bottom: 0.75rem;
        }

        .revalidation-correction {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            margin-bottom: 0.75rem;
        }

        .revalidation-correction .original {
            color: #e57373;
            text-decoration: line-through;
        }

        .revalidation-correction .arrow {
            color: #888;
        }

        .revalidation-correction .corrected {
            color: #81c784;
            font-weight: 500;
        }

        .revalidation-actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .revalidation-actions .btn {
            padding: 0.4rem 0.8rem;
            font-size: 0.8rem;
        }

        .revalidation-help {
            background: rgba(100, 200, 255, 0.1);
            border-left: 3px solid #64c8ff;
            padding: 0.5rem 0.75rem;
            margin: 0.5rem 0;
            font-size: 0.85rem;
            color: #b0bec5;
            border-radius: 0 4px 4px 0;
        }

        .revalidation-help strong {
            color: #64c8ff;
        }

        .revalidation-chart {
            max-width: 300px;
            margin: 0.75rem 0;
        }

        .revalidation-correction-panel {
            background: rgba(255, 152, 0, 0.1);
            border: 1px solid rgba(255, 152, 0, 0.3);
            border-radius: 6px;
            padding: 0.75rem;
            margin-top: 0.75rem;
        }

        .revalidation-correction-panel .correction-header {
            font-weight: 500;
            color: #ffb74d;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .revalidation-correction-panel .correction-options {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            align-items: center;
        }

        .revalidation-correction-panel .pattern-select {
            flex: 1;
            min-width: 200px;
            padding: 0.4rem 0.6rem;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            font-size: 0.85rem;
        }

        .revalidation-correction-panel .pattern-select option {
            background: #1a1a2e;
            color: #fff;
        }

        .revalidation-correction-panel .pattern-select optgroup {
            background: #1a1a2e;
            color: #888;
            font-style: normal;
        }

        /* Revalidation List View */
        .reval-list-container {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .reval-list-item {
            display: grid;
            grid-template-columns: 100px 1fr 80px 100px 90px 100px 50px;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s ease;
            border-left: 3px solid transparent;
        }

        .reval-list-item:hover {
            background: rgba(100, 200, 255, 0.1);
            border-left-color: #64c8ff;
        }

        .reval-list-item.rejected {
            border-left-color: #e57373;
        }

        .reval-list-item.corrected {
            border-left-color: #ffb74d;
        }

        .reval-list-item .symbol-col {
            font-weight: 600;
            color: #fff;
        }

        .reval-list-item .pattern-col {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .reval-list-item .pattern-col .arrow {
            color: #888;
        }

        .reval-list-item .pattern-col .original {
            color: #e57373;
            text-decoration: line-through;
            opacity: 0.8;
        }

        .reval-list-item .pattern-col .corrected {
            color: #81c784;
        }

        .reval-list-item .timeframe-col {
            text-align: center;
        }

        .reval-list-item .date-col {
            color: #888;
            font-size: 0.85rem;
        }

        .reval-list-item .type-col {
            text-align: center;
        }

        .reval-list-item .arrow-col {
            color: #666;
            text-align: right;
            font-size: 1.2rem;
        }

        .reval-list-header {
            display: grid;
            grid-template-columns: 100px 1fr 80px 100px 90px 100px 50px;
            gap: 0.75rem;
            padding: 0.5rem 1rem;
            font-size: 0.75rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 0.5rem;
        }

        .reval-filters {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
        }

        .reval-filters select,
        .reval-filters input {
            padding: 0.5rem 0.75rem;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: #1a1a2e;
            color: #fff;
            font-size: 0.85rem;
            min-width: 130px;
            cursor: pointer;
        }

        .reval-filters select:hover,
        .reval-filters input:hover {
            border-color: rgba(255, 255, 255, 0.35);
        }

        .reval-filters select:focus,
        .reval-filters input:focus {
            outline: none;
            border-color: #64c8ff;
        }

        .reval-filters select option {
            background: #1a1a2e;
            color: #fff;
            padding: 8px;
        }

        .reval-filters select optgroup {
            background: #1a1a2e;
            color: #888;
            font-style: normal;
            font-weight: 600;
        }

        .reval-filters label {
            font-size: 0.75rem;
            color: #888;
            margin-bottom: 0.25rem;
            display: block;
        }

        .reval-filter-group {
            display: flex;
            flex-direction: column;
        }

        /* Revalidation Detail Modal */
        .reval-detail-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
        }

        .reval-detail-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .reval-detail-modal {
            background: #1a1a2e;
            border-radius: 12px;
            max-width: 900px;
            width: 95%;
            max-height: 90vh;
            overflow-y: auto;
            padding: 1.5rem;
            position: relative;
        }

        .reval-detail-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            color: #888;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            line-height: 1;
        }

        .reval-detail-close:hover {
            color: #fff;
        }

        .reval-detail-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1.5rem;
            padding-right: 2rem;
        }

        .reval-detail-title {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .reval-detail-nav {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .reval-detail-nav button {
            padding: 0.5rem 1rem;
        }

        .reval-detail-nav .nav-counter {
            color: #888;
            font-size: 0.9rem;
            margin: 0 1rem;
        }

        /* Scan suggestions styles */
        .scan-suggestions {
            margin-bottom: 0.75rem;
        }

        .scan-suggestions-header {
            font-size: 0.85rem;
            color: #64c8ff;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .scan-suggestions-header .scan-icon {
            font-size: 1rem;
        }

        .scan-suggestions-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .scan-suggestion-btn {
            padding: 0.5rem 0.8rem;
            border-radius: 6px;
            border: 1px solid rgba(129, 199, 132, 0.5);
            background: rgba(129, 199, 132, 0.15);
            color: #81c784;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s ease;
        }

        .scan-suggestion-btn:hover {
            background: rgba(129, 199, 132, 0.3);
            border-color: #81c784;
        }

        .scan-suggestion-btn.original {
            border-color: rgba(255, 152, 0, 0.5);
            background: rgba(255, 152, 0, 0.15);
            color: #ffb74d;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .scan-suggestion-btn.no-pattern {
            border-color: rgba(239, 83, 80, 0.5);
            background: rgba(239, 83, 80, 0.15);
            color: #ef9a9a;
        }

        .scan-suggestion-btn.no-pattern:hover {
            background: rgba(239, 83, 80, 0.3);
            border-color: #ef5350;
        }

        .correction-divider {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin: 0.75rem 0;
            color: #666;
            font-size: 0.8rem;
        }

        .correction-divider::before,
        .correction-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: rgba(255, 255, 255, 0.1);
        }

        .no-patterns-found {
            padding: 0.5rem;
            color: #888;
            font-size: 0.85rem;
            font-style: italic;
            width: 100%;
        }

        /* Feedback History Styles */
        .feedback-history {
            margin-top: 0.75rem;
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            border-left: 3px solid #64c8ff;
        }

        .feedback-history-title {
            font-size: 0.8rem;
            color: #64c8ff;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .feedback-history-item {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .feedback-history-item:last-child {
            margin-bottom: 0;
        }

        .feedback-history-item.confirmed {
            border-left: 2px solid #81c784;
        }

        .feedback-history-item.corrected {
            border-left: 2px solid #ffb74d;
        }

        .feedback-history-item.rejected {
            border-left: 2px solid #e57373;
        }

        .feedback-history-item.revalidated {
            border-left: 2px solid #64c8ff;
        }

        .feedback-history-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .feedback-history-type {
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .feedback-history-type.confirmed { color: #81c784; }
        .feedback-history-type.corrected { color: #ffb74d; }
        .feedback-history-type.rejected { color: #e57373; }
        .feedback-history-type.revalidated { color: #64c8ff; }

        .feedback-history-time {
            color: #888;
            font-size: 0.75rem;
        }

        .feedback-history-detail {
            color: #aaa;
            font-size: 0.75rem;
        }

        .feedback-history-arrow {
            color: #888;
            margin: 0 0.3rem;
        }

        .feedback-badge-detailed {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
        }

        .feedback-badge-detailed.confirmed {
            background: rgba(129, 199, 132, 0.2);
            color: #81c784;
        }

        .feedback-badge-detailed.corrected {
            background: rgba(255, 183, 77, 0.2);
            color: #ffb74d;
        }

        .feedback-badge-detailed.rejected {
            background: rgba(229, 115, 115, 0.2);
            color: #e57373;
        }

        .feedback-badge-detailed:hover {
            filter: brightness(1.2);
        }

        .feedback-count-badge {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem;
            margin-left: 0.2rem;
        }

        /* Training specific styles */
        .training-status-card {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .training-progress {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin: 0.5rem 0;
        }

        .training-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #64c8ff, #81c784);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .training-form {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .form-group label {
            font-size: 0.85rem;
            color: #888;
        }

        .form-group input,
        .form-group select {
            padding: 0.5rem 0.75rem;
            background: #1a1a2e;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #fff;
            font-size: 0.9rem;
        }

        .form-group select {
            cursor: pointer;
        }

        .form-group select option {
            background: #1a1a2e;
            color: #fff;
            padding: 0.5rem;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #64c8ff;
        }

        /* Filter Dropdowns */
        .filter-controls select {
            background: #1a1a2e;
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .filter-controls select option {
            background: #1a1a2e;
            color: #fff;
            padding: 8px;
        }

        .job-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .job-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            margin-bottom: 0.5rem;
            border-left: 3px solid #888;
        }

        .job-item.completed { border-left-color: #81c784; }
        .job-item.running { border-left-color: #64c8ff; }
        .job-item.failed { border-left-color: #e57373; }
        .job-item.pending { border-left-color: #ffb74d; }

        .job-info {
            flex: 1;
        }

        .job-title {
            font-weight: 500;
            color: #fff;
            margin-bottom: 0.25rem;
        }

        .job-meta {
            font-size: 0.8rem;
            color: #888;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .job-status {
            padding: 0.2rem 0.6rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .job-status.completed { background: rgba(76, 175, 80, 0.2); color: #81c784; }
        .job-status.running { background: rgba(100, 200, 255, 0.2); color: #64c8ff; }
        .job-status.failed { background: rgba(244, 67, 54, 0.2); color: #e57373; }
        .job-status.pending { background: rgba(255, 152, 0, 0.2); color: #ffb74d; }

        .symbol-chips {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 0.5rem;
        }

        .symbol-chip {
            padding: 0.25rem 0.5rem;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 4px;
            font-size: 0.8rem;
            color: #64c8ff;
            cursor: pointer;
            transition: all 0.2s;
        }

        .symbol-chip:hover {
            background: rgba(100, 200, 255, 0.2);
        }

        .symbol-chip.selected {
            background: rgba(100, 200, 255, 0.3);
            border-color: #64c8ff;
        }

        /* Pattern History Styles */
        .history-filters {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        .history-filters select,
        .history-filters input {
            padding: 0.5rem 0.75rem;
            background: #252540;
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 6px;
            color: #fff;
            font-size: 0.85rem;
            min-width: 120px;
        }

        .history-filters select option {
            background: #252540;
            color: #fff;
            padding: 8px 12px;
        }

        .history-filters select:focus {
            outline: none;
            border-color: #64c8ff;
        }

        /* Timeline Styles */
        .timeline-container {
            position: relative;
            max-height: 600px;
            overflow-y: auto;
            padding: 1rem 0;
        }

        .timeline {
            position: relative;
            padding-left: 140px;
        }

        .timeline::before {
            content: '';
            position: absolute;
            left: 130px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: linear-gradient(180deg, rgba(100, 200, 255, 0.3), rgba(100, 200, 255, 0.1));
        }

        .timeline-date-group {
            margin-bottom: 1.5rem;
        }

        .timeline-date-header {
            position: relative;
            font-size: 0.85rem;
            font-weight: 600;
            color: #64c8ff;
            margin-bottom: 0.75rem;
            padding-left: 25px;
        }

        .timeline-date-header::before {
            content: '';
            position: absolute;
            left: -10px;
            top: 50%;
            transform: translateY(-50%);
            width: 10px;
            height: 10px;
            background: #64c8ff;
            border-radius: 50%;
            border: 2px solid #1a1a2e;
        }

        .timeline-item {
            position: relative;
            display: flex;
            align-items: center;
            padding: 0.6rem 1rem;
            margin-bottom: 0.5rem;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            cursor: pointer;
            transition: all 0.2s;
        }

        .timeline-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateX(4px);
        }

        .timeline-item::before {
            content: '';
            position: absolute;
            left: -25px;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 8px;
            border-radius: 50%;
            border: 2px solid;
        }

        .timeline-item.bullish::before {
            background: #81c784;
            border-color: #4caf50;
        }

        .timeline-item.bearish::before {
            background: #e57373;
            border-color: #f44336;
        }

        .timeline-item.neutral::before {
            background: #ffb74d;
            border-color: #ff9800;
        }

        .timeline-time {
            position: absolute;
            left: -130px;
            width: 95px;
            text-align: right;
            font-size: 0.8rem;
            font-weight: 500;
            color: #888;
        }

        .timeline-item.bullish .timeline-time { color: #81c784; }
        .timeline-item.bearish .timeline-time { color: #e57373; }
        .timeline-item.neutral .timeline-time { color: #ffb74d; }

        .timeline-content {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .timeline-pattern-name {
            font-weight: 600;
            color: #fff;
            font-size: 0.95rem;
            min-width: 150px;
        }

        .timeline-symbol {
            font-size: 0.85rem;
            color: #64c8ff;
            font-weight: 500;
            min-width: 70px;
        }

        .timeline-direction {
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .timeline-direction.bullish {
            background: rgba(76, 175, 80, 0.2);
            color: #81c784;
        }

        .timeline-direction.bearish {
            background: rgba(244, 67, 54, 0.2);
            color: #e57373;
        }

        .timeline-direction.neutral {
            background: rgba(255, 152, 0, 0.2);
            color: #ffb74d;
        }

        .timeline-timeframe {
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
            font-size: 0.7rem;
            font-weight: 600;
            background: rgba(100, 200, 255, 0.15);
            color: #64c8ff;
            min-width: 30px;
            text-align: center;
        }

        .timeline-confidence {
            font-size: 0.8rem;
            color: #888;
            min-width: 40px;
            text-align: right;
        }

        .timeline-status {
            margin-left: auto;
            min-width: 100px;
            display: flex;
            justify-content: flex-end;
        }

        .timeline-status-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .timeline-status-badge.pending {
            background: rgba(136, 136, 136, 0.2);
            color: #888;
        }

        .timeline-status-badge.confirmed {
            background: rgba(76, 175, 80, 0.2);
            color: #81c784;
        }

        .timeline-status-badge.corrected {
            background: rgba(255, 152, 0, 0.2);
            color: #ffb74d;
        }

        .timeline-status-badge.rejected {
            background: rgba(244, 67, 54, 0.2);
            color: #e57373;
        }

        .timeline-arrow {
            color: #666;
            font-size: 1.2rem;
            margin-left: 0.5rem;
        }

        /* Feedback Status Badges */
        .timeline-feedback {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            font-size: 0.75rem;
            padding: 0.15rem 0.5rem;
            border-radius: 4px;
            margin-left: 0.5rem;
        }

        .timeline-feedback.confirmed {
            background: rgba(76, 175, 80, 0.2);
            color: #81c784;
        }

        .timeline-feedback.corrected {
            background: rgba(255, 152, 0, 0.2);
            color: #ffb74d;
        }

        .timeline-feedback.rejected {
            background: rgba(244, 67, 54, 0.2);
            color: #e57373;
        }

        .timeline-feedback-icon {
            font-size: 0.9rem;
        }

        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(4px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem;
            line-height: 1;
            transition: color 0.2s;
        }

        .modal-close:hover {
            color: #fff;
        }

        .modal-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.2);
            border-radius: 0 0 12px 12px;
        }

        .modal-nav-btn {
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            color: #64c8ff;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            transition: all 0.2s;
            min-width: 120px;
        }

        .modal-nav-btn:hover:not(:disabled) {
            background: rgba(100, 200, 255, 0.25);
            border-color: #64c8ff;
            transform: translateY(-1px);
        }

        .modal-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .modal-nav-prev {
            justify-content: flex-start;
        }

        .modal-nav-next {
            justify-content: flex-end;
        }

        .modal-nav-counter {
            font-size: 1rem;
            color: #64c8ff;
            font-weight: 600;
            min-width: 100px;
            text-align: center;
        }

        .modal-body {
            padding: 1.5rem;
        }

        .modal-chart-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 0.75rem;
            margin-bottom: 1.5rem;
        }

        .modal-chart {
            width: 100%;
            height: 220px;
            display: block;
        }

        .modal-info-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .modal-info-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 0.75rem;
            border-radius: 6px;
        }

        .modal-info-label {
            font-size: 0.75rem;
            color: #888;
            margin-bottom: 0.25rem;
        }

        .modal-info-value {
            font-size: 1rem;
            color: #fff;
            font-weight: 500;
        }

        .modal-description {
            background: rgba(0, 0, 0, 0.2);
            padding: 1rem;
            border-radius: 6px;
            color: #aaa;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .modal-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
        }

        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            margin-top: 1.5rem;
            padding: 1rem;
        }

        .pagination button {
            padding: 0.5rem 1rem;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 6px;
            color: #64c8ff;
            cursor: pointer;
            transition: all 0.2s;
        }

        .pagination button:hover:not(:disabled) {
            background: rgba(100, 200, 255, 0.2);
        }

        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pagination-info {
            color: #888;
            font-size: 0.85rem;
        }

        .empty-state {
            text-align: center;
            padding: 3rem;
            color: #666;
        }

        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .pattern-grid {
                grid-template-columns: 1fr;
            }

            header .container {
                flex-direction: column;
                gap: 1rem;
            }

            .tabs {
                flex-wrap: wrap;
            }

            .tab {
                flex: 1;
                text-align: center;
            }
        }

        /* Additional Revalidation List Styles */
        .reval-list-symbol {
            font-weight: 600;
            color: #fff;
        }

        .reval-list-pattern {
            color: #ccc;
            font-size: 0.9rem;
        }

        .reval-list-timeframe {
            text-align: center;
        }

        .reval-list-date {
            color: #888;
            font-size: 0.85rem;
        }

        .reval-list-type {
            text-align: center;
        }

        .reval-list-action {
            text-align: right;
        }

        .reval-type-badge {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .reval-type-badge.rejected {
            background: rgba(229, 115, 115, 0.2);
            color: #e57373;
        }

        .reval-type-badge.corrected {
            background: rgba(255, 183, 77, 0.2);
            color: #ffb74d;
        }

        .reval-list-status {
            text-align: center;
        }

        .reval-status-badge {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 500;
            white-space: nowrap;
        }

        .reval-status-badge.pending {
            background: rgba(100, 200, 255, 0.2);
            color: #64c8ff;
        }

        .reval-status-badge.validated {
            background: rgba(129, 199, 132, 0.2);
            color: #81c784;
        }

        .reval-status-badge.re-corrected {
            background: rgba(255, 152, 0, 0.2);
            color: #ff9800;
        }

        .btn-sm {
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
        }

        /* Detail Modal Active State */
        .reval-detail-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .reval-detail-badge {
            display: inline-block;
            padding: 0.25rem 0.6rem;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 500;
            margin-left: 0.75rem;
        }

        .reval-detail-badge.rejected {
            background: rgba(229, 115, 115, 0.2);
            color: #e57373;
        }

        .reval-detail-badge.corrected {
            background: rgba(255, 183, 77, 0.2);
            color: #ffb74d;
        }

        .reval-detail-content {
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
        }

        .reval-detail-info {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 1rem;
        }

        .reval-detail-info-row {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
        }

        .reval-detail-info-item {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .reval-detail-info-item label {
            font-size: 0.75rem;
            color: #888;
            text-transform: uppercase;
        }

        .reval-detail-info-item span {
            font-size: 0.95rem;
            color: #fff;
        }

        .reval-detail-chart {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 1rem;
        }

        .reval-detail-history {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 1rem;
        }

        .reval-detail-history h4 {
            margin: 0 0 0.75rem 0;
            font-size: 0.9rem;
            color: #64c8ff;
        }

        .reval-history-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 4px;
            margin-bottom: 0.5rem;
        }

        .reval-history-entry:last-child {
            margin-bottom: 0;
        }

        .reval-history-date {
            font-size: 0.8rem;
            color: #888;
            min-width: 150px;
        }

        .reval-history-action {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
        }

        .reval-history-badge {
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .reval-history-badge.initial {
            background: rgba(100, 200, 255, 0.2);
            color: #64c8ff;
        }

        .reval-history-badge.success {
            background: rgba(129, 199, 132, 0.2);
            color: #81c784;
        }

        .reval-history-badge.failed {
            background: rgba(229, 115, 115, 0.2);
            color: #e57373;
        }

        .reval-history-text {
            font-size: 0.85rem;
            color: #aaa;
        }

        .reval-detail-current {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 1rem;
        }

        .reval-detail-current h4 {
            margin: 0 0 0.75rem 0;
            font-size: 0.9rem;
            color: #64c8ff;
        }

        .detection-results {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .detection-result {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .detection-result.detection-success {
            background: rgba(129, 199, 132, 0.15);
            color: #81c784;
        }

        .detection-result.detection-wrong {
            background: rgba(229, 115, 115, 0.15);
            color: #e57373;
        }

        .detection-result.detection-other {
            background: rgba(255, 255, 255, 0.05);
            color: #aaa;
        }

        .detection-result.detection-none {
            background: rgba(255, 255, 255, 0.05);
            color: #888;
        }

        .detection-icon {
            font-size: 1.1rem;
        }

        .reval-detail-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
            padding-top: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        @media (max-width: 768px) {
            .reval-list-item {
                grid-template-columns: 1fr 1fr;
                gap: 0.5rem;
            }

            .reval-list-header {
                display: none;
            }

            .reval-detail-info-row {
                grid-template-columns: 1fr 1fr;
            }

            .reval-detail-actions {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <a href="/index.html" class="back-link">‚Üê Dashboard</a>
            <h1 class="header-title">Candlestick Pattern Konfiguration</h1>
            <span class="service-badge" id="serviceStatus">Laden...</span>
        </div>
    </header>

    <main class="container">
        <!-- Tabs -->
        <div class="tabs">
            <button class="tab active" onclick="switchTab('status')">Status</button>
            <button class="tab" onclick="switchTab('detection')">Detection & History</button>
            <button class="tab" onclick="switchTab('training')">Training</button>
            <button class="tab" onclick="switchTab('revalidation')">Re-Validierung <span id="revalidationBadge" class="tab-badge" style="display: none;">0</span></button>
            <button class="tab" onclick="switchTab('ruleoptimizer')">‚öôÔ∏è Regelwerk</button>
            <button class="tab" onclick="switchTab('claudeqa')">ü§ñ Claude QA</button>
        </div>

        <!-- Tab: Status (Dashboard) -->
        <div id="tab-status" class="tab-content active">

            <!-- KPI Overview Card -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üìä Candlestick Pattern Service</h2>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <span class="service-badge" id="statusServiceBadge">Laden...</span>
                        <button class="btn btn-secondary" onclick="loadStatusDashboard()" style="font-size: 0.75rem; padding: 0.3rem 0.6rem;">Aktualisieren</button>
                    </div>
                </div>

                <!-- Three Column KPI Layout -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1.5rem;">

                    <!-- Detection KPIs -->
                    <div style="background: rgba(100, 200, 255, 0.05); border: 1px solid rgba(100, 200, 255, 0.15); border-radius: 8px; padding: 1rem;">
                        <div style="font-size: 0.9rem; font-weight: 600; color: #64c8ff; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
                            <span>üîç Detection</span>
                            <span class="scan-status" id="statusScanStatus" style="font-size: 0.7rem; padding: 0.2rem 0.5rem;">
                                <span class="status-dot"></span>
                                <span id="statusScanText">-</span>
                            </span>
                        </div>
                        <div class="stats-grid" style="grid-template-columns: repeat(2, 1fr); gap: 0.5rem;">
                            <div class="stat-card" style="padding: 0.5rem;">
                                <div class="stat-value" id="statusPatternTypes" style="font-size: 1.5rem;">-</div>
                                <div class="stat-label" style="font-size: 0.7rem;">Pattern-Typen</div>
                            </div>
                            <div class="stat-card" style="padding: 0.5rem;">
                                <div class="stat-value" id="statusHistoryCount" style="font-size: 1.5rem;">-</div>
                                <div class="stat-label" style="font-size: 0.7rem;">In History</div>
                            </div>
                            <div class="stat-card" style="padding: 0.5rem; border-color: rgba(76, 175, 80, 0.3);">
                                <div class="stat-value success" id="statusBullish" style="font-size: 1.5rem;">-</div>
                                <div class="stat-label" style="font-size: 0.7rem;">Bullish</div>
                            </div>
                            <div class="stat-card" style="padding: 0.5rem; border-color: rgba(244, 67, 54, 0.3);">
                                <div class="stat-value error" id="statusBearish" style="font-size: 1.5rem;">-</div>
                                <div class="stat-label" style="font-size: 0.7rem;">Bearish</div>
                            </div>
                        </div>
                    </div>

                    <!-- Training KPIs -->
                    <div style="background: rgba(156, 39, 176, 0.05); border: 1px solid rgba(156, 39, 176, 0.15); border-radius: 8px; padding: 1rem;">
                        <div style="font-size: 0.9rem; font-weight: 600; color: #ce93d8; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
                            <span>üîß Training</span>
                            <span class="service-badge" id="statusTrainBadge" style="font-size: 0.65rem; padding: 0.15rem 0.4rem;">-</span>
                        </div>
                        <div class="stats-grid" style="grid-template-columns: repeat(2, 1fr); gap: 0.5rem;">
                            <div class="stat-card" style="padding: 0.5rem;">
                                <div class="stat-value" id="statusTrainJobs" style="font-size: 1.5rem;">-</div>
                                <div class="stat-label" style="font-size: 0.7rem;">Jobs Total</div>
                            </div>
                            <div class="stat-card" style="padding: 0.5rem;">
                                <div class="stat-value" id="statusFeedbackTotal" style="font-size: 1.5rem;">-</div>
                                <div class="stat-label" style="font-size: 0.7rem;">Feedback</div>
                            </div>
                            <div class="stat-card" style="padding: 0.5rem; border-color: rgba(76, 175, 80, 0.3);">
                                <div class="stat-value" id="statusFeedbackConfirmed" style="font-size: 1.5rem; color: #81c784;">-</div>
                                <div class="stat-label" style="font-size: 0.7rem;">‚úì Best√§tigt</div>
                            </div>
                            <div class="stat-card" style="padding: 0.5rem; border-color: rgba(255, 152, 0, 0.3);">
                                <div class="stat-value" id="statusFeedbackCorrected" style="font-size: 1.5rem; color: #ffb74d;">-</div>
                                <div class="stat-label" style="font-size: 0.7rem;">‚úé Korrigiert</div>
                            </div>
                        </div>
                    </div>

                    <!-- Re-Validation KPIs -->
                    <div style="background: rgba(255, 193, 7, 0.05); border: 1px solid rgba(255, 193, 7, 0.15); border-radius: 8px; padding: 1rem;">
                        <div style="font-size: 0.9rem; font-weight: 600; color: #ffd54f; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
                            <span>üîÑ Re-Validierung</span>
                        </div>
                        <div class="stats-grid" style="grid-template-columns: repeat(2, 1fr); gap: 0.5rem;">
                            <div class="stat-card" style="padding: 0.5rem;">
                                <div class="stat-value" id="statusPendingReval" style="font-size: 1.5rem;">-</div>
                                <div class="stat-label" style="font-size: 0.7rem;">Ausstehend</div>
                            </div>
                            <div class="stat-card" style="padding: 0.5rem;">
                                <div class="stat-value" id="statusRevalidated" style="font-size: 1.5rem;">-</div>
                                <div class="stat-label" style="font-size: 0.7rem;">Validiert</div>
                            </div>
                            <div class="stat-card" style="padding: 0.5rem; grid-column: span 2; border-color: rgba(76, 175, 80, 0.3);">
                                <div class="stat-value success" id="statusImprovementRate" style="font-size: 1.5rem;">-</div>
                                <div class="stat-label" style="font-size: 0.7rem;">Verbesserungsrate</div>
                            </div>
                        </div>
                    </div>

                </div>

                <!-- Service Info Footer -->
                <div style="margin-top: 1rem; padding-top: 0.75rem; border-top: 1px solid rgba(255,255,255,0.1); display: flex; flex-wrap: wrap; gap: 1rem; font-size: 0.8rem; color: #888;">
                    <span>Inference: <span style="color: #64c8ff;">Port 3006</span></span>
                    <span>Training: <span style="color: #64c8ff;">Port 3016</span></span>
                    <span>Version: <span style="color: #64c8ff;" id="statusVersion">-</span></span>
                    <span>Gestartet: <span style="color: #64c8ff;" id="statusStarted">-</span></span>
                </div>
            </div>

            <!-- Pattern Categories -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Verf√ºgbare Pattern-Typen</h2>
                </div>

                <!-- Reversal Patterns -->
                <div class="category-section" id="reversalSection">
                    <div class="category-title">
                        <span class="badge badge-reversal">Reversal</span>
                        Umkehrmuster
                        <span class="category-count" id="reversalCount">0</span>
                    </div>
                    <div class="pattern-grid" id="reversalPatterns">
                        <div class="loading"><span class="spinner"></span></div>
                    </div>
                </div>

                <!-- Continuation Patterns -->
                <div class="category-section" id="continuationSection">
                    <div class="category-title">
                        <span class="badge badge-continuation">Continuation</span>
                        Fortsetzungsmuster
                        <span class="category-count" id="continuationCount">0</span>
                    </div>
                    <div class="pattern-grid" id="continuationPatterns">
                        <div class="loading"><span class="spinner"></span></div>
                    </div>
                </div>

                <!-- Indecision Patterns -->
                <div class="category-section" id="indecisionSection">
                    <div class="category-title">
                        <span class="badge badge-indecision">Indecision</span>
                        Unentschlossenheit
                        <span class="category-count" id="indecisionCount">0</span>
                    </div>
                    <div class="pattern-grid" id="indecisionPatterns">
                        <div class="loading"><span class="spinner"></span></div>
                    </div>
                </div>
            </div>

        </div><!-- End Tab: Status -->

        <!-- Tab: Training -->
        <div id="tab-training" class="tab-content">

            <!-- Combined Training Status Card -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üîß Training Service</h2>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <span class="service-badge" id="trainServiceStatus">Laden...</span>
                        <button class="btn btn-secondary" onclick="loadTrainingServiceInfo(); loadFeedbackStats(); loadTrainingStatus();" style="font-size: 0.75rem; padding: 0.3rem 0.6rem;">Aktualisieren</button>
                    </div>
                </div>

                <!-- Service Info Row -->
                <div style="display: flex; flex-wrap: wrap; gap: 1rem; align-items: center; margin-bottom: 1rem; padding-bottom: 0.75rem; border-bottom: 1px solid rgba(255,255,255,0.1);">
                    <div style="display: flex; gap: 1rem; flex-wrap: wrap; font-size: 0.85rem; color: #888;">
                        <span>Version: <span style="color: #64c8ff;" id="trainVersion">-</span></span>
                        <span>PyTorch: <span style="color: #64c8ff;" id="trainPyTorch">-</span></span>
                        <span>Port: <span style="color: #64c8ff;">3016</span></span>
                        <span>Gestartet: <span style="color: #64c8ff;" id="trainStarted">-</span></span>
                    </div>
                    <div class="timeframe-list" id="trainTimeframes" style="flex: 1; min-width: 200px;">
                        <span class="loading" style="padding: 0;"><span class="spinner" style="width: 16px; height: 16px;"></span></span>
                    </div>
                </div>

                <!-- Stats Grid: Training + Feedback combined -->
                <div class="stats-grid" style="margin-bottom: 1rem;">
                    <div class="stat-card">
                        <div class="stat-value" id="trainPatternTypes">-</div>
                        <div class="stat-label">Pattern-Typen</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="trainJobsTotal">-</div>
                        <div class="stat-label">Jobs Total</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="feedbackTotal">-</div>
                        <div class="stat-label">Feedback</div>
                    </div>
                    <div class="stat-card" style="border-color: rgba(76, 175, 80, 0.3);">
                        <div class="stat-value" id="feedbackConfirmed" style="color: #81c784;">-</div>
                        <div class="stat-label">‚úì Best√§tigt</div>
                    </div>
                    <div class="stat-card" style="border-color: rgba(255, 152, 0, 0.3);">
                        <div class="stat-value" id="feedbackCorrected" style="color: #ffb74d;">-</div>
                        <div class="stat-label">‚úé Korrigiert</div>
                    </div>
                    <div class="stat-card" style="border-color: rgba(244, 67, 54, 0.3);">
                        <div class="stat-value" id="feedbackRejected" style="color: #e57373;">-</div>
                        <div class="stat-label">‚úó Abgelehnt</div>
                    </div>
                </div>

                <!-- Info Footer -->
                <div style="font-size: 0.8rem; color: #888;">
                    <span id="feedbackInfo">Das gesammelte Feedback wird beim n√§chsten Training automatisch ber√ºcksichtigt.</span>
                </div>
            </div>

            <!-- Start New Training Card -->
            <div class="card" style="border: 1px solid rgba(100, 200, 255, 0.3);">
                <div class="card-header">
                    <h2 class="card-title">üöÄ Neues Training starten</h2>
                </div>
                <p class="card-description" style="margin-bottom: 1rem;">
                    Trainiere das Modell mit den gesammelten Korrekturen, um die Pattern-Erkennung zu verbessern.
                </p>

                <!-- Current Training Progress (shown only when training is active) -->
                <div id="currentTrainingSection" style="display: none; margin-bottom: 1rem; padding: 1rem; background: rgba(100, 200, 255, 0.1); border-radius: 8px; border: 1px solid rgba(100, 200, 255, 0.3);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <span style="font-weight: 600; color: #64c8ff;">‚è≥ Aktuelles Training</span>
                            <span class="job-status running" id="currentJobStatus">Running</span>
                        </div>
                        <button class="btn btn-danger" onclick="cancelCurrentTraining()" style="font-size: 0.75rem; padding: 0.3rem 0.6rem;">Abbrechen</button>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem; font-size: 0.85rem; color: #888;">
                        <span id="currentJobId">-</span>
                        <span id="currentJobProgress">0%</span>
                    </div>
                    <div style="background: rgba(0,0,0,0.3); border-radius: 4px; height: 8px; overflow: hidden;">
                        <div id="currentProgressBar" style="background: linear-gradient(90deg, #64c8ff, #81c784); height: 100%; width: 0%; transition: width 0.3s;"></div>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 0.5rem; font-size: 0.8rem; color: #888;">
                        <span>Epoch: <span id="currentEpoch">0</span> / <span id="totalEpochs">0</span></span>
                        <span>Loss: <span id="currentLoss">-</span></span>
                        <span>Best: <span id="bestLoss">-</span></span>
                    </div>
                </div>

                <div style="display: flex; justify-content: space-between; align-items: flex-start; flex-wrap: wrap; gap: 1rem;">
                    <div style="flex: 1; min-width: 300px;">
                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 0.75rem;">
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <label style="font-size: 0.8rem; color: #888;">Epochen:</label>
                                <input type="number" id="trainEpochs" value="50" min="1" max="500" style="width: 70px; padding: 0.3rem; background: #1a1a2e; color: #fff; border: 1px solid rgba(255,255,255,0.2); border-radius: 4px;">
                            </div>
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <label style="font-size: 0.8rem; color: #888;">Batch:</label>
                                <input type="number" id="trainBatchSize" value="32" min="8" max="128" style="width: 60px; padding: 0.3rem; background: #1a1a2e; color: #fff; border: 1px solid rgba(255,255,255,0.2); border-radius: 4px;">
                            </div>
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <label style="font-size: 0.8rem; color: #888;">LR:</label>
                                <input type="number" id="trainLearningRate" value="0.001" min="0.0001" max="0.1" step="0.0001" style="width: 80px; padding: 0.3rem; background: #1a1a2e; color: #fff; border: 1px solid rgba(255,255,255,0.2); border-radius: 4px;">
                            </div>
                        </div>
                        <span style="font-size: 0.75rem; color: #666;">Symbole: BTCUSD, EURUSD, GBPUSD, XAUUSD, GER40, XTIUSD</span>
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 0.5rem; align-items: flex-end;">
                        <button class="btn btn-success" id="btnStartRevalTraining" onclick="startRevalTraining()" style="padding: 0.6rem 1.5rem;">
                            ‚ñ∂ Training starten
                        </button>
                    </div>
                </div>
            </div>

            <!-- Training History -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üìö Training History</h2>
                    <span class="badge badge-neutral" id="jobHistoryCount">0 Jobs</span>
                </div>
                <div class="job-list" id="jobList">
                    <div class="loading"><span class="spinner"></span></div>
                </div>
            </div>

        </div><!-- End Tab: Training -->

        <!-- Tab: Detection & History -->
        <div id="tab-detection" class="tab-content">

            <!-- Combined Stats & Service Info -->
            <div class="card" style="margin-bottom: 1.5rem;">
                <div class="stats-grid" style="margin-bottom: 1rem;">
                    <div class="stat-card">
                        <div class="stat-value" id="patternCount">-</div>
                        <div class="stat-label">Pattern-Typen</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="timeframeCount">-</div>
                        <div class="stat-label">Timeframes</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="historyCount">-</div>
                        <div class="stat-label">History</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value success" id="bullishCount">-</div>
                        <div class="stat-label">Bullish</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value error" id="bearishCount">-</div>
                        <div class="stat-label">Bearish</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value warning" id="neutralCount">-</div>
                        <div class="stat-label">Neutral</div>
                    </div>
                </div>
                <div style="display: flex; flex-wrap: wrap; gap: 1.5rem; align-items: center; padding-top: 0.75rem; border-top: 1px solid rgba(255,255,255,0.1);">
                    <div style="display: flex; gap: 1rem; flex-wrap: wrap; font-size: 0.85rem; color: #888;">
                        <span>Version: <span style="color: #64c8ff;" id="infoVersion">-</span></span>
                        <span>Port: <span style="color: #64c8ff;">3006</span></span>
                        <span>Gestartet: <span style="color: #64c8ff;" id="infoStarted">-</span></span>
                    </div>
                    <div class="timeframe-list" id="timeframeList" style="flex: 1; min-width: 200px;">
                        <span class="loading" style="padding: 0;"><span class="spinner" style="width: 16px; height: 16px;"></span></span>
                    </div>
                </div>
            </div>

            <!-- Scan Controls -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Auto-Scan Steuerung</h2>
                    <div class="scan-status running" id="scanStatus">
                        <span class="status-dot running"></span>
                        <span id="scanStatusText">L√§uft</span>
                    </div>
                </div>
                <p class="card-description">
                    Der Auto-Scan √ºberwacht alle Favoriten-Symbole und erkennt Candlestick-Patterns automatisch.
                </p>
                <div class="btn-group">
                    <button class="btn btn-success" id="btnStartScan" onclick="startAutoScan()" style="display: none;">
                        Auto-Scan starten
                    </button>
                    <button class="btn btn-danger" id="btnStopScan" onclick="stopAutoScan()">
                        Auto-Scan stoppen
                    </button>
                    <button class="btn btn-primary" onclick="triggerManualScan()">
                        Jetzt scannen
                    </button>
                    <button class="btn btn-warning" onclick="clearHistory()" title="L√∂scht alle erkannten Patterns aus der History-Liste. Feedback und Korrekturen bleiben erhalten.">
                        History l√∂schen
                    </button>
                </div>
            </div>

            <!-- Pattern History -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Erkannte Patterns</h2>
                    <div class="btn-group">
                        <button class="btn btn-secondary" onclick="resetHistoryFilters()" title="Filter zur√ºcksetzen">‚úï Filter</button>
                        <button class="btn btn-primary" onclick="loadPatternHistory()">Aktualisieren</button>
                    </div>
                </div>

                <div class="history-filters">
                    <div class="form-group" style="margin: 0;">
                        <label style="font-size: 0.75rem;">Pattern</label>
                        <select id="historyFilterPattern" onchange="loadPatternHistory()">
                            <option value="">Alle Patterns</option>
                        </select>
                    </div>
                    <div class="form-group" style="margin: 0;">
                        <label style="font-size: 0.75rem;">Symbol</label>
                        <select id="historyFilterSymbol" onchange="loadPatternHistory()">
                            <option value="">Alle Symbole</option>
                        </select>
                    </div>
                    <div class="form-group" style="margin: 0;">
                        <label style="font-size: 0.75rem;">Richtung</label>
                        <select id="historyFilterDirection" onchange="loadPatternHistory()">
                            <option value="">Alle</option>
                            <option value="bullish">Bullish</option>
                            <option value="bearish">Bearish</option>
                            <option value="neutral">Neutral</option>
                        </select>
                    </div>
                    <div class="form-group" style="margin: 0;">
                        <label style="font-size: 0.75rem;">Timeframe</label>
                        <select id="historyFilterTimeframe" onchange="loadPatternHistory()">
                            <option value="">Alle</option>
                            <option value="M5">M5</option>
                            <option value="M15">M15</option>
                            <option value="H1">H1</option>
                            <option value="H4">H4</option>
                            <option value="D1">D1</option>
                        </select>
                    </div>
                    <div class="form-group" style="margin: 0;">
                        <label style="font-size: 0.75rem;">Konfidenz</label>
                        <select id="historyFilterConfidence" onchange="loadPatternHistory()">
                            <option value="0">Alle</option>
                            <option value="0.5">‚â•50%</option>
                            <option value="0.6">‚â•60%</option>
                            <option value="0.7">‚â•70%</option>
                            <option value="0.8">‚â•80%</option>
                        </select>
                    </div>
                    <div class="form-group" style="margin: 0;">
                        <label style="font-size: 0.75rem;">Status</label>
                        <select id="historyFilterStatus" onchange="loadPatternHistory()">
                            <option value="">Alle</option>
                            <option value="pending">Ausstehend</option>
                            <option value="confirmed">Best√§tigt</option>
                            <option value="corrected">Korrigiert</option>
                            <option value="rejected">Abgelehnt</option>
                        </select>
                    </div>
                    <div class="form-group" style="margin: 0;">
                        <label style="font-size: 0.75rem;">Von</label>
                        <input type="date" id="historyFilterDateFrom" onchange="loadPatternHistory()" style="padding: 0.4rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; color: #e8e8e8;">
                    </div>
                    <div class="form-group" style="margin: 0;">
                        <label style="font-size: 0.75rem;">Bis</label>
                        <input type="date" id="historyFilterDateTo" onchange="loadPatternHistory()" style="padding: 0.4rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; color: #e8e8e8;">
                    </div>
                </div>

                <!-- Timeline Container -->
                <div class="timeline-container" id="patternTimelineContainer">
                    <div class="timeline" id="patternTimeline">
                        <div class="loading"><span class="spinner"></span> Lade Patterns...</div>
                    </div>
                </div>

                <!-- Pagination -->
                <div class="pagination" id="historyPagination" style="display: none;">
                    <button onclick="loadPatternHistory(currentHistoryPage - 1)" id="historyPrevBtn">Zur√ºck</button>
                    <span class="pagination-info" id="historyPageInfo">Seite 1 von 1</span>
                    <button onclick="loadPatternHistory(currentHistoryPage + 1)" id="historyNextBtn">Weiter</button>
                </div>
            </div>

        </div><!-- End Tab: Detection & History -->

        <!-- Optimization Summary Modal -->
        <div class="modal-overlay" id="optimizationSummaryModal" onclick="closeOptimizationSummary(event)">
            <div class="modal" onclick="event.stopPropagation()" style="max-width: 95vw; width: 1200px; max-height: 90vh;">
                <div class="modal-header">
                    <div class="modal-title">
                        <span>üìä Optimierung abgeschlossen</span>
                    </div>
                    <button class="modal-close" onclick="closeOptimizationSummary()">&times;</button>
                </div>
                <div class="modal-body" style="padding: 1.5rem; overflow-y: auto; max-height: calc(90vh - 60px);">
                    <!-- Summary Stats -->
                    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 1rem; margin-bottom: 1.5rem;">
                        <div style="background: rgba(100, 200, 255, 0.1); padding: 1rem; border-radius: 8px; text-align: center;">
                            <div style="font-size: 1.8rem; font-weight: bold; color: #64c8ff;" id="summaryCollected">0</div>
                            <div style="font-size: 0.8rem; color: #888;">Patterns gesammelt</div>
                        </div>
                        <div style="background: rgba(76, 175, 80, 0.1); padding: 1rem; border-radius: 8px; text-align: center;">
                            <div style="font-size: 1.8rem; font-weight: bold; color: #4caf50;" id="summaryValidCount">0</div>
                            <div style="font-size: 0.8rem; color: #888;">Valide</div>
                        </div>
                        <div style="background: rgba(244, 67, 54, 0.1); padding: 1rem; border-radius: 8px; text-align: center;">
                            <div style="font-size: 1.8rem; font-weight: bold; color: #f44336;" id="summaryInvalidCount">0</div>
                            <div style="font-size: 0.8rem; color: #888;">Invalide</div>
                        </div>
                        <div style="background: rgba(255, 152, 0, 0.1); padding: 1rem; border-radius: 8px; text-align: center;">
                            <div style="font-size: 1.8rem; font-weight: bold; color: #ff9800;" id="summaryRecommendations">0</div>
                            <div style="font-size: 0.8rem; color: #888;">Empfehlungen</div>
                        </div>
                        <div style="background: rgba(206, 147, 216, 0.1); padding: 1rem; border-radius: 8px; text-align: center;">
                            <div style="font-size: 1.8rem; font-weight: bold; color: #ce93d8;" id="summaryPatternTypes">0</div>
                            <div style="font-size: 0.8rem; color: #888;">Pattern-Typen</div>
                        </div>
                    </div>

                    <!-- Pattern Analysis Summary -->
                    <div style="margin-bottom: 1.5rem;">
                        <h4 style="margin: 0 0 0.8rem 0; color: #64c8ff; font-size: 1rem;">Pattern-Analyse nach Typ</h4>
                        <div id="summaryPatternAnalysis" style="max-height: 150px; overflow-y: auto; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 0.8rem;">
                            <!-- Filled dynamically -->
                        </div>
                    </div>

                    <!-- Detailed Sample List with Images -->
                    <div style="margin-bottom: 1.5rem;">
                        <h4 style="margin: 0 0 0.8rem 0; color: #ce93d8; font-size: 1rem;">
                            Validierte Patterns im Detail
                            <span style="font-weight: normal; color: #888; font-size: 0.85rem;"> - Claude Vision Analyse</span>
                        </h4>
                        <div id="summarySamplesList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(350px, 1fr)); gap: 1rem; max-height: 400px; overflow-y: auto; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 1rem;">
                            <!-- Filled dynamically with pattern cards -->
                        </div>
                    </div>

                    <!-- Recommendations Preview -->
                    <div id="summaryRecommendationsSection" style="display: none;">
                        <h4 style="margin: 0 0 0.8rem 0; color: #ff9800; font-size: 1rem;">Empfehlungen</h4>
                        <div id="summaryRecommendationsList" style="max-height: 150px; overflow-y: auto; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 0.8rem;">
                            <!-- Filled dynamically -->
                        </div>
                    </div>

                    <!-- Action Buttons -->
                    <div style="display: flex; gap: 1rem; margin-top: 1.5rem; justify-content: flex-end;">
                        <button class="btn btn-secondary" onclick="closeOptimizationSummary()">Schliessen</button>
                        <button class="btn btn-primary" id="summaryApplyBtn" onclick="applyAllRecommendationsFromSummary()" style="display: none;">
                            ‚úì Alle Empfehlungen anwenden
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Validation Queue Modal -->
        <div class="modal-overlay" id="queueModal" onclick="closeQueueModal(event)">
            <div class="modal" onclick="event.stopPropagation()" style="max-width: 900px; width: 90vw; max-height: 85vh;">
                <div class="modal-header">
                    <div class="modal-title">
                        <span>üìã Validierungs-Warteschlange</span>
                        <span id="queueTotalCount" style="font-size: 0.85rem; color: #888; margin-left: 0.5rem;">(0 Eintr√§ge)</span>
                    </div>
                    <button class="modal-close" onclick="closeQueueModal()">&times;</button>
                </div>
                <div class="modal-body" style="padding: 1rem; overflow-y: auto; max-height: calc(85vh - 120px);">
                    <p style="font-size: 0.85rem; color: #aaa; margin-bottom: 1rem;">
                        Diese Patterns warten auf Validierung durch Claude Vision. Patterns werden beim n√§chsten Batch-Lauf oder automatisch (wenn aktiviert) validiert.
                    </p>
                    <div id="queueContent" style="min-height: 100px;">
                        <div style="text-align: center; color: #888;">Lade...</div>
                    </div>
                </div>
                <div style="padding: 0.75rem 1rem; border-top: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center;">
                    <button class="btn btn-danger btn-sm" onclick="clearValidationQueueFromModal()" title="Alle Eintr√§ge aus der Warteschlange entfernen">
                        Queue leeren ‚ùå
                    </button>
                    <button class="btn btn-secondary" onclick="closeQueueModal()">Schliessen</button>
                </div>
            </div>
        </div>

        <!-- Pattern Detail Modal -->
        <div class="modal-overlay" id="patternModal" onclick="closePatternModal(event)">
            <div class="modal" onclick="event.stopPropagation()" style="max-width: 800px;">
                <div class="modal-header">
                    <div class="modal-title">
                        <span id="modalPatternName">-</span>
                        <span class="timeline-direction" id="modalDirection">-</span>
                    </div>
                    <button class="modal-close" onclick="closePatternModal()">&times;</button>
                </div>
                <div class="modal-body">
                    <!-- Chart Comparison -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                        <div>
                            <div style="font-size: 0.8rem; color: #888; margin-bottom: 0.5rem; text-align: center;">Erkanntes Pattern</div>
                            <div class="modal-chart-container" style="margin-bottom: 0;">
                                <canvas class="modal-chart" id="modalChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <div style="font-size: 0.8rem; color: #888; margin-bottom: 0.5rem; text-align: center;">Referenz-Beispiel</div>
                            <div class="modal-chart-container" id="modalReferenceContainer" style="margin-bottom: 0; display: flex; align-items: center; justify-content: center; min-height: 150px;">
                                <span class="spinner"></span>
                            </div>
                        </div>
                    </div>

                    <div class="modal-info-grid">
                        <div class="modal-info-item">
                            <div class="modal-info-label">Symbol</div>
                            <div class="modal-info-value" id="modalSymbol">-</div>
                        </div>
                        <div class="modal-info-item">
                            <div class="modal-info-label">Timeframe</div>
                            <div class="modal-info-value" id="modalTimeframe">-</div>
                        </div>
                        <div class="modal-info-item">
                            <div class="modal-info-label">Zeitpunkt</div>
                            <div class="modal-info-value" id="modalTimestamp">-</div>
                        </div>
                        <div class="modal-info-item">
                            <div class="modal-info-label">Konfidenz</div>
                            <div class="modal-info-value" id="modalConfidence">-</div>
                        </div>
                    </div>

                    <div class="modal-description" id="modalDescription">
                        Pattern-Beschreibung wird geladen...
                    </div>

                    <!-- Correction Section -->
                    <div style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.1);">
                        <!-- Claude Vision Result (above buttons) -->
                        <div id="claudeVisionResult" style="display: none; margin-bottom: 1rem; padding: 0.75rem; border-radius: 8px;">
                        </div>

                        <!-- Primary Action Buttons -->
                        <div id="primaryActions" style="display: flex; gap: 0.75rem; align-items: center; flex-wrap: wrap;">
                            <button class="btn btn-success" onclick="confirmPatternAndNext()" style="padding: 0.5rem 1rem;" title="Pattern best√§tigen und zum n√§chsten">
                                ‚úì Korrekt
                            </button>
                            <button class="btn btn-warning" onclick="showCorrectionForm()" style="padding: 0.5rem 1rem;" title="Anderes Pattern erkannt">
                                ‚úó Falsches Pattern
                            </button>
                            <button class="btn btn-secondary" onclick="showNoPatternForm()" style="padding: 0.5rem 1rem;" title="Kein g√ºltiges Pattern erkennbar">
                                ‚úó Kein Pattern
                            </button>
                            <button class="btn" id="btnClaudeVision" onclick="validateWithClaudeVision()"
                                    style="padding: 0.5rem 1rem; background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); border: none; margin-left: auto;"
                                    title="Pattern mit Claude Vision analysieren">
                                ü§ñ Claude Vision
                            </button>
                        </div>

                        <!-- Correction Form (hidden initially) -->
                        <div id="correctionFormSection" style="display: none; margin-top: 1rem; padding: 0.75rem; background: rgba(255,152,0,0.08); border: 1px solid rgba(255,152,0,0.2); border-radius: 8px;">
                            <div style="font-size: 0.9rem; font-weight: 600; color: #ffb74d; margin-bottom: 0.75rem;">
                                <span id="correctionFormTitle">Korrektur eingeben</span>
                            </div>

                            <!-- Pattern Selection (only for "Falsches Pattern") -->
                            <div id="patternSelectionRow" style="display: flex; gap: 0.75rem; align-items: center; flex-wrap: wrap; margin-bottom: 0.75rem;">
                                <label style="color: #aaa; font-size: 0.85rem;">Korrektes Pattern:</label>
                                <select id="correctionPatternSelect" style="padding: 0.5rem; background: #252540; color: #fff; border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; min-width: 200px;">
                                    <option value="">-- Pattern w√§hlen --</option>
                                </select>
                            </div>

                            <!-- Reason Selection -->
                            <div style="display: flex; gap: 0.75rem; align-items: center; flex-wrap: wrap; margin-bottom: 0.75rem;">
                                <label style="color: #aaa; font-size: 0.85rem;">Grund:</label>
                                <select id="reasonCategorySelect" style="padding: 0.5rem; background: #252540; color: #fff; border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; min-width: 220px;" onchange="onReasonCategoryChange()">
                                    <option value="">-- Grund w√§hlen (optional) --</option>
                                </select>
                            </div>
                            <div id="reasonDescription" style="margin-bottom: 0.75rem; font-size: 0.8rem; color: #888; font-style: italic;"></div>

                            <!-- Additional Details -->
                            <input type="text" id="reasonTextInput" placeholder="Zus√§tzliche Details (optional)"
                                   style="width: 100%; padding: 0.5rem; background: #252540; color: #fff; border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; margin-bottom: 0.75rem;">

                            <!-- Action Buttons -->
                            <div style="display: flex; gap: 0.75rem;">
                                <button class="btn btn-primary" onclick="submitCorrectionAndNext()" style="padding: 0.5rem 1.5rem;">
                                    üíæ Speichern & Weiter
                                </button>
                                <button class="btn btn-secondary" onclick="hideCorrectionForm()" style="padding: 0.5rem 1rem;">
                                    Abbrechen
                                </button>
                            </div>
                        </div>

                        <div id="correctionFeedback" style="margin-top: 0.5rem; font-size: 0.85rem; display: none;"></div>
                    </div>
                    <!-- Hidden legacy elements for compatibility -->
                    <div id="reasonSection" style="display: none;"></div>
                </div>
                <!-- Navigation Footer -->
                <div class="modal-footer">
                    <button class="modal-nav-btn modal-nav-prev" id="modalPrevBtn" onclick="navigatePattern(-1)" title="Vorheriges Pattern (‚Üê)">
                        ‚Äπ Zur√ºck
                    </button>
                    <span class="modal-nav-counter" id="modalNavCounter">1 / 100</span>
                    <button class="modal-nav-btn modal-nav-next" id="modalNextBtn" onclick="navigatePattern(1)" title="N√§chstes Pattern (‚Üí)">
                        Weiter ‚Ä∫
                    </button>
                </div>
            </div>
        </div>

        <!-- Tab: Re-Validierung -->
        <div id="tab-revalidation" class="tab-content">

            <!-- Revalidation Statistics -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üîÑ Re-Validierung nach Training</h2>
                    <div class="btn-group">
                        <button class="btn btn-warning" onclick="resetRevalidation()" title="Nach neuem Training zur√ºcksetzen">Zur√ºcksetzen</button>
                        <button class="btn btn-primary" onclick="loadRevalidationData()">Aktualisieren</button>
                    </div>
                </div>
                <p class="card-description">
                    √úberpr√ºfe zuvor korrigierte oder abgelehnte Patterns nach dem Neu-Training des Modells,
                    um zu verifizieren, dass die Verbesserungen wirksam sind.
                </p>
                <div class="stats-grid" style="margin-top: 1rem;">
                    <div class="stat-card">
                        <div class="stat-value" id="revalTotal">-</div>
                        <div class="stat-label">Korrekturen gesamt</div>
                    </div>
                    <div class="stat-card" style="border-color: rgba(255, 152, 0, 0.3);">
                        <div class="stat-value" id="revalPending" style="color: #ffb74d;">-</div>
                        <div class="stat-label">‚è≥ Ausstehend</div>
                    </div>
                    <div class="stat-card" style="border-color: rgba(76, 175, 80, 0.3);">
                        <div class="stat-value" id="revalDone" style="color: #81c784;">-</div>
                        <div class="stat-label">‚úì √úberpr√ºft</div>
                    </div>
                    <div class="stat-card" style="border-color: rgba(100, 200, 255, 0.3);">
                        <div class="stat-value" id="revalImprovement" style="color: #64c8ff;">-</div>
                        <div class="stat-label">üìà Verbesserungsrate</div>
                    </div>
                </div>

                <!-- Training Info Section -->
                <div style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
                    <!-- Last Training Info -->
                    <div style="display: flex; gap: 1rem; flex-wrap: wrap; margin-bottom: 1rem; align-items: center;">
                        <span style="background: rgba(255,255,255,0.1); padding: 0.4rem 0.8rem; border-radius: 4px; font-size: 0.85rem;">
                            Letztes Training: <span id="revalLastTraining" style="color: #64c8ff;">-</span>
                        </span>
                        <span style="background: rgba(255,255,255,0.1); padding: 0.4rem 0.8rem; border-radius: 4px; font-size: 0.85rem;">
                            Letzte Re-Validierung: <span id="revalLastRevalidation" style="color: #81c784;">-</span>
                        </span>
                    </div>
                </div>
            </div>

            <!-- Pending Revalidation List -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Ausstehende √úberpr√ºfungen</h2>
                    <span class="badge badge-neutral" id="pendingCount">0</span>
                </div>

                <!-- Filter Section -->
                <div class="reval-filters">
                    <div class="reval-filter-group">
                        <label>Symbol</label>
                        <select id="revalFilterSymbol" onchange="filterRevalidationList()">
                            <option value="">Alle Symbole</option>
                        </select>
                    </div>
                    <div class="reval-filter-group">
                        <label>Pattern</label>
                        <select id="revalFilterPattern" onchange="filterRevalidationList()">
                            <option value="">Alle Patterns</option>
                        </select>
                    </div>
                    <div class="reval-filter-group">
                        <label>Timeframe</label>
                        <select id="revalFilterTimeframe" onchange="filterRevalidationList()">
                            <option value="">Alle</option>
                            <option value="M5">M5</option>
                            <option value="M15">M15</option>
                            <option value="H1">H1</option>
                            <option value="H4">H4</option>
                            <option value="D1">D1</option>
                        </select>
                    </div>
                    <div class="reval-filter-group">
                        <label>Typ</label>
                        <select id="revalFilterType" onchange="filterRevalidationList()">
                            <option value="">Alle</option>
                            <option value="rejected">Abgelehnt</option>
                            <option value="corrected">Korrigiert</option>
                        </select>
                    </div>
                    <div class="reval-filter-group">
                        <label>Status</label>
                        <select id="revalFilterStatus" onchange="filterRevalidationList()">
                            <option value="">Alle</option>
                            <option value="pending">‚è≥ Ausstehend</option>
                            <option value="validated">‚úì √úberpr√ºft</option>
                            <option value="re_corrected">üîÑ Korrigiert</option>
                        </select>
                    </div>
                    <div class="reval-filter-group" style="align-self: flex-end;">
                        <button class="btn btn-secondary" onclick="resetRevalidationFilters()" style="padding: 0.4rem 0.8rem;">
                            Filter zur√ºcksetzen
                        </button>
                    </div>
                </div>

                <!-- List Header -->
                <div class="reval-list-header">
                    <div>Symbol</div>
                    <div>Pattern-Korrektur</div>
                    <div>Timeframe</div>
                    <div>Datum</div>
                    <div>Typ</div>
                    <div>Status</div>
                    <div></div>
                </div>

                <!-- List Content -->
                <div id="revalidationList" class="reval-list-container">
                    <div class="loading"><span class="spinner"></span></div>
                </div>

                <div id="noRevalidations" style="display: none; text-align: center; padding: 2rem; color: #888;">
                    <div style="font-size: 2rem; margin-bottom: 0.5rem;">‚úì</div>
                    <div>Alle Korrekturen wurden √ºberpr√ºft!</div>
                    <div style="font-size: 0.85rem; margin-top: 0.5rem;">
                        Nach einem neuen Training kannst du die √úberpr√ºfung mit "Zur√ºcksetzen" erneut starten.
                    </div>
                </div>
            </div>

            <!-- Revalidation Results Summary -->
            <div class="card" id="revalResultsCard" style="display: none;">
                <div class="card-header">
                    <h2 class="card-title">√úberpr√ºfungsergebnisse</h2>
                </div>
                <div class="stats-grid">
                    <div class="stat-card" style="border-color: rgba(76, 175, 80, 0.3);">
                        <div class="stat-value" id="revalCorrect" style="color: #81c784;">0</div>
                        <div class="stat-label">‚úì Jetzt korrekt</div>
                    </div>
                    <div class="stat-card" style="border-color: rgba(76, 175, 80, 0.3);">
                        <div class="stat-value" id="revalNowCorrect" style="color: #81c784;">0</div>
                        <div class="stat-label">‚úì Nicht mehr erkannt</div>
                    </div>
                    <div class="stat-card" style="border-color: rgba(244, 67, 54, 0.3);">
                        <div class="stat-value" id="revalStillWrong" style="color: #e57373;">0</div>
                        <div class="stat-label">‚úó Weiterhin falsch</div>
                    </div>
                </div>
            </div>

        </div><!-- End Tab: Re-Validierung -->

        <!-- Tab: Regelwerk Optimierung -->
        <div id="tab-ruleoptimizer" class="tab-content">
            <!-- Einleitung -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">‚öôÔ∏è Regelwerk-Optimierung mit Claude Vision</h2>
                </div>
                <p style="color: #888; margin-bottom: 1rem;">
                    Diese Funktion analysiert eine gro√üe Anzahl erkannter Patterns mit Claude Vision API,
                    um systematische Probleme in der Regel-basierten Erkennung zu identifizieren und
                    optimale Parameter-Werte zu berechnen.
                </p>
                <div style="background: rgba(255, 152, 0, 0.1); border: 1px solid rgba(255, 152, 0, 0.3); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
                    <strong style="color: #ff9800;">‚ö†Ô∏è Hinweis:</strong>
                    <span style="color: #ccc;"> Diese Optimierung verbraucht Claude API Credits. Pro Pattern-Sample wird ein API-Call gemacht. Bei 10 Samples √ó 19 Pattern-Typen = ~190 API Calls.</span>
                </div>
            </div>

            <!-- Optimierung starten -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üöÄ Optimierung starten</h2>
                </div>

                <div class="form-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1rem;">
                    <div class="form-group">
                        <label>Symbole</label>
                        <input type="text" id="optimizerSymbols" value="BTCUSD,EURUSD,XAUUSD,GER40" placeholder="Komma-getrennt">
                    </div>
                    <div class="form-group">
                        <label>Timeframes</label>
                        <input type="text" id="optimizerTimeframes" value="M5,M15,H1,H4,D1" placeholder="Komma-getrennt">
                    </div>
                    <div class="form-group">
                        <label>Samples pro Pattern</label>
                        <input type="number" id="optimizerSamples" value="10" min="3" max="50">
                    </div>
                </div>

                <button id="btnStartOptimization" class="btn btn-primary" onclick="startRuleOptimization()" style="margin-bottom: 1rem;">
                    ‚ñ∂ Optimierung starten
                </button>

                <!-- Progress Section -->
                <div id="optimizationProgress" style="display: none; margin-top: 1rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                        <span id="optimizationPhase" style="color: #64c8ff;">Phase: Sammle Patterns...</span>
                        <span id="optimizationPercent">0%</span>
                    </div>
                    <div style="background: rgba(255,255,255,0.1); border-radius: 4px; height: 20px; overflow: hidden;">
                        <div id="optimizationBar" style="background: linear-gradient(90deg, #64c8ff, #81c784); height: 100%; width: 0%; transition: width 0.3s;"></div>
                    </div>
                    <p id="optimizationMessage" style="margin-top: 0.5rem; color: #888; font-size: 0.85rem;"></p>
                    <div style="margin-top: 0.5rem; color: #888; font-size: 0.85rem;">
                        <span>Patterns gesammelt: <span id="optimizationCollected">0</span></span>
                        <span style="margin-left: 1rem;">Validiert: <span id="optimizationValidated">0</span></span>
                    </div>
                </div>
            </div>

            <!-- Aktuelle Parameter -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üìä Aktuelle Regel-Parameter</h2>
                    <button class="btn btn-secondary" onclick="loadCurrentParams()">Aktualisieren</button>
                </div>

                <div id="currentParamsContainer" style="max-height: 400px; overflow-y: auto;">
                    <p style="color: #888;">Lade Parameter...</p>
                </div>
            </div>

            <!-- Empfehlungen -->
            <div class="card" id="recommendationsCard" style="display: none;">
                <div class="card-header">
                    <h2 class="card-title">üí° Optimierungs-Empfehlungen</h2>
                    <div class="btn-group">
                        <button class="btn btn-success" onclick="applyAllRecommendations()">‚úì Alle anwenden</button>
                        <button class="btn btn-secondary" onclick="applySelectedRecommendations()">Ausgew√§hlte anwenden</button>
                    </div>
                </div>

                <div id="recommendationsContainer">
                    <!-- Will be populated by JavaScript -->
                </div>
            </div>

            <!-- Pattern-Analyse Ergebnisse -->
            <div class="card" id="analysisResultsCard" style="display: none;">
                <div class="card-header">
                    <h2 class="card-title">üìà Pattern-Analyse Ergebnisse</h2>
                </div>

                <div id="analysisResultsContainer">
                    <!-- Will be populated by JavaScript -->
                </div>
            </div>

            <!-- Parameter-√Ñnderungshistorie -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üìú √Ñnderungshistorie</h2>
                    <button class="btn btn-danger" onclick="resetAllParams()">‚ü≤ Auf Standard zur√ºcksetzen</button>
                </div>

                <div id="paramHistoryContainer" style="max-height: 300px; overflow-y: auto;">
                    <p style="color: #888;">Lade Historie...</p>
                </div>
            </div>

            <!-- Backup/Restore -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üíæ Backup & Restore</h2>
                    <div class="btn-group">
                        <button class="btn btn-success" onclick="createBackup()">+ Backup erstellen</button>
                        <button class="btn btn-primary" onclick="exportConfig()">üì• Exportieren</button>
                        <button class="btn btn-secondary" onclick="document.getElementById('importFileInput').click()">üì§ Importieren</button>
                        <input type="file" id="importFileInput" accept=".json" style="display: none;" onchange="importConfig(event)">
                    </div>
                </div>
                <p style="color: #888; margin-bottom: 1rem;">
                    Sichere deine Regelwerk-Einstellungen oder stelle einen fr√ºheren Stand wieder her.
                    Vor jedem Restore/Import wird automatisch ein Backup erstellt.
                </p>

                <!-- Backup List -->
                <div id="backupListContainer">
                    <p style="color: #888;">Lade Backups...</p>
                </div>
            </div>

            <!-- Factory Reset -->
            <div class="card" style="border: 1px solid rgba(244, 67, 54, 0.3);">
                <div class="card-header">
                    <h2 class="card-title" style="color: #e57373;">‚ö†Ô∏è Factory Reset</h2>
                    <button class="btn btn-danger" onclick="factoryReset()">üóëÔ∏è Alles zur√ºcksetzen</button>
                </div>
                <p style="color: #888;">
                    <strong style="color: #e57373;">Achtung:</strong> Dies l√∂scht ALLE Daten unwiderruflich:
                    Regelwerk-Einstellungen, Feedbacks, Pattern-History, Claude-Validierungen, Backups
                    und Training History. Der Service wird auf den Auslieferungszustand zur√ºckgesetzt.
                </p>
            </div>
        </div><!-- End Tab: Regelwerk Optimierung -->

        <!-- Tab: Claude QA -->
        <div id="tab-claudeqa" class="tab-content">
            <!-- Claude Vision Validator (Combined with Auto-Optimization) -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">ü§ñ Claude Vision Validator</h2>
                    <div class="btn-group">
                        <button class="btn btn-secondary btn-sm" onclick="loadAutoOptStatus()" title="Status und Konfiguration neu laden">Aktualisieren</button>
                    </div>
                </div>
                <p style="font-size: 0.85rem; color: #aaa; margin-bottom: 0.75rem; line-height: 1.4;">
                    Validiert erkannte Candlestick-Patterns mit Claude Vision. Claude analysiert das Chart-Bild und pr√ºft,
                    ob das Pattern den klassischen Kriterien entspricht.
                </p>

                <!-- Status Row -->
                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 0.75rem;">
                    <span style="background: rgba(255,255,255,0.1); padding: 0.3rem 0.6rem; border-radius: 4px; font-size: 0.85rem;"
                          title="Ist die Claude Vision API konfiguriert und aktiv?">
                        <span id="claudeEnabled" style="color: #81c784;">-</span>
                    </span>
                    <span style="background: rgba(255,255,255,0.1); padding: 0.3rem 0.6rem; border-radius: 4px; font-size: 0.85rem;"
                          title="L√§uft der Hintergrund-Validierungsprozess?">
                        Auto: <span id="autoOptRunning" style="color: #888;">-</span>
                    </span>
                    <span style="background: rgba(255,255,255,0.1); padding: 0.3rem 0.6rem; border-radius: 4px; font-size: 0.85rem;"
                          title="Das verwendete Claude-Modell f√ºr die Validierung">
                        Modell: <span id="claudeModel" style="color: #64c8ff;">-</span>
                    </span>
                    <span style="background: rgba(255,255,255,0.1); padding: 0.3rem 0.6rem; border-radius: 4px; font-size: 0.85rem;"
                          title="Anzahl gecachter Validierungsergebnisse (vermeidet doppelte API-Aufrufe)">
                        Cache: <span id="claudeCached" style="color: #ffb74d;">-</span>
                    </span>
                    <span style="background: rgba(255,255,255,0.1); padding: 0.3rem 0.6rem; border-radius: 4px; font-size: 0.85rem;"
                          title="Gesamtanzahl durchgef√ºhrter Validierungen">
                        Total: <span id="claudeTotal" style="color: #ce93d8;">-</span>
                    </span>
                    <span style="background: rgba(255,255,255,0.1); padding: 0.3rem 0.6rem; border-radius: 4px; font-size: 0.85rem;"
                          title="Anzahl neu erkannter Patterns, die auf Claude-Validierung warten">
                        Queue: <span id="autoOptPending" style="color: #ffb74d;">-</span>
                    </span>
                    <span style="background: rgba(255,255,255,0.1); padding: 0.3rem 0.6rem; border-radius: 4px; font-size: 0.85rem;"
                          title="Automatische Parameter-Anpassungen pro Stunde (aktuell / Maximum)">
                        Anpassungen/h: <span id="autoOptAdjustments" style="color: #64c8ff;">-</span>
                    </span>
                </div>

                <!-- Manual Batch Validation -->
                <div style="background: rgba(0,0,0,0.2); padding: 0.75rem; border-radius: 6px; margin-bottom: 0.75rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.5rem;">
                        <span style="font-size: 0.85rem; color: #64c8ff;">Manuelle Batch-Validierung:</span>
                        <div class="btn-group">
                            <button class="btn btn-primary btn-sm" id="btnBatch5" onclick="runBatchValidation(5)" title="5 Patterns aus der Warteschlange mit Claude validieren">5x</button>
                            <button class="btn btn-primary btn-sm" id="btnBatch10" onclick="runBatchValidation(10)" title="10 Patterns aus der Warteschlange mit Claude validieren">10x</button>
                            <button class="btn btn-warning btn-sm" id="btnBatch20" onclick="runBatchValidation(20)" title="20 Patterns aus der Warteschlange mit Claude validieren">20x</button>
                            <button class="btn btn-secondary btn-sm" onclick="runOptimizationCycle()" title="Vollst√§ndigen Optimierungszyklus ausf√ºhren (Sammeln ‚Üí Validieren ‚Üí Analysieren ‚Üí Empfehlen)">Zyklus</button>
                            <button class="btn btn-secondary btn-sm" onclick="showValidationQueue()" title="Warteschlange anzeigen">Queue üìã</button>
                        </div>
                    </div>
                    <div id="batchProgress" style="display: none; margin-top: 0.75rem;">
                        <div style="background: rgba(0,0,0,0.3); padding: 0.75rem; border-radius: 6px;">
                            <!-- Progress Header -->
                            <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                <span class="spinner"></span>
                                <span id="batchProgressText" style="font-weight: 500;">Validierung l√§uft...</span>
                            </div>
                            <!-- Progress Bar -->
                            <div style="background: rgba(255,255,255,0.1); border-radius: 4px; height: 8px; margin-bottom: 0.5rem; overflow: hidden;">
                                <div id="batchProgressBar" style="background: linear-gradient(90deg, #64c8ff, #81c784); height: 100%; width: 0%; transition: width 0.3s ease;"></div>
                            </div>
                            <!-- Progress Stats -->
                            <div id="batchProgressStats" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem; font-size: 0.8rem; text-align: center;">
                                <div><span id="batchStatValidated" style="color: #64c8ff; font-weight: bold;">0</span> / <span id="batchStatTotal">0</span></div>
                                <div style="color: #81c784;"><span id="batchStatAgreed">0</span> ‚úì</div>
                                <div style="color: #e57373;"><span id="batchStatRejected">0</span> ‚úó</div>
                                <div style="color: #ffb74d;"><span id="batchStatErrors">0</span> ‚ö†</div>
                            </div>
                            <!-- Current Pattern -->
                            <div id="batchCurrentPattern" style="margin-top: 0.5rem; font-size: 0.8rem; color: #888; text-align: center; display: none;">
                                Aktuell: <span id="batchCurrentPatternName">-</span>
                            </div>
                        </div>
                    </div>
                    <div id="batchResult" style="display: none; margin-top: 0.5rem; padding: 0.5rem; background: rgba(0,0,0,0.3); border-radius: 4px;">
                        <div id="batchResultContent"></div>
                    </div>
                </div>

                <!-- Auto-Optimization Config (Collapsible) -->
                <div id="autoOptStatusSection">
                    <details style="background: rgba(0,0,0,0.2); border-radius: 6px;">
                        <summary style="padding: 0.75rem; cursor: pointer; font-size: 0.85rem; color: #64c8ff;">
                            ‚öôÔ∏è Auto-Optimierung Konfiguration
                        </summary>
                        <div style="padding: 0 0.75rem 0.75rem 0.75rem;">
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 0.75rem; margin-bottom: 0.75rem;">
                                <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem;" title="Neue erkannte Patterns automatisch zur Validierungs-Queue hinzuf√ºgen">
                                    <input type="checkbox" id="autoOptValidateNew" onchange="updateAutoOptConfig()">
                                    Neue Patterns validieren
                                </label>
                                <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem;" title="Parameter-Empfehlungen automatisch anwenden (max. 3/Stunde)">
                                    <input type="checkbox" id="autoOptAutoApply" onchange="updateAutoOptConfig()">
                                    Empfehlungen auto-anwenden
                                </label>
                                <div style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem;" title="Anteil der neuen Patterns, die validiert werden (0.3 = 30%)">
                                    <span>Sample-Rate:</span>
                                    <input type="number" id="autoOptSampleRate" min="0.1" max="1.0" step="0.1" value="0.3"
                                           style="width: 55px; padding: 0.2rem; background: #1a1a2e; color: #fff; border: 1px solid rgba(255,255,255,0.2); border-radius: 4px;"
                                           onchange="updateAutoOptConfig()">
                                </div>
                                <div style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem;" title="Mindest-Konfidenz f√ºr automatische Empfehlungen">
                                    <span>Min. Konfidenz:</span>
                                    <input type="number" id="autoOptMinConfidence" min="0.5" max="1.0" step="0.05" value="0.85"
                                           style="width: 55px; padding: 0.2rem; background: #1a1a2e; color: #fff; border: 1px solid rgba(255,255,255,0.2); border-radius: 4px;"
                                           onchange="updateAutoOptConfig()">
                                </div>
                            </div>
                            <div class="btn-group">
                                <button class="btn btn-success btn-sm" onclick="toggleAutoOptimization(true)" id="autoOptEnableBtn" title="Automatische Hintergrund-Validierung starten">Auto Ein</button>
                                <button class="btn btn-danger btn-sm" onclick="toggleAutoOptimization(false)" id="autoOptDisableBtn" style="display: none;" title="Automatische Hintergrund-Validierung stoppen">Auto Aus</button>
                                <button class="btn btn-secondary btn-sm" onclick="loadAutoOptHistory()" title="Verlauf der automatischen Parameter-Anpassungen anzeigen">Historie anzeigen</button>
                            </div>
                        </div>
                    </details>

                    <!-- Historie -->
                    <div id="autoOptHistoryContainer" style="display: none; margin-top: 0.75rem; max-height: 150px; overflow-y: auto;">
                        <table class="data-table" style="font-size: 0.8rem;">
                            <thead>
                                <tr>
                                    <th>Zeit</th>
                                    <th>Pattern</th>
                                    <th>Parameter</th>
                                    <th>√Ñnderung</th>
                                </tr>
                            </thead>
                            <tbody id="autoOptHistoryBody"></tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- Two-Column Layout for History (2/3) and Problems (1/3) -->
            <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 1rem;">
                <!-- Validation History (2/3) -->
                <div class="card" style="margin-bottom: 0;">
                    <div class="card-header">
                        <h2 class="card-title" style="font-size: 1rem;">üìú Historie</h2>
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <label style="font-size: 0.8rem; color: #888;">Limit:</label>
                            <select id="claudeHistoryLimit" onchange="loadClaudeHistory()"
                                    style="padding: 0.2rem 0.4rem; background: #1a1a2e; color: #fff; border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; font-size: 0.8rem;">
                                <option value="10" selected>10</option>
                                <option value="25">25</option>
                                <option value="50">50</option>
                                <option value="100">100</option>
                            </select>
                            <button class="btn btn-secondary btn-sm" onclick="loadClaudeHistory()">Aktualisieren</button>
                        </div>
                    </div>
                    <div id="claudeHistoryTable" style="overflow-x: auto; max-height: 300px; overflow-y: auto;">
                        <table class="data-table" style="font-size: 0.8rem; width: 100%;">
                            <thead>
                                <tr>
                                    <th style="text-align: left; width: 70px;">Symbol</th>
                                    <th style="text-align: left; width: 40px;">TF</th>
                                    <th style="text-align: left; min-width: 100px;">Pattern</th>
                                    <th style="text-align: left; width: 65px;">Result</th>
                                    <th style="text-align: left; max-width: 200px;">Begr√ºndung</th>
                                </tr>
                            </thead>
                            <tbody id="claudeHistoryBody">
                                <tr><td colspan="5" style="text-align: center; color: #888; padding: 1rem;"><span class="spinner"></span> Laden...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Problematic Patterns (1/3) -->
                <div class="card" style="margin-bottom: 0;">
                    <div class="card-header">
                        <h2 class="card-title" style="font-size: 1rem;">‚ö†Ô∏è Problematisch</h2>
                        <button class="btn btn-secondary btn-sm" onclick="loadProblematicPatterns()">Aktualisieren</button>
                    </div>
                    <div id="problematicPatternsTable" style="overflow-x: auto; max-height: 300px; overflow-y: auto;">
                        <table class="data-table" style="width: 100%; font-size: 0.8rem;">
                            <thead>
                                <tr>
                                    <th style="text-align: left; padding: 0.5rem;">Pattern</th>
                                    <th style="text-align: center; padding: 0.5rem; width: 40px;">‚úì</th>
                                    <th style="text-align: center; padding: 0.5rem; width: 40px;">‚úó</th>
                                    <th style="text-align: left; padding: 0.5rem; min-width: 80px;">Rate</th>
                                </tr>
                            </thead>
                            <tbody id="problematicPatternsBody">
                                <tr><td colspan="4" style="text-align: center; color: #888; padding: 1rem;"><span class="spinner"></span> Laden...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- Chart Preview -->
            <div class="card" style="margin-top: 1rem;">
                <div class="card-header">
                    <h2 class="card-title" style="font-size: 1rem;">üîç Chart-Vorschau</h2>
                    <button class="btn btn-secondary btn-sm" onclick="loadRecentPatternsForPreview()">Aktualisieren</button>
                </div>
                <div id="chartPreviewSection">
                    <div style="display: flex; gap: 0.5rem; align-items: flex-end; flex-wrap: wrap;">
                        <select id="chartPreviewSelect" onchange="selectPatternForPreview(); loadChartPreview();"
                                style="flex: 2; min-width: 180px; padding: 0.4rem; background: #1a1a2e; color: #fff; border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; font-size: 0.85rem;">
                            <option value="">-- Pattern w√§hlen --</option>
                        </select>
                        <input type="text" id="chartPreviewPatternId" placeholder="oder ID..."
                               style="flex: 1; min-width: 100px; padding: 0.4rem; background: #1a1a2e; color: #fff; border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; font-size: 0.85rem;">
                    </div>
                    <div id="chartPreviewContainer" style="display: none; margin-top: 0.75rem; text-align: center;">
                        <img id="chartPreviewImage" style="max-width: 100%; max-height: 250px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.1);" />
                        <div id="chartPreviewInfo" style="margin-top: 0.3rem; color: #888; font-size: 0.8rem;"></div>
                    </div>
                </div>
            </div>

            <!-- Feedback Loop Section -->
            <div class="card" style="border: 1px solid rgba(100, 200, 255, 0.2);">
                <div class="card-header">
                    <h2 class="card-title" style="font-size: 1rem;">üîÑ Feedback-Loop</h2>
                    <button class="btn btn-secondary btn-sm" onclick="loadFeedbackLoopData()">Aktualisieren</button>
                </div>
                <div id="feedbackSection">
                    <!-- Recommendations -->
                    <div id="recommendationsContainer" style="margin-bottom: 1rem;">
                        <div style="text-align: center; color: #888; padding: 0.5rem; font-size: 0.85rem;">
                            <span class="spinner"></span> Laden...
                        </div>
                    </div>

                    <!-- Current Rules -->
                    <div id="currentRulesContainer" style="padding-top: 0.75rem; border-top: 1px solid rgba(255,255,255,0.1);">
                        <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                            <div style="flex: 1; min-width: 200px;">
                                <h4 style="font-size: 0.85rem; margin-bottom: 0.3rem; color: #64c8ff;">K√ºrzliche Anpassungen</h4>
                                <div id="recentAdjustments" style="max-height: 120px; overflow-y: auto; font-size: 0.8rem;"></div>
                            </div>
                            <div style="flex: 1; min-width: 200px;">
                                <h4 style="font-size: 0.85rem; margin-bottom: 0.3rem; color: #64c8ff;">Parameter</h4>
                                <select id="rulePatternSelect" onchange="showPatternParams()" style="width: 100%; padding: 0.3rem; background: #1a1a2e; color: #fff; border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; font-size: 0.8rem; margin-bottom: 0.3rem;">
                                    <option value="">-- Pattern --</option>
                                </select>
                                <div id="patternParamsTable" style="font-size: 0.8rem;"></div>
                            </div>
                        </div>
                        <button class="btn btn-warning btn-sm" onclick="resetAllRules()" style="margin-top: 0.5rem;">Alle zur√ºcksetzen</button>
                    </div>

                    <!-- Impact Analysis -->
                    <div id="impactContainer" style="padding-top: 0.75rem; border-top: 1px solid rgba(255,255,255,0.1);">
                        <div style="display: flex; gap: 1rem; flex-wrap: wrap; margin-bottom: 0.5rem;">
                            <span style="background: rgba(255,255,255,0.1); padding: 0.3rem 0.6rem; border-radius: 4px; font-size: 0.8rem;">
                                Anpassungen: <strong id="impactTotalAdj">-</strong>
                            </span>
                            <span style="background: rgba(76, 175, 80, 0.2); padding: 0.3rem 0.6rem; border-radius: 4px; font-size: 0.8rem;">
                                Verbesserungen: <strong id="impactImprovements" style="color: #81c784;">-</strong>
                            </span>
                            <span style="background: rgba(100, 200, 255, 0.2); padding: 0.3rem 0.6rem; border-radius: 4px; font-size: 0.8rem;">
                                Erfolgsrate: <strong id="impactSuccessRate" style="color: #64c8ff;">-</strong>
                            </span>
                        </div>
                        <div id="impactDetails" style="font-size: 0.8rem;"></div>
                    </div>
                </div>
            </div>
        </div><!-- End Tab: Claude QA -->

    </main>

    <!-- Revalidation Detail Modal -->
    <div id="revalDetailOverlay" class="reval-detail-overlay" onclick="closeRevalDetail(event)">
        <div class="reval-detail-modal" onclick="event.stopPropagation()">
            <div class="reval-detail-header">
                <div class="reval-detail-title">
                    <span id="revalDetailSymbol">BTCUSD</span>
                    <span class="reval-detail-badge" id="revalDetailType">Korrigiert</span>
                </div>
                <div class="reval-detail-nav">
                    <button class="btn btn-secondary" onclick="navigateRevalDetail(-1)" id="revalPrevBtn" title="Vorheriger">
                        ‚Üê Zur√ºck
                    </button>
                    <span id="revalDetailPosition">1 / 10</span>
                    <button class="btn btn-secondary" onclick="navigateRevalDetail(1)" id="revalNextBtn" title="N√§chster">
                        Weiter ‚Üí
                    </button>
                </div>
                <button class="close-btn" onclick="closeRevalDetail()">&times;</button>
            </div>

            <div class="reval-detail-content">
                <!-- Pattern Info -->
                <div class="reval-detail-info">
                    <div class="reval-detail-info-row">
                        <div class="reval-detail-info-item">
                            <label>Original erkannt</label>
                            <span id="revalDetailOriginal">-</span>
                        </div>
                        <div class="reval-detail-info-item">
                            <label>Korrigiert zu</label>
                            <span id="revalDetailCorrected">-</span>
                        </div>
                        <div class="reval-detail-info-item">
                            <label>Timeframe</label>
                            <span id="revalDetailTimeframe">-</span>
                        </div>
                        <div class="reval-detail-info-item">
                            <label>Zeitpunkt</label>
                            <span id="revalDetailTimestamp">-</span>
                        </div>
                    </div>
                    <!-- Begr√ºndungszeile -->
                    <div class="reval-detail-info-row" id="revalReasonRow" style="display: none; margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid rgba(255,255,255,0.1);">
                        <div class="reval-detail-info-item" style="flex: 1;">
                            <label>Begr√ºndung</label>
                            <span id="revalDetailReason" style="color: #ffb74d;">-</span>
                        </div>
                    </div>
                </div>

                <!-- Charts: Actual vs Reference -->
                <div class="reval-detail-charts" style="display: flex; gap: 1rem; flex-wrap: wrap;">
                    <!-- Aktueller Chart -->
                    <div style="flex: 2; min-width: 300px;">
                        <div style="font-size: 0.8rem; color: #888; margin-bottom: 0.5rem; text-align: center;">Erkanntes Pattern (Marktdaten)</div>
                        <div id="revalDetailChartContainer" style="width: 100%; height: 280px; background: rgba(0,0,0,0.2); border-radius: 8px;"></div>
                    </div>
                    <!-- Referenz-Beispiel -->
                    <div style="flex: 1; min-width: 200px;">
                        <div style="font-size: 0.8rem; color: #888; margin-bottom: 0.5rem; text-align: center;">Referenz-Beispiel</div>
                        <div id="revalDetailReferenceContainer" style="width: 100%; min-height: 150px; background: rgba(0,0,0,0.2); border-radius: 8px; display: flex; align-items: center; justify-content: center;">
                            <span class="spinner"></span>
                        </div>
                    </div>
                </div>

                <!-- Feedback History -->
                <div class="reval-detail-history">
                    <h4>Feedback-Verlauf</h4>
                    <div id="revalDetailFeedbackHistory"></div>
                </div>

                <!-- Current Detection -->
                <div class="reval-detail-current">
                    <h4>Aktuelle Erkennung nach Training</h4>
                    <div id="revalDetailCurrentDetection">
                        <div class="loading"><span class="spinner"></span> Pr√ºfe aktuelle Erkennung...</div>
                    </div>
                </div>

                <!-- Claude Vision Result -->
                <div id="revalClaudeVisionResult" style="display: none; margin: 1rem 0 0.75rem 0; padding: 0.75rem; border-radius: 8px;"></div>

                <!-- Actions -->
                <div class="reval-detail-actions">
                    <button class="btn btn-success" onclick="submitRevalFeedback('correct')" id="revalBtnCorrect">
                        ‚úì Jetzt korrekt erkannt
                    </button>
                    <button class="btn btn-primary" onclick="submitRevalFeedback('not_detected')" id="revalBtnNotDetected">
                        ‚úì Nicht mehr erkannt (gut)
                    </button>
                    <button class="btn btn-danger" onclick="submitRevalFeedback('still_wrong')" id="revalBtnStillWrong">
                        ‚úó Weiterhin falsch
                    </button>
                    <button class="btn btn-secondary" id="revalBtnClaudeVision" onclick="validateRevalWithClaudeVision()"
                            title="Mit Claude Vision pr√ºfen">
                        ü§ñ Claude Vision
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <script>
        const CANDLESTICK_API = '/candlestick/api/v1';
        const CANDLESTICK_TRAIN_API = '/candlestick-train/api/v1';
        const DATA_API = '/data/api/v1';
        let isAutoScanRunning = true;  // Default: aktiv
        let trainingRefreshInterval = null;
        let currentHistoryPage = 1;
        const HISTORY_PAGE_SIZE = 12;
        let ohlcCache = {};  // Cache for OHLC data

        // Revalidation list state
        let allRevalidationItems = [];  // All pending revalidation items
        let filteredRevalidationItems = [];  // Filtered items based on user selection
        let currentRevalDetailIndex = 0;  // Current index in detail view
        let revalDetailChart = null;  // Current chart instance in detail modal

        // Pattern visual examples - each candle: [upperWick, body, lowerWick, type]
        // type: 'bullish', 'bearish', 'doji'
        const patternExamples = {
            // Reversal Bullish
            'hammer': [[2, 8, 22, 'bullish']],
            'inverted_hammer': [[22, 8, 2, 'bullish']],
            'bullish_engulfing': [[4, 18, 4, 'bearish'], [2, 28, 2, 'bullish']],
            'morning_star': [[4, 20, 4, 'bearish'], [8, 4, 8, 'doji'], [2, 22, 4, 'bullish']],
            'three_white_soldiers': [[2, 14, 2, 'bullish'], [2, 16, 2, 'bullish'], [2, 18, 2, 'bullish']],
            'piercing_line': [[4, 22, 4, 'bearish'], [4, 18, 2, 'bullish']],
            'tweezer_bottom': [[4, 16, 12, 'bearish'], [4, 16, 12, 'bullish']],
            'dragonfly_doji': [[0, 2, 28, 'doji']],

            // Reversal Bearish
            'hanging_man': [[2, 8, 22, 'bearish']],
            'shooting_star': [[22, 8, 2, 'bearish']],
            'bearish_engulfing': [[2, 18, 4, 'bullish'], [2, 28, 2, 'bearish']],
            'evening_star': [[2, 20, 4, 'bullish'], [8, 4, 8, 'doji'], [4, 22, 2, 'bearish']],
            'three_black_crows': [[2, 14, 2, 'bearish'], [2, 16, 2, 'bearish'], [2, 18, 2, 'bearish']],
            'dark_cloud_cover': [[2, 22, 4, 'bullish'], [2, 18, 4, 'bearish']],
            'tweezer_top': [[12, 16, 4, 'bullish'], [12, 16, 4, 'bearish']],
            'gravestone_doji': [[28, 2, 0, 'doji']],

            // Continuation
            'rising_three_methods': [[2, 24, 2, 'bullish'], [4, 8, 2, 'bearish'], [4, 6, 2, 'bearish'], [4, 8, 2, 'bearish'], [2, 26, 2, 'bullish']],
            'falling_three_methods': [[2, 24, 2, 'bearish'], [2, 8, 4, 'bullish'], [2, 6, 4, 'bullish'], [2, 8, 4, 'bullish'], [2, 26, 2, 'bearish']],
            'upside_tasuki_gap': [[2, 16, 2, 'bullish'], [2, 16, 2, 'bullish'], [4, 12, 2, 'bearish']],
            'downside_tasuki_gap': [[2, 16, 2, 'bearish'], [2, 16, 2, 'bearish'], [2, 12, 4, 'bullish']],
            'mat_hold': [[2, 20, 2, 'bullish'], [4, 8, 2, 'bearish'], [4, 6, 4, 'bearish'], [2, 8, 4, 'bullish'], [2, 22, 2, 'bullish']],
            'bullish_marubozu': [[0, 30, 0, 'bullish']],
            'bearish_marubozu': [[0, 30, 0, 'bearish']],

            // Indecision
            'doji': [[12, 2, 12, 'doji']],
            'long_legged_doji': [[16, 2, 16, 'doji']],
            'spinning_top': [[10, 8, 10, 'bullish']],
            'high_wave': [[14, 6, 14, 'doji']],
            // Bullish Harami: Abw√§rtstrend (rot) + gro√üe rote Kerze + kleine gr√ºne Kerze
            'harami': [[3, 14, 3, 'bearish'], [2, 16, 2, 'bearish'], [2, 24, 2, 'bearish'], [6, 10, 6, 'bullish']],
            'bullish_harami': [[3, 14, 3, 'bearish'], [2, 16, 2, 'bearish'], [2, 24, 2, 'bearish'], [6, 10, 6, 'bullish']],
            // Bearish Harami: Aufw√§rtstrend (gr√ºn) + gro√üe gr√ºne Kerze + kleine rote Kerze
            'bearish_harami': [[3, 14, 3, 'bullish'], [2, 16, 2, 'bullish'], [2, 24, 2, 'bullish'], [6, 10, 6, 'bearish']],
            // Harami Cross: Abw√§rtstrend (rot) + gro√üe Kerze + Doji
            'harami_cross': [[3, 14, 3, 'bearish'], [2, 16, 2, 'bearish'], [2, 24, 2, 'bearish'], [8, 2, 8, 'doji']],
            'bullish_harami_cross': [[3, 14, 3, 'bearish'], [2, 16, 2, 'bearish'], [2, 24, 2, 'bearish'], [8, 2, 8, 'doji']],
            'bearish_harami_cross': [[3, 14, 3, 'bullish'], [2, 16, 2, 'bullish'], [2, 24, 2, 'bullish'], [8, 2, 8, 'doji']],
            'inside_bar': [[4, 20, 4, 'bearish'], [6, 12, 6, 'bullish']],

            // New patterns
            'bullish_belt_hold': [[0, 28, 2, 'bullish']],
            'bearish_belt_hold': [[2, 28, 0, 'bearish']],
            'bullish_counterattack': [[4, 18, 4, 'bearish'], [4, 18, 4, 'bullish']],
            'bearish_counterattack': [[4, 18, 4, 'bullish'], [4, 18, 4, 'bearish']],
            'three_inside_up': [[4, 22, 4, 'bearish'], [6, 10, 6, 'bullish'], [2, 20, 4, 'bullish']],
            'three_inside_down': [[4, 22, 4, 'bullish'], [6, 10, 6, 'bearish'], [4, 20, 2, 'bearish']],
            'bullish_abandoned_baby': [[4, 18, 4, 'bearish'], [10, 2, 10, 'doji'], [4, 18, 4, 'bullish']],
            'bearish_abandoned_baby': [[4, 18, 4, 'bullish'], [10, 2, 10, 'doji'], [4, 18, 4, 'bearish']],
            'tower_bottom': [[4, 22, 4, 'bearish'], [6, 8, 6, 'bearish'], [6, 6, 6, 'bullish'], [6, 8, 6, 'bullish'], [4, 22, 4, 'bullish']],
            'tower_top': [[4, 22, 4, 'bullish'], [6, 8, 6, 'bullish'], [6, 6, 6, 'bearish'], [6, 8, 6, 'bearish'], [4, 22, 4, 'bearish']],
            'advance_block': [[2, 20, 2, 'bullish'], [4, 14, 6, 'bullish'], [6, 10, 8, 'bullish']],
            'bearish_island': [[4, 18, 4, 'bullish'], [4, 10, 4, 'bearish'], [4, 20, 4, 'bearish']],
            'bullish_island': [[4, 18, 4, 'bearish'], [4, 10, 4, 'bullish'], [4, 20, 4, 'bullish']],

            // Default fallback
            'default': [[8, 12, 8, 'doji']]
        };

        // Detaillierte Erkennungsregeln pro Pattern-Typ
        const PATTERN_RULES = {
            // === REVERSAL BULLISH ===
            'hammer': {
                candles: 1,
                rules: [
                    'Kleiner Body (< 30% der Gesamtrange)',
                    'Langer unterer Schatten (‚â• 2x Body-Gr√∂√üe)',
                    'Kurzer oder kein oberer Schatten (< 10% der Range)',
                    'Body im oberen Drittel der Kerze',
                    'Erscheint idealerweise nach Abw√§rtstrend'
                ],
                confidence: 'H√∂her wenn: Volumen erh√∂ht, nach klarem Abw√§rtstrend'
            },
            'inverted_hammer': {
                candles: 1,
                rules: [
                    'Kleiner Body (< 30% der Gesamtrange)',
                    'Langer oberer Schatten (‚â• 2x Body-Gr√∂√üe)',
                    'Kurzer oder kein unterer Schatten (< 10% der Range)',
                    'Body im unteren Drittel der Kerze',
                    'Erscheint idealerweise nach Abw√§rtstrend'
                ],
                confidence: 'Best√§tigung durch folgende bullische Kerze empfohlen'
            },
            'bullish_engulfing': {
                candles: 2,
                rules: [
                    'Erste Kerze: bearish (rot) mit signifikantem Body',
                    'Zweite Kerze: bullish (gr√ºn)',
                    'Body der zweiten Kerze umschlie√üt den Body der ersten vollst√§ndig',
                    'Zweite Kerze ‚â• 1.5x gr√∂√üer als erste Kerze',
                    'Preisbewegung der zweiten Kerze ‚â• 0.25% (filtert Noise)',
                    'Body-Anteil erste Kerze ‚â• 25% ihrer Range (kein Doji)',
                    'Body-Anteil zweite Kerze ‚â• 40% ihrer Range'
                ],
                confidence: 'H√∂her nach Abw√§rtstrend, bei Unterst√ºtzung'
            },
            'morning_star': {
                candles: 3,
                rules: [
                    'Erste Kerze: gro√üe bearish Kerze',
                    'Zweite Kerze: kleiner Body (Stern), Gap nach unten m√∂glich',
                    'Dritte Kerze: gro√üe bullish Kerze, schlie√üt √ºber 50% der ersten',
                    'Stern kann Doji oder Spinning Top sein'
                ],
                confidence: 'St√§rkstes Signal mit Gap zwischen Kerzen'
            },
            'piercing_line': {
                candles: 2,
                rules: [
                    'Erste Kerze: gro√üe bearish Kerze',
                    'Zweite Kerze: er√∂ffnet unter dem Close der ersten',
                    'Zweite Kerze: schlie√üt √ºber 50% des Bodies der ersten',
                    'Zweite Kerze: bullish mit signifikantem Body'
                ],
                confidence: 'Tiefere Er√∂ffnung = st√§rkeres Signal'
            },
            'dragonfly_doji': {
                candles: 1,
                rules: [
                    'Open ‚âà High ‚âà Close (Doji-Bedingung)',
                    'Langer unterer Schatten (‚â• 3x Body)',
                    'Kein oder minimaler oberer Schatten',
                    'Body < 5% der Gesamtrange'
                ],
                confidence: 'Bullish nach Abw√§rtstrend, bearish nach Aufw√§rtstrend'
            },

            // === REVERSAL BEARISH ===
            'hanging_man': {
                candles: 1,
                rules: [
                    'Identische Form wie Hammer',
                    'Erscheint nach Aufw√§rtstrend (entscheidender Unterschied)',
                    'Kleiner Body oben, langer unterer Schatten',
                    'Warnsignal f√ºr Trendumkehr'
                ],
                confidence: 'Best√§tigung durch folgende bearische Kerze empfohlen'
            },
            'shooting_star': {
                candles: 1,
                rules: [
                    'Kleiner Body (< 30% der Gesamtrange)',
                    'Langer oberer Schatten (‚â• 2x Body-Gr√∂√üe)',
                    'Kurzer oder kein unterer Schatten (< 10% der Range)',
                    'Body im unteren Drittel der Kerze',
                    'Erscheint nach Aufw√§rtstrend'
                ],
                confidence: 'H√∂her bei Widerstandsniveau'
            },
            'bearish_engulfing': {
                candles: 2,
                rules: [
                    'Erste Kerze: bullish (gr√ºn) mit signifikantem Body',
                    'Zweite Kerze: bearish (rot)',
                    'Body der zweiten Kerze umschlie√üt den Body der ersten vollst√§ndig',
                    'Zweite Kerze ‚â• 1.5x gr√∂√üer als erste Kerze',
                    'Preisbewegung der zweiten Kerze ‚â• 0.25% (filtert Noise)',
                    'Body-Anteil erste Kerze ‚â• 25% ihrer Range (kein Doji)',
                    'Body-Anteil zweite Kerze ‚â• 40% ihrer Range'
                ],
                confidence: 'H√∂her nach Aufw√§rtstrend, bei Widerstand'
            },
            'evening_star': {
                candles: 3,
                rules: [
                    'Erste Kerze: gro√üe bullish Kerze',
                    'Zweite Kerze: kleiner Body (Stern), Gap nach oben m√∂glich',
                    'Dritte Kerze: gro√üe bearish Kerze, schlie√üt unter 50% der ersten',
                    'Stern kann Doji oder Spinning Top sein'
                ],
                confidence: 'St√§rkstes Signal mit Gap zwischen Kerzen'
            },
            'dark_cloud_cover': {
                candles: 2,
                rules: [
                    'Erste Kerze: gro√üe bullish Kerze',
                    'Zweite Kerze: er√∂ffnet √ºber dem Close der ersten',
                    'Zweite Kerze: schlie√üt unter 50% des Bodies der ersten',
                    'Zweite Kerze: bearish mit signifikantem Body'
                ],
                confidence: 'H√∂here Er√∂ffnung = st√§rkeres Signal'
            },
            'gravestone_doji': {
                candles: 1,
                rules: [
                    'Open ‚âà Low ‚âà Close (Doji-Bedingung)',
                    'Langer oberer Schatten (‚â• 3x Body)',
                    'Kein oder minimaler unterer Schatten',
                    'Body < 5% der Gesamtrange'
                ],
                confidence: 'Bearish nach Aufw√§rtstrend'
            },

            // === CONTINUATION ===
            'three_white_soldiers': {
                candles: 3,
                rules: [
                    'Drei aufeinanderfolgende bullish Kerzen',
                    'Jede Kerze er√∂ffnet innerhalb des Bodies der vorherigen',
                    'Jede Kerze schlie√üt nahe am High',
                    'Progressiv h√∂here Closes',
                    'Keine langen oberen Schatten'
                ],
                confidence: 'Starkes Fortsetzungssignal im Aufw√§rtstrend'
            },
            'three_black_crows': {
                candles: 3,
                rules: [
                    'Drei aufeinanderfolgende bearish Kerzen',
                    'Jede Kerze er√∂ffnet innerhalb des Bodies der vorherigen',
                    'Jede Kerze schlie√üt nahe am Low',
                    'Progressiv tiefere Closes',
                    'Keine langen unteren Schatten'
                ],
                confidence: 'Starkes Fortsetzungssignal im Abw√§rtstrend'
            },
            'rising_three_methods': {
                candles: 5,
                rules: [
                    'Erste Kerze: gro√üe bullish Kerze',
                    '2-4. Kerze: kleine bearish Kerzen innerhalb der Range der ersten',
                    'F√ºnfte Kerze: gro√üe bullish Kerze, schlie√üt √ºber High der ersten',
                    'Kleine Kerzen zeigen Konsolidierung, kein Trendwechsel'
                ],
                confidence: 'Klassisches bullish Fortsetzungsmuster'
            },
            'falling_three_methods': {
                candles: 5,
                rules: [
                    'Erste Kerze: gro√üe bearish Kerze',
                    '2-4. Kerze: kleine bullish Kerzen innerhalb der Range der ersten',
                    'F√ºnfte Kerze: gro√üe bearish Kerze, schlie√üt unter Low der ersten',
                    'Kleine Kerzen zeigen Konsolidierung, kein Trendwechsel'
                ],
                confidence: 'Klassisches bearish Fortsetzungsmuster'
            },

            // === INDECISION ===
            'doji': {
                candles: 1,
                rules: [
                    'Open ‚âà Close (Body < 10% der Gesamtrange)',
                    'Ober- und Unterschatten vorhanden',
                    'Signalisiert Marktunentschlossenheit',
                    'Kontext entscheidet √ºber Bedeutung'
                ],
                confidence: 'Wichtiger nach starkem Trend'
            },
            'spinning_top': {
                candles: 1,
                rules: [
                    'Kleiner Body (< 30% der Gesamtrange)',
                    'Signifikante Schatten auf beiden Seiten (‚â• 25% jeweils)',
                    'Schatten ungef√§hr gleich lang (Differenz < 20%)',
                    'Zeigt Unentschlossenheit zwischen K√§ufern und Verk√§ufern'
                ],
                confidence: 'Signal f√ºr m√∂gliche Trendwende oder Konsolidierung'
            },
            'bullish_harami': {
                candles: 2,
                rules: [
                    'Erste Kerze: gro√üe bearish Kerze',
                    'Zweite Kerze: kleine bullish Kerze',
                    'Body der zweiten liegt vollst√§ndig innerhalb der ersten',
                    'Zeigt nachlassenden Verkaufsdruck'
                ],
                confidence: 'Best√§tigung durch folgende bullische Kerze empfohlen'
            },
            'bearish_harami': {
                candles: 2,
                rules: [
                    'Erste Kerze: gro√üe bullish Kerze',
                    'Zweite Kerze: kleine bearish Kerze',
                    'Body der zweiten liegt vollst√§ndig innerhalb der ersten',
                    'Zeigt nachlassenden Kaufdruck'
                ],
                confidence: 'Best√§tigung durch folgende bearische Kerze empfohlen'
            },
            'harami_cross': {
                candles: 2,
                rules: [
                    'Erste Kerze: gro√üe Kerze (bullish oder bearish)',
                    'Zweite Kerze: Doji innerhalb des Bodies der ersten',
                    'St√§rker als normales Harami',
                    'Doji verst√§rkt die Unentschlossenheit'
                ],
                confidence: 'Starkes Umkehrsignal, Best√§tigung empfohlen'
            },

            // === NEW PATTERNS ===
            'bullish_belt_hold': {
                candles: 1,
                rules: [
                    'Langer bullischer Body (‚â• 75% der Gesamtrange)',
                    'Er√∂ffnet am oder sehr nahe am Low (unterer Schatten < 5%)',
                    'Kleiner oder kein oberer Schatten (< 15%)',
                    'Erscheint nach Abw√§rtstrend',
                    'Gap Down vor der Kerze verst√§rkt das Signal'
                ],
                confidence: 'H√∂her mit Gap, nach klarem Abw√§rtstrend'
            },
            'bearish_belt_hold': {
                candles: 1,
                rules: [
                    'Langer bearischer Body (‚â• 75% der Gesamtrange)',
                    'Er√∂ffnet am oder sehr nahe am High (oberer Schatten < 5%)',
                    'Kleiner oder kein unterer Schatten (< 15%)',
                    'Erscheint nach Aufw√§rtstrend',
                    'Gap Up vor der Kerze verst√§rkt das Signal'
                ],
                confidence: 'H√∂her mit Gap, nach klarem Aufw√§rtstrend'
            },
            'bullish_counterattack': {
                candles: 2,
                rules: [
                    'Erste Kerze: bearish mit signifikantem Body',
                    'Zweite Kerze: bullish mit Gap Down Er√∂ffnung',
                    'Beide Kerzen schlie√üen auf ungef√§hr gleichem Niveau',
                    'Beide Bodies sind signifikant (nicht Doji)',
                    'Schlusskurs-Differenz < 0.3% des Preises'
                ],
                confidence: 'Starkes Signal nach klarem Abw√§rtstrend'
            },
            'bearish_counterattack': {
                candles: 2,
                rules: [
                    'Erste Kerze: bullish mit signifikantem Body',
                    'Zweite Kerze: bearish mit Gap Up Er√∂ffnung',
                    'Beide Kerzen schlie√üen auf ungef√§hr gleichem Niveau',
                    'Beide Bodies sind signifikant (nicht Doji)',
                    'Schlusskurs-Differenz < 0.3% des Preises'
                ],
                confidence: 'Starkes Signal nach klarem Aufw√§rtstrend'
            },
            'three_inside_up': {
                candles: 3,
                rules: [
                    'Erste Kerze: gro√üe bearish Kerze',
                    'Zweite Kerze: kleine bullish Kerze vollst√§ndig innerhalb des ersten Bodies (Harami)',
                    'Dritte Kerze: bullish, schlie√üt √ºber dem Open der ersten Kerze',
                    'Erscheint nach Abw√§rtstrend',
                    'Best√§tigt das Harami-Pattern'
                ],
                confidence: 'Sehr zuverl√§ssiges bullish Umkehrsignal'
            },
            'three_inside_down': {
                candles: 3,
                rules: [
                    'Erste Kerze: gro√üe bullish Kerze',
                    'Zweite Kerze: kleine bearish Kerze vollst√§ndig innerhalb des ersten Bodies (Harami)',
                    'Dritte Kerze: bearish, schlie√üt unter dem Open der ersten Kerze',
                    'Erscheint nach Aufw√§rtstrend',
                    'Best√§tigt das Harami-Pattern'
                ],
                confidence: 'Sehr zuverl√§ssiges bearish Umkehrsignal'
            },
            'bullish_abandoned_baby': {
                candles: 3,
                rules: [
                    'Erste Kerze: bearish mit signifikantem Body',
                    'Zweite Kerze: Doji mit Gap Down (High unter Low der ersten)',
                    'Dritte Kerze: bullish mit Gap Up (Low √ºber High des Doji)',
                    'Der Doji schwebt isoliert durch Gaps auf beiden Seiten',
                    'Seltenes aber sehr starkes Pattern'
                ],
                confidence: 'Eines der st√§rksten bullish Umkehrsignale'
            },
            'bearish_abandoned_baby': {
                candles: 3,
                rules: [
                    'Erste Kerze: bullish mit signifikantem Body',
                    'Zweite Kerze: Doji mit Gap Up (Low √ºber High der ersten)',
                    'Dritte Kerze: bearish mit Gap Down (High unter Low des Doji)',
                    'Der Doji schwebt isoliert durch Gaps auf beiden Seiten',
                    'Seltenes aber sehr starkes Pattern'
                ],
                confidence: 'Eines der st√§rksten bearish Umkehrsignale'
            },
            'tower_bottom': {
                candles: 5,
                rules: [
                    'Erste Kerze: gro√üe bearish Kerze (Turmwand)',
                    'Mittlere Kerzen (2-4): kleine Bodies in Konsolidierungszone',
                    'Letzte Kerze: gro√üe bullish Kerze (Turmwand)',
                    'Kleine Kerzen bilden ein "Dach" zwischen den Turmw√§nden',
                    'Erscheint am Ende eines Abw√§rtstrends'
                ],
                confidence: 'Zuverl√§ssiges Umkehrmuster, je l√§nger Konsolidierung desto st√§rker'
            },
            'tower_top': {
                candles: 5,
                rules: [
                    'Erste Kerze: gro√üe bullish Kerze (Turmwand)',
                    'Mittlere Kerzen (2-4): kleine Bodies in Konsolidierungszone',
                    'Letzte Kerze: gro√üe bearish Kerze (Turmwand)',
                    'Kleine Kerzen bilden ein "Dach" zwischen den Turmw√§nden',
                    'Erscheint am Ende eines Aufw√§rtstrends'
                ],
                confidence: 'Zuverl√§ssiges Umkehrmuster, je l√§nger Konsolidierung desto st√§rker'
            },
            'advance_block': {
                candles: 3,
                rules: [
                    'Drei aufeinanderfolgende bullische (gr√ºne) Kerzen',
                    'Jede Kerze √∂ffnet innerhalb des Bodies der vorherigen Kerze',
                    'Bodies werden progressiv KLEINER (abnehmende Kaufkraft)',
                    'Obere Schatten werden progressiv L√ÑNGER (zunehmender Verkaufsdruck)',
                    'Jede Kerze schlie√üt h√∂her als die vorherige',
                    'Erscheint nach einem Aufw√§rtstrend'
                ],
                confidence: 'Warnsignal f√ºr nachlassende Kaufkraft - b√§rische Umkehr m√∂glich'
            },
            'bearish_island': {
                candles: 3,
                rules: [
                    'Gap UP vor der Insel (Low der Inselkerze > High der vorherigen)',
                    'Eine oder mehrere Kerzen bilden die isolierte "Insel"',
                    'Gap DOWN nach der Insel (High der letzten Inselkerze < Low der n√§chsten)',
                    'Best√§tigungskerze nach dem Gap ist bearish',
                    'Erscheint nach einem Aufw√§rtstrend'
                ],
                confidence: 'Starkes b√§risches Umkehrsignal - Gaps best√§tigen Trendwende'
            },
            'bullish_island': {
                candles: 3,
                rules: [
                    'Gap DOWN vor der Insel (High der Inselkerze < Low der vorherigen)',
                    'Eine oder mehrere Kerzen bilden die isolierte "Insel"',
                    'Gap UP nach der Insel (Low der letzten Inselkerze > High der n√§chsten)',
                    'Best√§tigungskerze nach dem Gap ist bullish',
                    'Erscheint nach einem Abw√§rtstrend'
                ],
                confidence: 'Starkes bullisches Umkehrsignal - Gaps best√§tigen Trendwende'
            }
        };

        // Generate HTML for pattern candles
        function renderPatternExample(patternType) {
            const candles = patternExamples[patternType] || patternExamples['default'];

            return `<div class="pattern-example">${candles.map(([upperWick, body, lowerWick, type]) => `
                <div class="candle">
                    <div class="wick" style="height: ${upperWick}px;"></div>
                    <div class="body ${type}" style="height: ${body}px;"></div>
                    <div class="wick" style="height: ${lowerWick}px;"></div>
                </div>
            `).join('')}</div>`;
        }

        // Show toast notification
        function showToast(message, type = 'info') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast toast-${type} show`;
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        // Format timestamp
        function formatTimestamp(isoString) {
            if (!isoString) return '-';
            const date = new Date(isoString);
            return date.toLocaleString('de-CH', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        // Format pattern type for display
        function formatPatternType(type) {
            return type
                .split('_')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }

        // Load service info
        async function loadServiceInfo() {
            try {
                const res = await fetch(`${CANDLESTICK_API}/info`);
                const data = await res.json();

                document.getElementById('serviceStatus').textContent = 'Online';
                document.getElementById('serviceStatus').style.background = 'rgba(76, 175, 80, 0.2)';
                document.getElementById('serviceStatus').style.color = '#81c784';

                document.getElementById('infoVersion').textContent = data.version || '-';
                document.getElementById('infoStarted').textContent = formatTimestamp(data.started_at);
                document.getElementById('patternCount').textContent = data.pattern_types || 0;
                document.getElementById('timeframeCount').textContent = data.supported_timeframes?.length || 0;

                // Render timeframes
                const tfList = document.getElementById('timeframeList');
                if (data.supported_timeframes && data.supported_timeframes.length > 0) {
                    tfList.innerHTML = data.supported_timeframes.map(tf =>
                        `<span class="timeframe-badge">${tf}</span>`
                    ).join('');
                } else {
                    tfList.innerHTML = '<span style="color: #888;">Keine Timeframes verf√ºgbar</span>';
                }

            } catch (error) {
                console.error('Failed to load service info:', error);
                document.getElementById('serviceStatus').textContent = 'Offline';
                document.getElementById('serviceStatus').style.background = 'rgba(244, 67, 54, 0.2)';
                document.getElementById('serviceStatus').style.color = '#e57373';
            }
        }

        // Load pattern list
        async function loadPatterns() {
            try {
                const res = await fetch(`${CANDLESTICK_API}/patterns`);
                const data = await res.json();

                const categories = data.categories || {};

                // Render reversal patterns
                renderPatternCategory('reversalPatterns', 'reversalCount', categories.reversal || []);

                // Render continuation patterns
                renderPatternCategory('continuationPatterns', 'continuationCount', categories.continuation || []);

                // Render indecision patterns
                renderPatternCategory('indecisionPatterns', 'indecisionCount', categories.indecision || []);

            } catch (error) {
                console.error('Failed to load patterns:', error);
            }
        }

        // Alias for loadPatterns (used by Pattern-Typen tab)
        const loadPatternTypes = loadPatterns;

        // Cache for loaded API chart images
        const patternImageCache = {};

        // Render pattern category
        function renderPatternCategory(containerId, countId, patterns) {
            const container = document.getElementById(containerId);
            document.getElementById(countId).textContent = patterns.length;

            if (patterns.length === 0) {
                container.innerHTML = '<p style="color: #666;">Keine Patterns in dieser Kategorie</p>';
                return;
            }

            container.innerHTML = patterns.map(p => {
                const rules = PATTERN_RULES[p.type];
                const rulesHtml = rules ? `
                    <div class="pattern-rules">
                        <div class="pattern-rules-header" onclick="togglePatternRules('${p.type}')">
                            <span>üìã Erkennungsregeln</span>
                            <span class="pattern-rules-toggle" id="toggle-${p.type}">‚ñº</span>
                        </div>
                        <div class="pattern-rules-content" id="rules-${p.type}" style="display: none;">
                            <div class="pattern-rules-meta">
                                <span class="pattern-candles-badge">${rules.candles} Kerze${rules.candles > 1 ? 'n' : ''}</span>
                            </div>
                            <ul class="pattern-rules-list">
                                ${rules.rules.map(r => `<li>${r}</li>`).join('')}
                            </ul>
                            <div class="pattern-rules-confidence">
                                <strong>üí° Konfidenz:</strong> ${rules.confidence}
                            </div>
                        </div>
                    </div>
                ` : '';

                return `
                    <div class="pattern-card">
                        <div class="pattern-header">
                            <span class="pattern-name">${formatPatternType(p.type)}</span>
                            <div class="pattern-badges">
                                <span class="badge badge-${p.direction}">${p.direction}</span>
                            </div>
                        </div>
                        <div class="pattern-chart-container" id="chart-${p.type}" onclick="loadPatternChart('${p.type}')" title="Klicken f√ºr Beispiel-Chart">
                            ${renderPatternExample(p.type)}
                        </div>
                        <p class="pattern-description">${p.description}</p>
                        ${rulesHtml}
                    </div>
                `;
            }).join('');
        }

        // Toggle pattern rules visibility
        function togglePatternRules(patternType) {
            const content = document.getElementById(`rules-${patternType}`);
            const toggle = document.getElementById(`toggle-${patternType}`);
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '‚ñ≤';
            } else {
                content.style.display = 'none';
                toggle.textContent = '‚ñº';
            }
        }

        // Load pattern chart from API
        async function loadPatternChart(patternType) {
            const container = document.getElementById(`chart-${patternType}`);
            if (!container) return;

            // Check cache first
            if (patternImageCache[patternType]) {
                container.innerHTML = `<img src="data:image/png;base64,${patternImageCache[patternType]}" alt="${patternType}" style="max-width: 100%; height: auto; border-radius: 4px;">`;
                return;
            }

            // Show loading
            container.innerHTML = '<div style="text-align: center; padding: 1rem; color: #888;"><span class="spinner" style="width: 20px; height: 20px;"></span></div>';

            try {
                const res = await fetch(`${CANDLESTICK_API}/examples/chart/${patternType}?compact=true`);
                if (!res.ok) throw new Error('Failed to load chart');
                const data = await res.json();

                // Cache the image
                patternImageCache[patternType] = data.image_base64;

                // Display the image
                container.innerHTML = `<img src="data:image/png;base64,${data.image_base64}" alt="${patternType}" style="max-width: 100%; height: auto; border-radius: 4px;">`;
            } catch (error) {
                console.error(`Failed to load chart for ${patternType}:`, error);
                // Fall back to simple example
                container.innerHTML = renderPatternExample(patternType);
            }
        }

        // Load statistics
        async function loadStatistics() {
            try {
                // Try candlestick service first
                const res = await fetch(`${CANDLESTICK_API}/history/statistics`);
                const stats = await res.json();

                document.getElementById('historyCount').textContent = stats.total_patterns || 0;
                document.getElementById('bullishCount').textContent = stats.by_direction?.bullish || 0;
                document.getElementById('bearishCount').textContent = stats.by_direction?.bearish || 0;
                document.getElementById('neutralCount').textContent = stats.by_direction?.neutral || 0;

                // Update scan status (check both root and history object)
                isAutoScanRunning = stats.history?.scan_running || stats.scan_running || false;
                updateScanStatus();

            } catch (error) {
                console.error('Failed to load statistics:', error);
                // Try data service as fallback
                try {
                    const res2 = await fetch(`${DATA_API}/patterns/history/statistics`);
                    const stats2 = await res2.json();
                    document.getElementById('historyCount').textContent = stats2.total_patterns || 0;
                    document.getElementById('bullishCount').textContent = stats2.by_direction?.bullish || 0;
                    document.getElementById('bearishCount').textContent = stats2.by_direction?.bearish || 0;
                    document.getElementById('neutralCount').textContent = stats2.by_direction?.neutral || 0;
                } catch (e2) {
                    console.error('Fallback also failed:', e2);
                }
            }
        }

        // Update scan status display
        function updateScanStatus() {
            const statusEl = document.getElementById('scanStatus');
            const statusText = document.getElementById('scanStatusText');
            const statusDot = statusEl.querySelector('.status-dot');
            const btnStart = document.getElementById('btnStartScan');
            const btnStop = document.getElementById('btnStopScan');

            if (isAutoScanRunning) {
                statusEl.classList.remove('stopped');
                statusEl.classList.add('running');
                statusDot.classList.remove('stopped');
                statusDot.classList.add('running');
                statusText.textContent = 'L√§uft';
                btnStart.style.display = 'none';
                btnStop.style.display = 'inline-flex';
            } else {
                statusEl.classList.remove('running');
                statusEl.classList.add('stopped');
                statusDot.classList.remove('running');
                statusDot.classList.add('stopped');
                statusText.textContent = 'Gestoppt';
                btnStart.style.display = 'inline-flex';
                btnStop.style.display = 'none';
            }
        }

        // Start auto scan
        async function startAutoScan() {
            try {
                // Try candlestick service
                await fetch(`${CANDLESTICK_API}/scan/start`, { method: 'POST' });
                isAutoScanRunning = true;
                updateScanStatus();
                showToast('Auto-Scan gestartet', 'success');
            } catch (error) {
                // Try data service fallback
                try {
                    await fetch(`${DATA_API}/patterns/history/start-auto-scan`, { method: 'POST' });
                    isAutoScanRunning = true;
                    updateScanStatus();
                    showToast('Auto-Scan gestartet', 'success');
                } catch (e2) {
                    showToast('Fehler beim Starten', 'error');
                    console.error('Start auto scan failed:', e2);
                }
            }
        }

        // Stop auto scan
        async function stopAutoScan() {
            try {
                // Try candlestick service
                await fetch(`${CANDLESTICK_API}/scan/stop`, { method: 'POST' });
                isAutoScanRunning = false;
                updateScanStatus();
                showToast('Auto-Scan gestoppt', 'info');
            } catch (error) {
                // Try data service fallback
                try {
                    await fetch(`${DATA_API}/patterns/history/stop-auto-scan`, { method: 'POST' });
                    isAutoScanRunning = false;
                    updateScanStatus();
                    showToast('Auto-Scan gestoppt', 'info');
                } catch (e2) {
                    showToast('Fehler beim Stoppen', 'error');
                    console.error('Stop auto scan failed:', e2);
                }
            }
        }

        // Trigger manual scan
        async function triggerManualScan() {
            const btn = event.target;
            btn.disabled = true;
            btn.textContent = 'Scanne...';

            try {
                // Try candlestick service
                const res = await fetch(`${CANDLESTICK_API}/history/scan`, { method: 'POST' });
                const result = await res.json();
                showToast(`Scan abgeschlossen: ${result.new_patterns_found || 0} neue Patterns`, 'success');
                await loadStatistics();
            } catch (error) {
                // Try data service fallback
                try {
                    const res2 = await fetch(`${DATA_API}/patterns/history/scan`, { method: 'POST' });
                    const result2 = await res2.json();
                    showToast(`Scan abgeschlossen: ${result2.new_patterns_found || 0} neue Patterns`, 'success');
                    await loadStatistics();
                } catch (e2) {
                    showToast('Scan fehlgeschlagen', 'error');
                    console.error('Manual scan failed:', e2);
                }
            } finally {
                btn.disabled = false;
                btn.textContent = 'Jetzt scannen';
            }
        }

        // Clear history
        async function clearHistory() {
            if (!confirm('M√∂chten Sie wirklich die gesamte Pattern-History l√∂schen?')) {
                return;
            }

            try {
                // Try candlestick service
                await fetch(`${CANDLESTICK_API}/history/clear`, { method: 'POST' });
                showToast('History gel√∂scht', 'info');
                await loadStatistics();
            } catch (error) {
                // Try data service fallback
                try {
                    await fetch(`${DATA_API}/patterns/history`, { method: 'DELETE' });
                    showToast('History gel√∂scht', 'info');
                    await loadStatistics();
                } catch (e2) {
                    showToast('Fehler beim L√∂schen', 'error');
                    console.error('Clear history failed:', e2);
                }
            }
        }

        // === Status Dashboard ===
        async function loadStatusDashboard() {
            try {
                // Load all data in parallel
                const [infoRes, statsRes, trainInfoRes, feedbackRes, revalRes] = await Promise.all([
                    fetch(`${CANDLESTICK_API}/info`).catch(() => null),
                    fetch(`${CANDLESTICK_API}/history/statistics`).catch(() => null),
                    fetch(`${CANDLESTICK_TRAIN_API}/info`).catch(() => null),
                    fetch(`${CANDLESTICK_API}/history/feedback/statistics`).catch(() => null),
                    fetch(`${CANDLESTICK_API}/history/revalidation-statistics`).catch(() => null)
                ]);

                // Detection KPIs from /info
                if (infoRes?.ok) {
                    const info = await infoRes.json();
                    document.getElementById('statusServiceBadge').textContent = 'Online';
                    document.getElementById('statusServiceBadge').style.background = 'rgba(76, 175, 80, 0.2)';
                    document.getElementById('statusServiceBadge').style.color = '#81c784';
                    document.getElementById('statusVersion').textContent = info.version || '-';
                    document.getElementById('statusStarted').textContent = info.started_at ? new Date(info.started_at).toLocaleString('de-CH') : '-';
                    document.getElementById('statusPatternTypes').textContent = info.pattern_types || '-';
                }

                // Detection KPIs from /history/statistics
                if (statsRes?.ok) {
                    const stats = await statsRes.json();
                    document.getElementById('statusHistoryCount').textContent = stats.total_patterns || '0';
                    document.getElementById('statusBullish').textContent = stats.by_direction?.bullish || '0';
                    document.getElementById('statusBearish').textContent = stats.by_direction?.bearish || '0';

                    // Scan status from statistics
                    const scanStatus = document.getElementById('statusScanStatus');
                    const scanText = document.getElementById('statusScanText');
                    if (stats.scan_running) {
                        scanStatus.className = 'scan-status running';
                        scanText.textContent = 'L√§uft';
                    } else {
                        scanStatus.className = 'scan-status stopped';
                        scanText.textContent = 'Gestoppt';
                    }
                }

                // Training KPIs
                if (trainInfoRes?.ok) {
                    const trainInfo = await trainInfoRes.json();
                    document.getElementById('statusTrainBadge').textContent = 'Online';
                    document.getElementById('statusTrainBadge').style.background = 'rgba(76, 175, 80, 0.2)';
                    document.getElementById('statusTrainBadge').style.color = '#81c784';
                    document.getElementById('statusTrainJobs').textContent = trainInfo.jobs?.total || '0';
                } else {
                    document.getElementById('statusTrainBadge').textContent = 'Offline';
                    document.getElementById('statusTrainBadge').style.background = 'rgba(244, 67, 54, 0.2)';
                    document.getElementById('statusTrainBadge').style.color = '#e57373';
                }

                if (feedbackRes?.ok) {
                    const feedback = await feedbackRes.json();
                    document.getElementById('statusFeedbackTotal').textContent = feedback.total || '0';
                    document.getElementById('statusFeedbackConfirmed').textContent = feedback.confirmed || '0';
                    document.getElementById('statusFeedbackCorrected').textContent = feedback.corrected || '0';
                }

                // Re-Validation KPIs
                if (revalRes?.ok) {
                    const reval = await revalRes.json();
                    document.getElementById('statusPendingReval').textContent = reval.pending_revalidation || '0';
                    document.getElementById('statusRevalidated').textContent = reval.revalidated || '0';
                    document.getElementById('statusImprovementRate').textContent = `${reval.improvement_rate || 0}%`;
                }

            } catch (error) {
                console.error('Failed to load status dashboard:', error);
                document.getElementById('statusServiceBadge').textContent = 'Fehler';
                document.getElementById('statusServiceBadge').style.background = 'rgba(244, 67, 54, 0.2)';
                document.getElementById('statusServiceBadge').style.color = '#e57373';
            }
        }

        // === Tab Switching ===
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(`tab-${tabName}`).classList.add('active');

            // Load data based on tab
            if (tabName === 'status') {
                loadStatusDashboard();
                loadPatternTypes();

                // Stop auto-refresh
                if (trainingRefreshInterval) {
                    clearInterval(trainingRefreshInterval);
                    trainingRefreshInterval = null;
                }
            } else if (tabName === 'detection') {
                loadServiceInfo();
                initHistoryFilters();
                loadPatternHistory();

                // Stop auto-refresh
                if (trainingRefreshInterval) {
                    clearInterval(trainingRefreshInterval);
                    trainingRefreshInterval = null;
                }
            } else if (tabName === 'training') {
                loadTrainingServiceInfo();
                loadFeedbackStats();
                loadTrainingStatus();
                loadTrainingJobs();

                // Start auto-refresh for training status
                if (!trainingRefreshInterval) {
                    trainingRefreshInterval = setInterval(loadTrainingStatus, 5000);
                }
            } else if (tabName === 'revalidation') {
                loadRevalidationData();

                // Stop training auto-refresh
                if (trainingRefreshInterval) {
                    clearInterval(trainingRefreshInterval);
                    trainingRefreshInterval = null;
                }
            } else if (tabName === 'ruleoptimizer') {
                loadCurrentParams();
                loadParamHistory();
                loadBackups();

                // Stop training auto-refresh
                if (trainingRefreshInterval) {
                    clearInterval(trainingRefreshInterval);
                    trainingRefreshInterval = null;
                }
            } else if (tabName === 'claudeqa') {
                loadClaudeStatus();
                loadAutoOptStatus();
                loadClaudeHistory();
                loadProblematicPatterns();
                loadRecentPatternsForPreview();
                loadFeedbackLoopData();

                // Stop training auto-refresh
                if (trainingRefreshInterval) {
                    clearInterval(trainingRefreshInterval);
                    trainingRefreshInterval = null;
                }
            } else {
                // Stop auto-refresh when leaving status tab
                if (trainingRefreshInterval) {
                    clearInterval(trainingRefreshInterval);
                    trainingRefreshInterval = null;
                }
            }
        }

        // === Pattern History Functions ===

        // Initialize filter dropdowns (preserves current values)
        async function initHistoryFilters() {
            try {
                // Save current filter values
                const currentSymbol = document.getElementById('historyFilterSymbol')?.value || '';
                const currentPattern = document.getElementById('historyFilterPattern')?.value || '';

                // Load symbols
                const symbolsRes = await fetch(`${DATA_API}/managed-symbols`);
                const symbols = await symbolsRes.json();
                const symbolSelect = document.getElementById('historyFilterSymbol');
                const favorites = symbols.filter(s => s.is_favorite);

                symbolSelect.innerHTML = '<option value="">Alle Symbole</option>' +
                    favorites.map(s => `<option value="${s.symbol}">${s.symbol}</option>`).join('');

                // Restore symbol selection
                if (currentSymbol) symbolSelect.value = currentSymbol;

                // Load pattern types
                const patternsRes = await fetch(`${CANDLESTICK_API}/patterns`);
                const patternsData = await patternsRes.json();
                const patternSelect = document.getElementById('historyFilterPattern');

                const allPatterns = [
                    ...(patternsData.categories?.reversal || []),
                    ...(patternsData.categories?.continuation || []),
                    ...(patternsData.categories?.indecision || [])
                ];

                patternSelect.innerHTML = '<option value="">Alle Patterns</option>' +
                    allPatterns.map(p => `<option value="${p.type}">${formatPatternType(p.type)}</option>`).join('');

                // Restore pattern selection
                if (currentPattern) patternSelect.value = currentPattern;

            } catch (error) {
                console.error('Failed to init history filters:', error);
            }
        }

        // Reset all history filters to default
        function resetHistoryFilters() {
            document.getElementById('historyFilterSymbol').value = '';
            document.getElementById('historyFilterPattern').value = '';
            document.getElementById('historyFilterDirection').value = '';
            document.getElementById('historyFilterTimeframe').value = '';
            document.getElementById('historyFilterConfidence').value = '0';
            document.getElementById('historyFilterStatus').value = '';
            document.getElementById('historyFilterDateFrom').value = '';
            document.getElementById('historyFilterDateTo').value = '';
            loadPatternHistory(1);
        }

        // Store ALL filtered patterns for modal navigation (not just current page)
        let allFilteredPatterns = [];

        // Store patterns for current page display
        let loadedPatterns = [];

        // Store feedback data for timeline display - grouped by pattern ID
        // Each entry can have multiple feedbacks (initial + revalidations)
        let patternFeedbackMap = {};

        // Load feedback data for timeline display
        async function loadFeedbackData() {
            try {
                const res = await fetch(`${CANDLESTICK_API}/feedback?limit=1000`);
                const data = await res.json();

                // Create map by pattern_id - group all feedbacks for the same pattern
                patternFeedbackMap = {};
                (data.feedback || []).forEach(fb => {
                    const id = fb.id;
                    if (!patternFeedbackMap[id]) {
                        // First feedback for this pattern
                        patternFeedbackMap[id] = {
                            ...fb,
                            feedbackHistory: []
                        };
                    }

                    // Build feedback history entry
                    const historyEntry = {
                        type: fb.feedback_type,
                        timestamp: fb.feedback_timestamp,
                        originalPattern: fb.original_pattern,
                        correctedPattern: fb.corrected_pattern
                    };

                    // Add revalidation info if present
                    if (fb.revalidated) {
                        historyEntry.revalidated = true;
                        historyEntry.revalidationResult = fb.revalidation_result;
                        historyEntry.revalidationTimestamp = fb.revalidation_timestamp;
                        historyEntry.revalidationNotes = fb.revalidation_notes;
                        historyEntry.revalidationCorrectedPattern = fb.revalidation_corrected_pattern;
                    }

                    // Add historical revalidations if present
                    if (fb.revalidation_history && fb.revalidation_history.length > 0) {
                        historyEntry.previousRevalidations = fb.revalidation_history;
                    }

                    patternFeedbackMap[id].feedbackHistory.push(historyEntry);

                    // Update the main entry with latest data
                    patternFeedbackMap[id].feedback_type = fb.feedback_type;
                    patternFeedbackMap[id].corrected_pattern = fb.corrected_pattern;
                    patternFeedbackMap[id].revalidated = fb.revalidated;
                    patternFeedbackMap[id].revalidation_result = fb.revalidation_result;
                });
            } catch (error) {
                console.error('Failed to load feedback data:', error);
            }
        }

        // Format feedback type for display
        function formatFeedbackType(type) {
            const typeMap = {
                'confirmed': { icon: '‚úì', label: 'Best√§tigt', class: 'confirmed' },
                'corrected': { icon: '‚úé', label: 'Korrigiert', class: 'corrected' },
                'rejected': { icon: '‚úó', label: 'Abgelehnt', class: 'rejected' }
            };
            return typeMap[type] || { icon: '?', label: type, class: '' };
        }

        // Format revalidation result for display
        function formatRevalidationResult(result) {
            const resultMap = {
                'correct': { icon: '‚úì', label: 'Jetzt korrekt', class: 'confirmed' },
                'now_correct': { icon: '‚úì', label: 'Nicht mehr erkannt', class: 'confirmed' },
                'still_wrong': { icon: '‚úó', label: 'Noch falsch', class: 'rejected' }
            };
            return resultMap[result] || { icon: '?', label: result, class: '' };
        }

        // Render detailed feedback history HTML
        function renderFeedbackHistory(feedback) {
            if (!feedback || !feedback.feedbackHistory || feedback.feedbackHistory.length === 0) {
                return '';
            }

            const historyItems = [];

            feedback.feedbackHistory.forEach(entry => {
                // Initial feedback
                const ft = formatFeedbackType(entry.type);
                const feedbackTime = entry.timestamp ? formatTimestamp(entry.timestamp) : '';

                let detail = '';
                if (entry.type === 'corrected' && entry.correctedPattern) {
                    detail = `${formatPatternType(entry.originalPattern)} <span class="feedback-history-arrow">‚Üí</span> ${formatPatternType(entry.correctedPattern)}`;
                } else if (entry.type === 'rejected') {
                    detail = `${formatPatternType(entry.originalPattern)} <span class="feedback-history-arrow">‚Üí</span> Kein Pattern`;
                }

                historyItems.push(`
                    <div class="feedback-history-item ${entry.type}">
                        <div class="feedback-history-row">
                            <span class="feedback-history-type ${ft.class}">${ft.icon} ${ft.label}</span>
                            <span class="feedback-history-time">${feedbackTime}</span>
                        </div>
                        ${detail ? `<div class="feedback-history-detail">${detail}</div>` : ''}
                    </div>
                `);

                // Add revalidation if present
                if (entry.revalidated) {
                    const rv = formatRevalidationResult(entry.revalidationResult);
                    const revalTime = entry.revalidationTimestamp ? formatTimestamp(entry.revalidationTimestamp) : '';

                    let revalDetail = '';
                    if (entry.revalidationCorrectedPattern) {
                        revalDetail = `Neue Korrektur: ${formatPatternType(entry.revalidationCorrectedPattern)}`;
                    }
                    if (entry.revalidationNotes) {
                        revalDetail = entry.revalidationNotes;
                    }

                    historyItems.push(`
                        <div class="feedback-history-item revalidated">
                            <div class="feedback-history-row">
                                <span class="feedback-history-type revalidated">üîÑ Re-Validierung: ${rv.label}</span>
                                <span class="feedback-history-time">${revalTime}</span>
                            </div>
                            ${revalDetail ? `<div class="feedback-history-detail">${revalDetail}</div>` : ''}
                        </div>
                    `);
                }

                // Add historical revalidations
                if (entry.previousRevalidations) {
                    entry.previousRevalidations.forEach(prevReval => {
                        const prevRv = formatRevalidationResult(prevReval.result);
                        const prevTime = prevReval.timestamp ? formatTimestamp(prevReval.timestamp) : '';

                        historyItems.push(`
                            <div class="feedback-history-item revalidated" style="opacity: 0.7;">
                                <div class="feedback-history-row">
                                    <span class="feedback-history-type revalidated">üîÑ Re-Validierung: ${prevRv.label}</span>
                                    <span class="feedback-history-time">${prevTime}</span>
                                </div>
                                ${prevReval.notes ? `<div class="feedback-history-detail">${prevReval.notes}</div>` : ''}
                            </div>
                        `);
                    });
                }
            });

            return `
                <div class="feedback-history">
                    <div class="feedback-history-title">
                        <span>üìã</span> Feedback-Verlauf (${historyItems.length} Eintr√§ge)
                    </div>
                    ${historyItems.join('')}
                </div>
            `;
        }

        // Load pattern history with filters
        async function loadPatternHistory(page = 1) {
            currentHistoryPage = page;
            const timeline = document.getElementById('patternTimeline');
            timeline.innerHTML = '<div class="loading"><span class="spinner"></span> Lade Patterns...</div>';

            // Get filter values
            const symbol = document.getElementById('historyFilterSymbol')?.value || '';
            const pattern = document.getElementById('historyFilterPattern')?.value || '';
            const direction = document.getElementById('historyFilterDirection')?.value || '';
            const timeframe = document.getElementById('historyFilterTimeframe')?.value || '';
            const minConfidence = parseFloat(document.getElementById('historyFilterConfidence')?.value || '0');
            const feedbackStatus = document.getElementById('historyFilterStatus')?.value || '';
            const dateFrom = document.getElementById('historyFilterDateFrom')?.value || '';
            const dateTo = document.getElementById('historyFilterDateTo')?.value || '';

            try {
                // Load feedback data first (for status display)
                await loadFeedbackData();

                // Build query params - load all patterns for navigation
                const params = new URLSearchParams();
                params.set('limit', '1000');  // Load more for complete navigation
                if (symbol) params.set('symbol', symbol);
                if (timeframe) params.set('timeframe', timeframe);
                if (feedbackStatus) params.set('feedback_status', feedbackStatus);
                if (dateFrom) params.set('date_from', dateFrom);
                if (dateTo) params.set('date_to', dateTo);

                const res = await fetch(`${CANDLESTICK_API}/history?${params}`);
                let data = await res.json();
                let patterns = data.patterns || [];

                // Client-side filtering
                if (pattern) {
                    patterns = patterns.filter(p => p.pattern_type === pattern);
                }
                if (direction) {
                    patterns = patterns.filter(p => p.direction === direction);
                }
                if (minConfidence > 0) {
                    patterns = patterns.filter(p => (p.confidence || 0) >= minConfidence);
                }

                // Remove duplicates (same pattern_type, symbol, timestamp)
                // Keep the one with highest confidence
                const uniqueMap = new Map();
                patterns.forEach(p => {
                    const key = `${p.pattern_type}|${p.symbol}|${p.timestamp}`;
                    const existing = uniqueMap.get(key);
                    if (!existing || (p.confidence || 0) > (existing.confidence || 0)) {
                        uniqueMap.set(key, p);
                    }
                });
                patterns = Array.from(uniqueMap.values());

                // Sort by timestamp descending (newest first)
                patterns.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

                // Store ALL filtered patterns for modal navigation
                allFilteredPatterns = patterns.map((p, idx) => ({ ...p, globalIndex: idx }));

                // Pagination for display
                const totalPatterns = patterns.length;
                const totalPages = Math.ceil(totalPatterns / HISTORY_PAGE_SIZE);
                const startIdx = (page - 1) * HISTORY_PAGE_SIZE;
                const pagePatterns = patterns.slice(startIdx, startIdx + HISTORY_PAGE_SIZE);

                // Store page patterns with global index for modal access
                loadedPatterns = pagePatterns.map((p, idx) => ({ ...p, globalIndex: startIdx + idx }));

                // Update pagination
                updateHistoryPagination(page, totalPages, totalPatterns);

                if (pagePatterns.length === 0) {
                    timeline.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">üìä</div>
                            <p>Keine Patterns gefunden</p>
                            <p style="font-size: 0.85rem; margin-top: 0.5rem;">Passe die Filter an oder warte auf neue Erkennungen</p>
                        </div>
                    `;
                    return;
                }

                // Group patterns by date
                const groupedPatterns = groupPatternsByDate(pagePatterns);

                // Render timeline
                timeline.innerHTML = renderTimeline(groupedPatterns);

            } catch (error) {
                console.error('Failed to load pattern history:', error);
                timeline.innerHTML = '<div class="empty-state"><p style="color: #e57373;">Fehler beim Laden der History</p></div>';
            }
        }

        // Group patterns by date
        function groupPatternsByDate(patterns) {
            const groups = {};
            patterns.forEach((p, idx) => {
                const date = new Date(p.timestamp);
                const dateKey = date.toLocaleDateString('de-CH', { weekday: 'long', day: '2-digit', month: 'long', year: 'numeric' });
                if (!groups[dateKey]) {
                    groups[dateKey] = [];
                }
                groups[dateKey].push({ ...p, index: idx });
            });
            return groups;
        }

        // Render the full timeline
        function renderTimeline(groupedPatterns) {
            let html = '';
            for (const [dateKey, patterns] of Object.entries(groupedPatterns)) {
                html += `<div class="timeline-date-group">`;
                html += `<div class="timeline-date-header">${dateKey}</div>`;
                patterns.forEach(p => {
                    html += renderTimelineItem(p);
                });
                html += `</div>`;
            }
            return html;
        }

        // Render a single timeline item with detailed feedback info
        function renderTimelineItem(pattern) {
            const time = new Date(pattern.timestamp).toLocaleTimeString('de-CH', { hour: '2-digit', minute: '2-digit' });
            const confidencePercent = ((pattern.confidence || 0) * 100).toFixed(0);
            const directionClass = pattern.direction || 'neutral';

            // Check for feedback status
            const feedback = patternFeedbackMap[pattern.id];
            let feedbackBadge = '';
            let feedbackSummary = '';

            if (feedback) {
                const feedbackType = feedback.feedback_type;
                const ft = formatFeedbackType(feedbackType);

                // Count total feedback entries (initial + revalidations)
                let totalEntries = 1;
                if (feedback.feedbackHistory) {
                    feedback.feedbackHistory.forEach(h => {
                        if (h.revalidated) totalEntries++;
                        if (h.previousRevalidations) totalEntries += h.previousRevalidations.length;
                    });
                }

                // Show revalidation status if applicable
                let revalIcon = '';
                if (feedback.revalidated) {
                    const rv = formatRevalidationResult(feedback.revalidation_result);
                    revalIcon = `<span title="Re-Validierung: ${rv.label}" style="margin-left: 3px;">üîÑ</span>`;
                }

                // Build detailed label
                let label = ft.label;
                if (feedbackType === 'corrected' && feedback.corrected_pattern) {
                    label = `‚Üí ${formatPatternType(feedback.corrected_pattern)}`;
                }

                // Badge with entry count if multiple
                const countBadge = totalEntries > 1 ? `<span class="feedback-count-badge">${totalEntries}</span>` : '';

                feedbackBadge = `
                    <span class="feedback-badge-detailed ${feedbackType}"
                          title="Klicken f√ºr Details"
                          onclick="event.stopPropagation(); toggleFeedbackDetails('${pattern.id}')">
                        <span>${ft.icon}</span>
                        <span>${label}</span>
                        ${revalIcon}
                        ${countBadge}
                    </span>
                `;

                // Build detailed feedback summary (hidden by default)
                const feedbackTime = feedback.feedback_timestamp ? formatTimestamp(feedback.feedback_timestamp) : '';
                feedbackSummary = `
                    <div id="feedback-details-${pattern.id}" class="feedback-history" style="display: none; margin-top: 0.5rem;">
                        <div class="feedback-history-title">
                            <span>üìã</span> Feedback-Verlauf
                        </div>
                        <div class="feedback-history-item ${feedbackType}">
                            <div class="feedback-history-row">
                                <span class="feedback-history-type ${ft.class}">${ft.icon} ${ft.label}</span>
                                <span class="feedback-history-time">${feedbackTime}</span>
                            </div>
                            ${feedbackType === 'corrected' && feedback.corrected_pattern ?
                                `<div class="feedback-history-detail">${formatPatternType(feedback.original_pattern)} <span class="feedback-history-arrow">‚Üí</span> ${formatPatternType(feedback.corrected_pattern)}</div>` : ''}
                            ${feedbackType === 'rejected' ?
                                `<div class="feedback-history-detail">${formatPatternType(feedback.original_pattern)} <span class="feedback-history-arrow">‚Üí</span> Kein Pattern</div>` : ''}
                        </div>
                        ${feedback.revalidated ? `
                            <div class="feedback-history-item revalidated">
                                <div class="feedback-history-row">
                                    <span class="feedback-history-type revalidated">üîÑ Re-Validierung: ${formatRevalidationResult(feedback.revalidation_result).label}</span>
                                    <span class="feedback-history-time">${feedback.revalidation_timestamp ? formatTimestamp(feedback.revalidation_timestamp) : ''}</span>
                                </div>
                                ${feedback.revalidation_notes ? `<div class="feedback-history-detail">${feedback.revalidation_notes}</div>` : ''}
                            </div>
                        ` : ''}
                        ${feedback.revalidation_history ? feedback.revalidation_history.map(h => `
                            <div class="feedback-history-item revalidated" style="opacity: 0.7;">
                                <div class="feedback-history-row">
                                    <span class="feedback-history-type revalidated">üîÑ ${formatRevalidationResult(h.result).label}</span>
                                    <span class="feedback-history-time">${h.timestamp ? formatTimestamp(h.timestamp) : ''}</span>
                                </div>
                                ${h.notes ? `<div class="feedback-history-detail">${h.notes}</div>` : ''}
                            </div>
                        `).join('') : ''}
                    </div>
                `;
            }

            // Build status display (simplified version for timeline row)
            let statusBadge = '<span class="timeline-status-badge pending">‚Äî</span>';
            if (feedback) {
                const feedbackType = feedback.feedback_type;
                const ft = formatFeedbackType(feedbackType);
                statusBadge = `<span class="timeline-status-badge ${feedbackType}" title="${ft.label}">${ft.icon}</span>`;
            }

            return `
                <div class="timeline-item ${directionClass}">
                    <span class="timeline-time">${time}</span>
                    <div class="timeline-content" onclick="openPatternModal(${pattern.index})">
                        <span class="timeline-pattern-name">${formatPatternType(pattern.pattern_type)}</span>
                        <span class="timeline-symbol">${pattern.symbol}</span>
                        <span class="timeline-direction ${directionClass}">${pattern.direction}</span>
                        <span class="timeline-timeframe">${pattern.timeframe || '-'}</span>
                        <span class="timeline-confidence">${confidencePercent}%</span>
                        <span class="timeline-status">${feedbackBadge || statusBadge}</span>
                        <span class="timeline-arrow">‚Ä∫</span>
                    </div>
                    ${feedbackSummary}
                </div>
            `;
        }

        // Toggle feedback details visibility
        function toggleFeedbackDetails(patternId) {
            const detailsEl = document.getElementById(`feedback-details-${patternId}`);
            if (detailsEl) {
                detailsEl.style.display = detailsEl.style.display === 'none' ? 'block' : 'none';
            }
        }

        // Current modal pattern for corrections
        let currentModalPattern = null;

        // Reference pattern examples (synthetic ideal patterns)
        // Format: OHLC data matching the visual examples from Pattern Detection
        const PATTERN_REFERENCES = {
            // === Reversal Bullish ===
            'hammer': [
                { open: 102, high: 103, low: 98, close: 99 },    // Vorherige rote Kerze (Abw√§rtstrend)
                { open: 99, high: 100, low: 93, close: 99.5 }    // Hammer: kleiner Body oben, langer unterer Docht
            ],
            'inverted_hammer': [
                { open: 102, high: 103, low: 98, close: 99 },    // Vorherige rote Kerze
                { open: 98, high: 105, low: 97, close: 99 }      // Invertierter Hammer: langer oberer Docht
            ],
            'bullish_engulfing': [
                { open: 104, high: 105, low: 100, close: 101 },  // Kleine rote Kerze
                { open: 100, high: 106, low: 99, close: 105 }    // Gro√üe gr√ºne Kerze umschlie√üt
            ],
            'morning_star': [
                { open: 106, high: 107, low: 100, close: 101 },  // Lange rote Kerze
                { open: 101, high: 102, low: 100, close: 101 },  // Kleiner Body/Doji
                { open: 101, high: 108, low: 100, close: 107 }   // Lange gr√ºne Kerze
            ],
            'piercing_line': [
                { open: 106, high: 107, low: 100, close: 101 },  // Rote Kerze
                { open: 99, high: 105, low: 98, close: 104 }     // Gr√ºne Kerze schlie√üt √ºber 50%
            ],
            'dragonfly_doji': [
                { open: 102, high: 103, low: 98, close: 99 },    // Vorherige Kerze
                { open: 100, high: 100.5, low: 93, close: 100 }  // Dragonfly: Body oben, langer unterer Docht
            ],

            // === Reversal Bearish ===
            'hanging_man': [
                { open: 96, high: 99, low: 95, close: 98 },      // 1. gr√ºne Kerze (Aufw√§rtstrend)
                { open: 98, high: 101, low: 97, close: 100 },    // 2. gr√ºne Kerze (Aufw√§rtstrend)
                { open: 100, high: 103, low: 99, close: 102 },   // 3. gr√ºne Kerze (Aufw√§rtstrend)
                { open: 103, high: 104, low: 95, close: 102 }    // Hanging Man: kleiner roter Body oben, langer unterer Docht
            ],
            'shooting_star': [
                { open: 96, high: 99, low: 95, close: 98 },      // 1. gr√ºne Kerze (Aufw√§rtstrend)
                { open: 98, high: 101, low: 97, close: 100 },    // 2. gr√ºne Kerze (Aufw√§rtstrend)
                { open: 100, high: 103, low: 99, close: 102 },   // 3. gr√ºne Kerze (Aufw√§rtstrend)
                { open: 103, high: 111, low: 102, close: 104 }   // Shooting Star: kleiner Body unten, langer oberer Docht
            ],
            'bearish_engulfing': [
                { open: 100, high: 104, low: 99, close: 103 },   // Kleine gr√ºne Kerze
                { open: 104, high: 105, low: 98, close: 99 }     // Gro√üe rote Kerze umschlie√üt
            ],
            'evening_star': [
                { open: 100, high: 107, low: 99, close: 106 },   // Lange gr√ºne Kerze
                { open: 106, high: 107, low: 105, close: 106 },  // Kleiner Body/Doji
                { open: 106, high: 107, low: 100, close: 101 }   // Lange rote Kerze
            ],
            'dark_cloud_cover': [
                { open: 100, high: 106, low: 99, close: 105 },   // Gr√ºne Kerze
                { open: 107, high: 108, low: 101, close: 102 }   // Rote Kerze √∂ffnet √ºber, schlie√üt unter 50%
            ],
            'gravestone_doji': [
                { open: 98, high: 102, low: 97, close: 101 },    // Vorherige Kerze
                { open: 102, high: 109, low: 102, close: 102 }   // Gravestone: Body unten, langer oberer Docht
            ],

            // === Continuation ===
            'three_white_soldiers': [
                { open: 100, high: 104, low: 99, close: 103 },   // 1. gr√ºne Kerze
                { open: 103, high: 107, low: 102, close: 106 },  // 2. gr√ºne Kerze
                { open: 106, high: 110, low: 105, close: 109 }   // 3. gr√ºne Kerze
            ],
            'three_black_crows': [
                { open: 109, high: 110, low: 105, close: 106 },  // 1. rote Kerze
                { open: 106, high: 107, low: 102, close: 103 },  // 2. rote Kerze
                { open: 103, high: 104, low: 99, close: 100 }    // 3. rote Kerze
            ],
            'rising_three_methods': [
                { open: 100, high: 106, low: 99, close: 105 },   // Gro√üe gr√ºne
                { open: 104, high: 105, low: 102, close: 103 },  // Kleine rote
                { open: 103, high: 104, low: 101, close: 102 },  // Kleine rote
                { open: 102, high: 108, low: 101, close: 107 }   // Gro√üe gr√ºne
            ],
            'falling_three_methods': [
                { open: 107, high: 108, low: 101, close: 102 },  // Gro√üe rote
                { open: 103, high: 105, low: 102, close: 104 },  // Kleine gr√ºne
                { open: 104, high: 106, low: 103, close: 105 },  // Kleine gr√ºne
                { open: 105, high: 106, low: 99, close: 100 }    // Gro√üe rote
            ],

            // === Indecision ===
            'doji': [
                { open: 101, high: 103, low: 99, close: 100 },   // Vorherige Kerze
                { open: 100, high: 104, low: 96, close: 100 }    // Doji: Open ‚âà Close
            ],
            'spinning_top': [
                { open: 101, high: 103, low: 99, close: 100 },   // Vorherige Kerze
                { open: 100, high: 105, low: 95, close: 102 }    // Spinning Top: kleiner Body, lange Dochte
            ],
            'bullish_harami': [
                { open: 106, high: 107, low: 99, close: 100 },   // Gro√üe rote Kerze
                { open: 101, high: 103, low: 100, close: 102 }   // Kleine gr√ºne Kerze innerhalb
            ],
            'bearish_harami': [
                { open: 100, high: 107, low: 99, close: 106 },   // Gro√üe gr√ºne Kerze
                { open: 105, high: 106, low: 103, close: 104 }   // Kleine rote Kerze innerhalb
            ],
            'harami_cross': [
                { open: 106, high: 107, low: 99, close: 100 },   // Gro√üe Kerze
                { open: 103, high: 105, low: 101, close: 103 }   // Doji innerhalb
            ],
            'inside_bar': [
                { open: 106, high: 108, low: 98, close: 100 },   // Gro√üe Mutterkerze
                { open: 102, high: 105, low: 100, close: 103 }   // Kleinere Kerze komplett innerhalb
            ],

            // === Three Inside Patterns ===
            'three_inside_up': [
                { open: 108, high: 109, low: 102, close: 103 },  // 1. Gro√üe bearish Kerze (Abw√§rtstrend)
                { open: 104, high: 106, low: 103, close: 105 },  // 2. Kleine bullish Harami innerhalb
                { open: 105, high: 110, low: 104, close: 109 }   // 3. Bullish Best√§tigung √ºber Open der 1.
            ],
            'three_inside_down': [
                { open: 100, high: 106, low: 99, close: 105 },   // 1. Gro√üe bullish Kerze (Aufw√§rtstrend)
                { open: 104, high: 105, low: 102, close: 103 },  // 2. Kleine bearish Harami innerhalb
                { open: 103, high: 104, low: 97, close: 98 }     // 3. Bearish Best√§tigung unter Open der 1.
            ],

            // === Abandoned Baby ===
            'bullish_abandoned_baby': [
                { open: 106, high: 107, low: 100, close: 101 },  // 1. Gro√üe bearish Kerze
                { open: 98, high: 99, low: 97, close: 98 },      // 2. Doji mit Gap down (Island)
                { open: 100, high: 108, low: 99, close: 107 }    // 3. Gro√üe bullish mit Gap up
            ],
            'bearish_abandoned_baby': [
                { open: 100, high: 107, low: 99, close: 106 },   // 1. Gro√üe bullish Kerze
                { open: 109, high: 110, low: 108, close: 109 },  // 2. Doji mit Gap up (Island)
                { open: 107, high: 108, low: 100, close: 101 }   // 3. Gro√üe bearish mit Gap down
            ],

            // === Tower Patterns ===
            'tower_bottom': [
                { open: 106, high: 107, low: 100, close: 101 },  // 1. Gro√üe bearish
                { open: 101, high: 102, low: 99, close: 100 },   // 2. Kleine bearish
                { open: 100, high: 101, low: 99, close: 100 },   // 3. Kleine (Konsolidierung)
                { open: 100, high: 102, low: 99, close: 101 },   // 4. Kleine bullish
                { open: 101, high: 108, low: 100, close: 107 }   // 5. Gro√üe bullish
            ],
            'tower_top': [
                { open: 100, high: 107, low: 99, close: 106 },   // 1. Gro√üe bullish
                { open: 106, high: 108, low: 105, close: 107 },  // 2. Kleine bullish
                { open: 107, high: 108, low: 106, close: 107 },  // 3. Kleine (Konsolidierung)
                { open: 107, high: 108, low: 105, close: 106 },  // 4. Kleine bearish
                { open: 106, high: 107, low: 99, close: 100 }    // 5. Gro√üe bearish
            ],

            // === Advance Block ===
            'advance_block': [
                { open: 100, high: 106, low: 99, close: 105 },   // 1. Starke bullish
                { open: 104, high: 109, low: 103, close: 107 },  // 2. Kleinere bullish, l√§ngerer Docht
                { open: 106, high: 112, low: 105, close: 108 }   // 3. Kleinste bullish, l√§ngster Docht
            ],

            // === Island Reversal ===
            'bearish_island': [
                { open: 100, high: 106, low: 99, close: 105 },   // 1. Bullish vor Gap
                { open: 108, high: 111, low: 107, close: 109 },  // 2. Island-Kerze (Gap up)
                { open: 104, high: 105, low: 97, close: 98 }     // 3. Bearish nach Gap down
            ],
            'bullish_island': [
                { open: 106, high: 107, low: 100, close: 101 },  // 1. Bearish vor Gap
                { open: 98, high: 99, low: 95, close: 97 },      // 2. Island-Kerze (Gap down)
                { open: 102, high: 109, low: 101, close: 108 }   // 3. Bullish nach Gap up
            ],

            // === Belt Hold ===
            'bullish_belt_hold': [
                { open: 104, high: 105, low: 100, close: 101 },  // Vorherige bearish
                { open: 99, high: 106, low: 99, close: 105 }     // Belt Hold: Open = Low, starker K√∂rper
            ],
            'bearish_belt_hold': [
                { open: 100, high: 105, low: 99, close: 104 },   // Vorherige bullish
                { open: 106, high: 106, low: 99, close: 100 }    // Belt Hold: Open = High, starker K√∂rper
            ],

            // === Counterattack ===
            'bullish_counterattack': [
                { open: 106, high: 107, low: 100, close: 101 },  // 1. Gro√üe bearish
                { open: 98, high: 102, low: 97, close: 101 }     // 2. Bullish schlie√üt auf gleichem Level
            ],
            'bearish_counterattack': [
                { open: 100, high: 106, low: 99, close: 105 },   // 1. Gro√üe bullish
                { open: 108, high: 109, low: 104, close: 105 }   // 2. Bearish schlie√üt auf gleichem Level
            ]
        };

        // Open pattern detail modal
        // Current modal index for navigation (global index across all patterns)
        let currentModalIndex = 0;

        async function openPatternModal(index) {
            // Use globalIndex if provided (from timeline click), otherwise use index directly
            const pattern = loadedPatterns[index];
            if (!pattern) return;

            // Use the global index for navigation across all patterns
            const globalIdx = pattern.globalIndex !== undefined ? pattern.globalIndex : index;
            currentModalIndex = globalIdx;

            currentModalPattern = allFilteredPatterns[globalIdx] || pattern;

            // Populate modal fields
            document.getElementById('modalPatternName').textContent = formatPatternType(currentModalPattern.pattern_type);
            const directionEl = document.getElementById('modalDirection');
            directionEl.textContent = currentModalPattern.direction;
            directionEl.className = `timeline-direction ${currentModalPattern.direction}`;

            document.getElementById('modalSymbol').textContent = currentModalPattern.symbol;
            document.getElementById('modalTimeframe').textContent = currentModalPattern.timeframe;
            document.getElementById('modalTimestamp').textContent = formatTimestamp(currentModalPattern.timestamp);
            document.getElementById('modalConfidence').textContent = ((currentModalPattern.confidence || 0) * 100).toFixed(0) + '%';
            document.getElementById('modalDescription').textContent = currentModalPattern.description || currentModalPattern.trading_implication || 'Keine Beschreibung verf√ºgbar';

            // Update navigation counter and buttons
            updateModalNavigation();

            // Populate correction dropdown
            await populateCorrectionDropdown();

            // Reset feedback and Claude Vision result
            document.getElementById('correctionFeedback').style.display = 'none';
            document.getElementById('claudeVisionResult').style.display = 'none';
            document.getElementById('reasonSection').style.display = 'none';
            pendingFeedback = null;

            // Show modal
            document.getElementById('patternModal').classList.add('show');
            document.body.style.overflow = 'hidden';

            // Load charts
            await Promise.all([
                loadModalChart(currentModalPattern),
                loadReferenceChart(currentModalPattern.pattern_type, currentModalPattern.direction)
            ]);
        }

        // Open modal directly by global index (for navigation)
        async function openPatternModalByGlobalIndex(globalIndex) {
            const pattern = allFilteredPatterns[globalIndex];
            if (!pattern) return;

            currentModalIndex = globalIndex;
            currentModalPattern = pattern;

            // Populate modal fields
            document.getElementById('modalPatternName').textContent = formatPatternType(pattern.pattern_type);
            const directionEl = document.getElementById('modalDirection');
            directionEl.textContent = pattern.direction;
            directionEl.className = `timeline-direction ${pattern.direction}`;

            document.getElementById('modalSymbol').textContent = pattern.symbol;
            document.getElementById('modalTimeframe').textContent = pattern.timeframe;
            document.getElementById('modalTimestamp').textContent = formatTimestamp(pattern.timestamp);
            document.getElementById('modalConfidence').textContent = ((pattern.confidence || 0) * 100).toFixed(0) + '%';
            document.getElementById('modalDescription').textContent = pattern.description || pattern.trading_implication || 'Keine Beschreibung verf√ºgbar';

            // Update navigation counter and buttons
            updateModalNavigation();

            // Populate correction dropdown
            await populateCorrectionDropdown();

            // Reset feedback, Claude Vision result, and correction form
            document.getElementById('correctionFeedback').style.display = 'none';
            document.getElementById('claudeVisionResult').style.display = 'none';
            document.getElementById('reasonSection').style.display = 'none';
            document.getElementById('correctionFormSection').style.display = 'none';
            pendingFeedback = null;

            // Reset correction form fields
            document.getElementById('correctionPatternSelect').value = '';
            document.getElementById('reasonCategorySelect').value = '';
            document.getElementById('reasonTextInput').value = '';
            document.getElementById('reasonDescription').textContent = '';

            // Load charts
            await Promise.all([
                loadModalChart(pattern),
                loadReferenceChart(pattern.pattern_type, pattern.direction)
            ]);
        }

        // Update navigation buttons and counter
        function updateModalNavigation() {
            const total = allFilteredPatterns.length;
            const current = currentModalIndex + 1;

            // Update counter
            document.getElementById('modalNavCounter').textContent = `${current} / ${total}`;

            // Update button states
            document.getElementById('modalPrevBtn').disabled = currentModalIndex <= 0;
            document.getElementById('modalNextBtn').disabled = currentModalIndex >= total - 1;
        }

        // Navigate to previous/next pattern (using global index)
        function navigatePattern(direction) {
            const newIndex = currentModalIndex + direction;

            if (newIndex >= 0 && newIndex < allFilteredPatterns.length) {
                openPatternModalByGlobalIndex(newIndex);
            }
        }

        // Keyboard navigation for modal
        document.addEventListener('keydown', function(e) {
            const modal = document.getElementById('patternModal');
            if (!modal.classList.contains('show')) return;

            if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
                e.preventDefault();
                navigatePattern(-1);
            } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
                e.preventDefault();
                navigatePattern(1);
            } else if (e.key === 'Escape') {
                closePatternModal();
            }
        });

        // Cache for reason categories
        let reasonCategoriesCache = null;

        // Populate correction pattern dropdown
        async function populateCorrectionDropdown() {
            const select = document.getElementById('correctionPatternSelect');
            try {
                const res = await fetch(`${CANDLESTICK_API}/patterns`);
                const data = await res.json();
                const patterns = data.patterns || [];

                select.innerHTML = '<option value="">-- Korrektes Pattern w√§hlen --</option>' +
                    '<option value="no_pattern">Kein Pattern</option>' +
                    patterns.map(p => `<option value="${p.type}">${formatPatternType(p.type)} (${p.direction})</option>`).join('');

                // Also populate reason categories for this pattern
                await populateReasonCategories(currentModalPattern?.pattern_type);
            } catch (error) {
                console.error('Failed to load patterns for correction:', error);
            }
        }

        // Populate reason categories dropdown based on pattern type
        async function populateReasonCategories(patternType) {
            const select = document.getElementById('reasonCategorySelect');
            if (!select) return;

            try {
                // Fetch categories filtered for this pattern type
                const url = patternType
                    ? `${CANDLESTICK_API}/feedback/reason-categories?pattern=${patternType}`
                    : `${CANDLESTICK_API}/feedback/reason-categories`;
                const res = await fetch(url);
                const data = await res.json();

                reasonCategoriesCache = data.categories || {};

                select.innerHTML = '<option value="">-- Grund w√§hlen --</option>' +
                    Object.entries(reasonCategoriesCache)
                        .map(([key, info]) => `<option value="${key}">${info.label}</option>`)
                        .join('');

                // Reset description
                document.getElementById('reasonDescription').textContent = '';
                document.getElementById('reasonTextInput').value = '';
            } catch (error) {
                console.error('Failed to load reason categories:', error);
                select.innerHTML = '<option value="">-- Fehler beim Laden --</option>';
            }
        }

        // Handle reason category change - show description
        function onReasonCategoryChange() {
            const select = document.getElementById('reasonCategorySelect');
            const descEl = document.getElementById('reasonDescription');
            const category = select.value;

            if (category && reasonCategoriesCache && reasonCategoriesCache[category]) {
                descEl.textContent = reasonCategoriesCache[category].description || '';
            } else {
                descEl.textContent = '';
            }
        }

        // Show/hide reason section based on feedback type
        function showReasonSection(show) {
            const section = document.getElementById('reasonSection');
            if (section) {
                section.style.display = show ? 'block' : 'none';
            }
        }

        // Load reference chart showing ideal pattern from API
        async function loadReferenceChart(patternType, direction) {
            const container = document.getElementById('modalReferenceContainer');
            if (!container) return;

            console.log(`loadReferenceChart called with patternType: "${patternType}", direction: "${direction}"`);

            // Show loading spinner
            container.innerHTML = '<span class="spinner"></span>';

            // Check cache first
            if (patternImageCache[patternType]) {
                console.log(`Using cached image for ${patternType}`);
                container.innerHTML = `
                    <img src="data:image/png;base64,${patternImageCache[patternType]}" alt="${patternType}" style="max-width: 100%; height: auto; border-radius: 4px;">
                    <div style="font-size: 0.7rem; color: #666; text-align: center; margin-top: 4px;">${formatPatternType(patternType)}</div>
                `;
                return;
            }

            try {
                // Load from API (compact version for modal)
                console.log(`Fetching from API: ${CANDLESTICK_API}/examples/chart/${patternType}?compact=true`);
                const res = await fetch(`${CANDLESTICK_API}/examples/chart/${patternType}?compact=true`);
                if (!res.ok) throw new Error('Failed to load chart');
                const data = await res.json();

                // Validate the API returned the correct pattern
                if (data.pattern_type && data.pattern_type !== patternType) {
                    console.warn(`API returned wrong pattern: requested=${patternType}, got=${data.pattern_type}`);
                }

                // Cache the image using the requested pattern type
                patternImageCache[patternType] = data.image_base64;

                // Display the image with pattern type label for verification
                container.innerHTML = `
                    <img src="data:image/png;base64,${data.image_base64}" alt="${patternType}" style="max-width: 100%; height: auto; border-radius: 4px;">
                    <div style="font-size: 0.7rem; color: #666; text-align: center; margin-top: 4px;">${formatPatternType(patternType)}</div>
                `;
            } catch (error) {
                console.error(`Failed to load reference chart for ${patternType}:`, error);
                // Fallback: show pattern name
                container.innerHTML = `<div style="text-align: center; color: #888; padding: 1rem;">${formatPatternType(patternType)}</div>`;
            }
        }

        // Close pattern detail modal
        function closePatternModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('patternModal').classList.remove('show');
            document.body.style.overflow = '';
            currentModalPattern = null;
            pendingFeedback = null;  // Clear pending feedback
            showReasonSection(false);
        }

        // ==================== Optimization Summary Modal ====================

        async function showOptimizationSummary(progressData) {
            try {
                // Fetch detailed recommendations and samples in parallel
                const [recRes, samplesRes] = await Promise.all([
                    fetch(`${CANDLESTICK_API}/rule-optimizer/recommendations`),
                    fetch(`${CANDLESTICK_API}/rule-optimizer/validated-samples`)
                ]);

                const recData = await recRes.json();
                const samplesData = await samplesRes.json();

                const recommendations = recData.recommendations || [];
                const patternAnalyses = recData.pattern_analyses || {};
                const samples = samplesData.samples || [];

                // Count valid and invalid
                let validCount = 0;
                let invalidCount = 0;
                samples.forEach(s => {
                    if (s.claude_valid === 'valid') validCount++;
                    else if (s.claude_valid === 'invalid') invalidCount++;
                });

                // Update summary stats
                document.getElementById('summaryCollected').textContent = progressData.patterns_collected || 0;
                document.getElementById('summaryValidCount').textContent = validCount;
                document.getElementById('summaryInvalidCount').textContent = invalidCount;
                document.getElementById('summaryRecommendations').textContent = recommendations.length;
                document.getElementById('summaryPatternTypes').textContent = Object.keys(patternAnalyses).length;

                // Build pattern analysis table
                let analysisHtml = '<table style="width: 100%; font-size: 0.85rem; border-collapse: collapse;">';
                analysisHtml += '<thead><tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">';
                analysisHtml += '<th style="text-align: left; padding: 0.4rem;">Pattern</th>';
                analysisHtml += '<th style="text-align: center; padding: 0.4rem;">Samples</th>';
                analysisHtml += '<th style="text-align: center; padding: 0.4rem;">Valide</th>';
                analysisHtml += '<th style="text-align: center; padding: 0.4rem;">Invalide</th>';
                analysisHtml += '<th style="text-align: center; padding: 0.4rem;">Rate</th>';
                analysisHtml += '</tr></thead><tbody>';

                for (const [patternType, analysis] of Object.entries(patternAnalyses)) {
                    const validityRate = analysis.validity_rate || 0;
                    const rateColor = validityRate >= 0.7 ? '#4caf50' : validityRate >= 0.4 ? '#ff9800' : '#f44336';

                    analysisHtml += `<tr style="border-bottom: 1px solid rgba(255,255,255,0.05);">
                        <td style="padding: 0.4rem; color: #64c8ff;">${patternType.replace(/_/g, ' ')}</td>
                        <td style="text-align: center; padding: 0.4rem;">${analysis.total_samples || 0}</td>
                        <td style="text-align: center; padding: 0.4rem; color: #4caf50;">${analysis.valid_count || 0}</td>
                        <td style="text-align: center; padding: 0.4rem; color: #f44336;">${analysis.invalid_count || 0}</td>
                        <td style="text-align: center; padding: 0.4rem; color: ${rateColor};">${(validityRate * 100).toFixed(0)}%</td>
                    </tr>`;
                }

                analysisHtml += '</tbody></table>';

                if (Object.keys(patternAnalyses).length === 0) {
                    analysisHtml = '<div style="color: #888; text-align: center; padding: 1rem;">Keine Pattern-Analyse verf√ºgbar</div>';
                }

                document.getElementById('summaryPatternAnalysis').innerHTML = analysisHtml;

                // Build detailed samples list with images
                let samplesHtml = '';
                if (samples.length > 0) {
                    samples.forEach(sample => {
                        const statusColor = sample.claude_valid === 'valid' ? '#4caf50' :
                                           sample.claude_valid === 'invalid' ? '#f44336' :
                                           sample.claude_valid === 'borderline' ? '#ff9800' : '#888';
                        const statusIcon = sample.claude_valid === 'valid' ? '‚úì' :
                                          sample.claude_valid === 'invalid' ? '‚úó' :
                                          sample.claude_valid === 'borderline' ? '~' : '?';
                        const statusText = sample.claude_valid === 'valid' ? 'Valide' :
                                          sample.claude_valid === 'invalid' ? 'Invalide' :
                                          sample.claude_valid === 'borderline' ? 'Grenzwertig' : 'Fehler';

                        // Build image or placeholder
                        const imageHtml = sample.chart_image
                            ? `<img src="data:image/png;base64,${sample.chart_image}" style="width: 100%; height: 120px; object-fit: contain; background: #1a1a2e; border-radius: 4px;">`
                            : `<div style="width: 100%; height: 120px; background: #1a1a2e; border-radius: 4px; display: flex; align-items: center; justify-content: center; color: #666;">Kein Bild</div>`;

                        // Truncate reasoning
                        const reasoning = sample.claude_reasoning
                            ? (sample.claude_reasoning.length > 120 ? sample.claude_reasoning.substring(0, 120) + '...' : sample.claude_reasoning)
                            : 'Keine Begr√ºndung';

                        samplesHtml += `
                            <div style="background: rgba(255,255,255,0.03); border-radius: 8px; overflow: hidden; border: 1px solid ${statusColor}33;">
                                <!-- Image -->
                                <div style="position: relative;">
                                    ${imageHtml}
                                    <!-- Status Badge -->
                                    <div style="position: absolute; top: 8px; right: 8px; background: ${statusColor}; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem; font-weight: bold;">
                                        ${statusIcon} ${statusText}
                                    </div>
                                </div>
                                <!-- Info -->
                                <div style="padding: 0.8rem;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                                        <span style="color: #64c8ff; font-weight: 600; font-size: 0.9rem;">${sample.pattern_type.replace(/_/g, ' ')}</span>
                                        <span style="color: #888; font-size: 0.75rem;">${sample.symbol} / ${sample.timeframe}</span>
                                    </div>
                                    <!-- Confidence -->
                                    <div style="display: flex; gap: 1rem; margin-bottom: 0.5rem; font-size: 0.8rem;">
                                        <span style="color: #888;">Regel: <span style="color: #ce93d8;">${((sample.rule_confidence || 0) * 100).toFixed(0)}%</span></span>
                                        <span style="color: #888;">Claude: <span style="color: ${statusColor};">${((sample.claude_confidence || 0) * 100).toFixed(0)}%</span></span>
                                    </div>
                                    <!-- Metrics -->
                                    ${sample.body_ratio !== null ? `
                                        <div style="font-size: 0.75rem; color: #666; margin-bottom: 0.5rem;">
                                            Body: ${(sample.body_ratio * 100).toFixed(0)}% |
                                            Upper: ${((sample.upper_shadow_ratio || 0) * 100).toFixed(0)}% |
                                            Lower: ${((sample.lower_shadow_ratio || 0) * 100).toFixed(0)}%
                                        </div>
                                    ` : ''}
                                    <!-- Reasoning -->
                                    <div style="font-size: 0.75rem; color: #aaa; font-style: italic; line-height: 1.3;">
                                        "${reasoning}"
                                    </div>
                                </div>
                            </div>
                        `;
                    });
                } else {
                    samplesHtml = '<div style="color: #888; text-align: center; padding: 2rem;">Keine validierten Samples verf√ºgbar</div>';
                }

                document.getElementById('summarySamplesList').innerHTML = samplesHtml;

                // Build recommendations list
                const recSection = document.getElementById('summaryRecommendationsSection');
                const recList = document.getElementById('summaryRecommendationsList');
                const applyBtn = document.getElementById('summaryApplyBtn');

                if (recommendations.length > 0) {
                    recSection.style.display = 'block';
                    applyBtn.style.display = 'inline-block';

                    let recHtml = '';
                    recommendations.forEach(rec => {
                        const changePercent = rec.current_value !== 0
                            ? ((rec.recommended_value - rec.current_value) / rec.current_value * 100).toFixed(1)
                            : 'N/A';
                        const changeColor = parseFloat(changePercent) > 0 ? '#4caf50' : '#f44336';

                        recHtml += `<div style="display: flex; align-items: center; gap: 0.8rem; padding: 0.5rem 0; border-bottom: 1px solid rgba(255,255,255,0.05);">
                            <span style="color: #64c8ff; min-width: 120px;">${rec.pattern_type}</span>
                            <span style="color: #ce93d8;">${rec.parameter}</span>
                            <span style="color: #888;">‚Üí</span>
                            <span>${rec.current_value}</span>
                            <span style="color: #888;">‚Üí</span>
                            <span style="color: ${changeColor}; font-weight: bold;">${rec.recommended_value}</span>
                            <span style="color: ${changeColor}; font-size: 0.8rem;">(${changePercent}%)</span>
                        </div>`;
                    });

                    recList.innerHTML = recHtml;
                } else {
                    recSection.style.display = 'none';
                    applyBtn.style.display = 'none';
                    recList.innerHTML = '';
                }

                // Show modal
                document.getElementById('optimizationSummaryModal').classList.add('show');
                document.body.style.overflow = 'hidden';

            } catch (error) {
                console.error('Failed to show optimization summary:', error);
                showToast('Optimierung abgeschlossen!', 'success');
            }
        }

        function closeOptimizationSummary(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('optimizationSummaryModal').classList.remove('show');
            document.body.style.overflow = '';
        }

        async function applyAllRecommendationsFromSummary() {
            try {
                // Apply recommendations using existing function
                await applySelectedRecommendations();
                closeOptimizationSummary();
                showToast('Alle Empfehlungen angewendet!', 'success');
            } catch (error) {
                console.error('Failed to apply recommendations:', error);
                showToast('Fehler beim Anwenden der Empfehlungen', 'error');
            }
        }

        // Pending feedback state for two-step submission
        let pendingFeedback = null;

        // Confirm pattern is correct
        async function confirmPattern() {
            if (!currentModalPattern) return;
            // Hide reason section for confirmations (no reason needed)
            showReasonSection(false);
            pendingFeedback = null;
            await submitPatternFeedback(currentModalPattern, 'confirmed', currentModalPattern.pattern_type);
        }

        // === NEW OPTIMIZED WORKFLOW FUNCTIONS ===

        // Confirm pattern and automatically navigate to next
        async function confirmPatternAndNext() {
            if (!currentModalPattern) return;

            // Hide correction form if visible
            hideCorrectionForm();

            // Submit confirmation
            await submitPatternFeedback(currentModalPattern, 'confirmed', currentModalPattern.pattern_type);

            // Auto-navigate to next pattern after short delay
            setTimeout(() => {
                if (currentModalIndex < allFilteredPatterns.length - 1) {
                    navigatePattern(1);
                } else {
                    showCorrectionFeedback('Letztes Pattern erreicht.', 'info');
                }
            }, 300);
        }

        // Show correction form for "Falsches Pattern"
        function showCorrectionForm() {
            const formSection = document.getElementById('correctionFormSection');
            const patternRow = document.getElementById('patternSelectionRow');
            const formTitle = document.getElementById('correctionFormTitle');

            // Show pattern selection for corrections
            if (patternRow) patternRow.style.display = 'flex';
            if (formTitle) formTitle.textContent = 'Korrektur: Welches Pattern ist korrekt?';

            // Show the form
            formSection.style.display = 'block';

            // Populate dropdowns
            populateCorrectionDropdown();
        }

        // Show form for "Kein Pattern"
        function showNoPatternForm() {
            const formSection = document.getElementById('correctionFormSection');
            const patternRow = document.getElementById('patternSelectionRow');
            const formTitle = document.getElementById('correctionFormTitle');

            // Hide pattern selection - we already know it's "no pattern"
            if (patternRow) patternRow.style.display = 'none';
            if (formTitle) formTitle.textContent = 'Ablehnung: Warum ist dies kein valides Pattern?';

            // Show the form
            formSection.style.display = 'block';

            // Pre-select "no_pattern" in the hidden dropdown
            const correctionSelect = document.getElementById('correctionPatternSelect');
            if (correctionSelect) correctionSelect.value = 'no_pattern';

            // Populate reason categories
            populateReasonCategories(currentModalPattern?.pattern_type);
        }

        // Submit correction/rejection and navigate to next
        async function submitCorrectionAndNext() {
            if (!currentModalPattern) return;

            const correctedPattern = document.getElementById('correctionPatternSelect').value;
            const feedbackType = correctedPattern === 'no_pattern' ? 'rejected' : 'corrected';

            // Validate selection for corrections
            if (feedbackType === 'corrected' && !correctedPattern) {
                showCorrectionFeedback('Bitte w√§hlen Sie das korrekte Pattern aus.', 'warning');
                return;
            }

            // Submit feedback
            await submitPatternFeedback(currentModalPattern, feedbackType, correctedPattern || 'no_pattern');

            // Hide form and reset
            hideCorrectionForm();

            // Auto-navigate to next pattern after short delay
            setTimeout(() => {
                if (currentModalIndex < allFilteredPatterns.length - 1) {
                    navigatePattern(1);
                } else {
                    showCorrectionFeedback('Letztes Pattern erreicht.', 'info');
                }
            }, 300);
        }

        // Hide correction form and reset fields
        function hideCorrectionForm() {
            const formSection = document.getElementById('correctionFormSection');
            formSection.style.display = 'none';

            // Reset fields
            document.getElementById('correctionPatternSelect').value = '';
            document.getElementById('reasonCategorySelect').value = '';
            document.getElementById('reasonTextInput').value = '';
            document.getElementById('reasonDescription').textContent = '';

            // Clear any pending feedback
            pendingFeedback = null;
        }

        // Submit correction with different pattern
        async function submitCorrection() {
            if (!currentModalPattern) return;
            const correctedPattern = document.getElementById('correctionPatternSelect').value;
            if (!correctedPattern) {
                showCorrectionFeedback('Bitte w√§hlen Sie das korrekte Pattern aus.', 'warning');
                return;
            }
            // Store pending feedback and show reason section
            pendingFeedback = {
                pattern: currentModalPattern,
                feedbackType: 'corrected',
                correctedPattern: correctedPattern
            };
            document.getElementById('reasonSectionTitle').textContent =
                `Begr√ºndung f√ºr Korrektur zu "${formatPatternType(correctedPattern)}"`;
            showReasonSection(true);
            // Populate reason categories for this pattern type
            await populateReasonCategories(currentModalPattern.pattern_type);
        }

        // Mark as no pattern (false positive)
        async function markAsNoPattern() {
            if (!currentModalPattern) return;
            // Store pending feedback and show reason section
            pendingFeedback = {
                pattern: currentModalPattern,
                feedbackType: 'rejected',
                correctedPattern: 'no_pattern'
            };
            document.getElementById('reasonSectionTitle').textContent = 'Begr√ºndung f√ºr Ablehnung';
            showReasonSection(true);
            // Populate reason categories for this pattern type
            await populateReasonCategories(currentModalPattern.pattern_type);
        }

        // Validate pattern with Claude Vision API
        async function validateWithClaudeVision() {
            if (!currentModalPattern) {
                showCorrectionFeedback('Kein Pattern ausgew√§hlt.', 'warning');
                return;
            }

            const btn = document.getElementById('btnClaudeVision');
            const resultDiv = document.getElementById('claudeVisionResult');
            const originalText = btn.innerHTML;

            try {
                // Show loading state
                btn.disabled = true;
                btn.innerHTML = '‚è≥ Analysiere...';
                resultDiv.style.display = 'none';

                // Get pattern ID
                const patternId = currentModalPattern.id ||
                    `${currentModalPattern.symbol}_${currentModalPattern.timestamp}_${currentModalPattern.pattern_type}`;

                // Call Claude Vision API
                const response = await fetch(`${CANDLESTICK_API}/claude/validate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        pattern_id: patternId,
                        force: true  // Always get fresh validation
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.detail || `HTTP ${response.status}`);
                }

                const data = await response.json();
                const validation = data.validation || {};

                // Display result
                displayClaudeVisionResult(validation);

                // Auto-fill correction fields if pattern is invalid
                if (!validation.claude_agrees) {
                    await autoFillCorrectionFromClaude(validation);
                }

            } catch (error) {
                console.error('Claude Vision validation error:', error);
                resultDiv.style.display = 'block';
                resultDiv.style.background = 'rgba(244, 67, 54, 0.15)';
                resultDiv.style.border = '1px solid rgba(244, 67, 54, 0.3)';
                resultDiv.innerHTML = `
                    <div style="color: #f44336; font-weight: 600; margin-bottom: 0.25rem;">
                        ‚ùå Claude Vision Fehler
                    </div>
                    <div style="color: #ccc; font-size: 0.85rem;">
                        ${error.message || 'Unbekannter Fehler'}
                    </div>
                `;
            } finally {
                btn.disabled = false;
                btn.innerHTML = originalText;
            }
        }

        // Display Claude Vision validation result
        function displayClaudeVisionResult(validation) {
            const resultDiv = document.getElementById('claudeVisionResult');
            const agrees = validation.claude_agrees;
            const confidence = validation.claude_confidence || 0;
            const reasoning = validation.claude_reasoning || 'Keine Begr√ºndung verf√ºgbar';
            const suggestedPattern = validation.claude_pattern_type;

            resultDiv.style.display = 'block';

            if (agrees) {
                resultDiv.style.background = 'rgba(76, 175, 80, 0.15)';
                resultDiv.style.border = '1px solid rgba(76, 175, 80, 0.3)';
                resultDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                        <span style="color: #81c784; font-weight: 600;">‚úì Claude best√§tigt das Pattern</span>
                        <span style="background: rgba(76, 175, 80, 0.2); padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.8rem;">
                            ${Math.round(confidence * 100)}% Konfidenz
                        </span>
                    </div>
                    <div style="color: #aaa; font-size: 0.85rem; line-height: 1.4;">
                        ${reasoning}
                    </div>
                `;
            } else {
                resultDiv.style.background = 'rgba(255, 152, 0, 0.15)';
                resultDiv.style.border = '1px solid rgba(255, 152, 0, 0.3)';

                let suggestedHtml = '';
                if (suggestedPattern && suggestedPattern !== 'no_pattern' && suggestedPattern !== 'none') {
                    suggestedHtml = `
                        <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.1);">
                            <span style="color: #888;">Vorschlag:</span>
                            <span style="color: #64c8ff; font-weight: 500;">${formatPatternType(suggestedPattern)}</span>
                        </div>
                    `;
                }

                resultDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                        <span style="color: #ffb74d; font-weight: 600;">‚ö† Claude erkennt ein Problem</span>
                        <span style="background: rgba(255, 152, 0, 0.2); padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.8rem;">
                            ${Math.round(confidence * 100)}% Konfidenz
                        </span>
                    </div>
                    <div style="color: #aaa; font-size: 0.85rem; line-height: 1.4;">
                        ${reasoning}
                    </div>
                    ${suggestedHtml}
                `;
            }
        }

        // Auto-fill correction fields based on Claude's validation
        async function autoFillCorrectionFromClaude(validation) {
            const suggestedPattern = validation.claude_pattern_type;
            const reasoning = validation.claude_reasoning || '';

            // Determine the correction type
            if (!suggestedPattern || suggestedPattern === 'no_pattern' || suggestedPattern === 'none') {
                // Claude says it's not a valid pattern - trigger "Kein Pattern" flow
                showNoPatternForm();

                // Wait for reason categories to be populated, then auto-select
                await populateReasonCategories(currentModalPattern.pattern_type);

                // Small delay to ensure DOM is updated
                setTimeout(() => {
                    autoSelectReasonFromClaude(reasoning);

                    // Update form title to indicate Claude source
                    const formTitle = document.getElementById('correctionFormTitle');
                    if (formTitle) formTitle.textContent = 'Ablehnung (von Claude Vision vorgeschlagen)';
                }, 50);

                showCorrectionFeedback('Claude Vision: Pattern ung√ºltig. Begr√ºndung wurde vorausgef√ºllt.', 'info');
            } else if (suggestedPattern !== currentModalPattern.pattern_type) {
                // Claude suggests a different pattern - show correction form first
                showCorrectionForm();

                // Wait for dropdowns to be populated
                await populateReasonCategories(currentModalPattern.pattern_type);

                // Wait for dropdown to be populated, then select the suggested pattern
                setTimeout(() => {
                    const correctionSelect = document.getElementById('correctionPatternSelect');

                    // Try to find the suggested pattern in the dropdown
                    let found = false;
                    for (let option of correctionSelect.options) {
                        if (option.value.toLowerCase() === suggestedPattern.toLowerCase()) {
                            correctionSelect.value = option.value;
                            found = true;
                            break;
                        }
                    }

                    if (found) {
                        // Update form title to indicate Claude source
                        const formTitle = document.getElementById('correctionFormTitle');
                        if (formTitle) formTitle.textContent = `Korrektur zu "${formatPatternType(correctionSelect.value)}" (von Claude Vision)`;

                        // Auto-select reason from Claude's reasoning
                        autoSelectReasonFromClaude(reasoning);

                        showCorrectionFeedback(`Claude Vision: Korrektur zu "${formatPatternType(suggestedPattern)}" vorgeschlagen.`, 'info');
                    } else {
                        showCorrectionFeedback(`Claude Vision schl√§gt "${formatPatternType(suggestedPattern)}" vor (nicht in Liste).`, 'warning');
                    }
                }, 100);
            }
        }

        // Try to auto-select a reason category based on Claude's reasoning text
        function autoSelectReasonFromClaude(reasoning) {
            const reasonSelect = document.getElementById('reasonCategorySelect');
            const reasonText = document.getElementById('reasonTextInput');
            const lowerReasoning = reasoning.toLowerCase();

            // Mapping of keywords to reason categories (order matters - more specific first)
            const keywordMap = {
                'body_too_large': ['k√∂rper zu gro√ü', 'body too large', 'body is too large', 'gro√üer k√∂rper', 'relatively large body', 'large body', 'body size'],
                'body_too_small': ['k√∂rper zu klein', 'body too small', 'small body', 'kleiner k√∂rper', 'tiny body'],
                'upper_shadow_too_short': ['oberer schatten zu kurz', 'upper shadow too short', 'upper wick too short', 'no upper shadow', 'little upper shadow', 'long upper shadow'],
                'upper_shadow_too_long': ['oberer schatten zu lang', 'upper shadow too long'],
                'lower_shadow_too_short': ['unterer schatten zu kurz', 'lower shadow too short', 'lower wick too short', 'no lower shadow', 'little to no lower shadow', 'little lower shadow'],
                'lower_shadow_too_long': ['unterer schatten zu lang', 'lower shadow too long'],
                'wrong_trend_context': ['after an uptrend', 'after a downtrend', 'trend context', 'uptrend', 'downtrend', 'trendkontext', 'kein aufw√§rtstrend', 'kein abw√§rtstrend', 'appearance after'],
                'not_fully_engulfing': ['engulfing', 'umschlie√üt nicht', 'not fully engulfing', 'does not engulf'],
                'missing_gap': ['gap', 'l√ºcke', 'keine l√ºcke', 'no gap'],
                'false_positive': ['does not meet', 'does not show', 'not a valid', 'false positive', 'kein pattern', 'nicht erkennbar', 'no pattern', 'criteria']
            };

            // Find matching category
            let bestMatch = null;
            for (const [category, keywords] of Object.entries(keywordMap)) {
                for (const keyword of keywords) {
                    if (lowerReasoning.includes(keyword)) {
                        bestMatch = category;
                        break;
                    }
                }
                if (bestMatch) break;
            }

            // Set the reason category if found, otherwise use 'other' as fallback
            if (bestMatch) {
                for (let option of reasonSelect.options) {
                    if (option.value === bestMatch) {
                        reasonSelect.value = bestMatch;
                        onReasonCategoryChange();  // Update description
                        break;
                    }
                }
            } else {
                // No specific match found - select "Anderer Grund" as fallback
                reasonSelect.value = 'other';
                onReasonCategoryChange();
            }

            // Always put Claude's full reasoning in the text input
            reasonText.value = reasoning.substring(0, 500);  // Limit length
        }

        // Submit the pending feedback (called from reason section button)
        async function submitPendingFeedback() {
            if (!pendingFeedback) {
                showCorrectionFeedback('Kein Feedback ausstehend.', 'warning');
                return;
            }
            await submitPatternFeedback(
                pendingFeedback.pattern,
                pendingFeedback.feedbackType,
                pendingFeedback.correctedPattern
            );
            pendingFeedback = null;
        }

        // Cancel pending feedback
        function cancelPendingFeedback() {
            pendingFeedback = null;
            showReasonSection(false);
            // Reset reason fields
            document.getElementById('reasonCategorySelect').value = '';
            document.getElementById('reasonTextInput').value = '';
            document.getElementById('reasonDescription').textContent = '';
            showCorrectionFeedback('Feedback abgebrochen.', 'info');
        }

        // Get reason data from UI
        function getReasonData() {
            const categorySelect = document.getElementById('reasonCategorySelect');
            const textInput = document.getElementById('reasonTextInput');
            return {
                reason_category: categorySelect?.value || null,
                reason_text: textInput?.value?.trim() || null
            };
        }

        // Submit pattern feedback to backend
        async function submitPatternFeedback(pattern, feedbackType, correctedPattern) {
            try {
                // Get reason data for corrections and rejections
                const reasonData = (feedbackType !== 'confirmed') ? getReasonData() : {};

                const payload = {
                    pattern_id: pattern.id || `${pattern.symbol}_${pattern.timestamp}_${pattern.pattern_type}`,
                    original_pattern: pattern.pattern_type,
                    feedback_type: feedbackType,
                    corrected_pattern: correctedPattern,
                    symbol: pattern.symbol,
                    timeframe: pattern.timeframe,
                    timestamp: pattern.timestamp,
                    ohlc_data: pattern.ohlc_data || null,
                    // Begr√ºndungsfelder
                    reason_category: reasonData.reason_category,
                    reason_text: reasonData.reason_text
                };

                const res = await fetch(`${CANDLESTICK_API}/feedback`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (res.ok) {
                    let msg = feedbackType === 'confirmed' ? 'Pattern als korrekt best√§tigt!' :
                                feedbackType === 'rejected' ? 'Als Fehlererkennung markiert.' :
                                `Korrektur zu "${formatPatternType(correctedPattern)}" gespeichert.`;

                    // Add note about reason if provided
                    if (reasonData.reason_category) {
                        const reasonLabel = reasonCategoriesCache?.[reasonData.reason_category]?.label || reasonData.reason_category;
                        msg += ` (Grund: ${reasonLabel})`;
                    }

                    showCorrectionFeedback(msg, 'success');

                    // Hide reason section and reset fields
                    showReasonSection(false);
                    document.getElementById('reasonCategorySelect').value = '';
                    document.getElementById('reasonTextInput').value = '';
                    document.getElementById('reasonDescription').textContent = '';

                    // Update feedback map locally for immediate UI update
                    const patternId = pattern.id || `${pattern.symbol}_${pattern.timestamp}_${pattern.pattern_type}`;
                    patternFeedbackMap[patternId] = {
                        id: patternId,
                        feedback_type: feedbackType,
                        corrected_pattern: correctedPattern,
                        reason_category: reasonData.reason_category,
                        reason_text: reasonData.reason_text
                    };

                    // Refresh timeline to show updated status
                    loadPatternHistory(currentHistoryPage);
                } else {
                    throw new Error('Server error');
                }
            } catch (error) {
                console.error('Failed to submit feedback:', error);
                showCorrectionFeedback('Feedback konnte nicht gespeichert werden.', 'error');
            }
        }

        // Show feedback message
        function showCorrectionFeedback(message, type) {
            const el = document.getElementById('correctionFeedback');
            el.textContent = message;
            el.style.display = 'block';
            el.style.color = type === 'success' ? '#81c784' : type === 'error' ? '#e57373' : '#ffb74d';
        }

        // Parse TwelveData datetime as UTC (they return datetime without timezone suffix)
        function parseTwelveDataTimeUTC(datetime) {
            if (!datetime) return null;
            let dateStr = datetime;
            if (typeof dateStr === 'string' && !dateStr.includes('+') && !dateStr.includes('Z')) {
                dateStr = dateStr.replace(' ', 'T') + 'Z';
            }
            return new Date(dateStr);
        }

        // Load chart for modal
        async function loadModalChart(pattern) {
            const canvas = document.getElementById('modalChart');
            if (!canvas) return;

            try {
                const patternCandleCount = getPatternCandleCount(pattern.pattern_type);

                // PRIORITY 1: Use stored ohlc_context if available (most reliable)
                // This data was saved when the pattern was detected and never changes
                if (pattern.ohlc_context && pattern.ohlc_context.candles && pattern.ohlc_context.candles.length > 0) {
                    console.log(`Using stored ohlc_context for ${pattern.symbol}/${pattern.timeframe} (${pattern.ohlc_context.candles.length} candles)`);

                    // ohlc_context.candles is already in chronological order (oldest first)
                    const formattedCandles = pattern.ohlc_context.candles.map(c => ({
                        datetime: c.datetime,
                        open: parseFloat(c.open),
                        high: parseFloat(c.high),
                        low: parseFloat(c.low),
                        close: parseFloat(c.close)
                    }));

                    // Use the stored highlight indices
                    const highlightStartIdx = pattern.ohlc_context.pattern_start_idx;

                    // Store OHLC data in pattern for feedback submission
                    pattern.ohlc_data = formattedCandles;

                    renderCandlestickChart(canvas, formattedCandles, highlightStartIdx, pattern.direction, pattern.pattern_type, pattern.timeframe);
                    return;
                }

                // PRIORITY 2: Fetch from API (fallback for patterns without stored context)
                console.log(`No stored ohlc_context, fetching from API for ${pattern.symbol}/${pattern.timeframe}`);

                const interval = timeframeToInterval(pattern.timeframe);
                const patternTime = new Date(pattern.timestamp);
                const timeframeTolerance = getTimeframeMinutes(pattern.timeframe) * 60 * 1000;

                // Calculate cache key including pattern timestamp to avoid stale data issues
                const patternTimeBucket = Math.floor(patternTime.getTime() / (timeframeTolerance * 10));
                const cacheKey = `${pattern.symbol}_${interval}_${patternTimeBucket}`;

                let ohlcData;
                let needsFetch = true;

                // Check cache - but verify it contains the pattern timestamp
                if (ohlcCache[cacheKey]) {
                    const cachedData = ohlcCache[cacheKey];
                    if (cachedData && cachedData.length > 0) {
                        const newestTime = parseTwelveDataTimeUTC(cachedData[0].datetime);
                        const oldestTime = parseTwelveDataTimeUTC(cachedData[cachedData.length - 1].datetime);
                        if (patternTime >= oldestTime && patternTime <= newestTime) {
                            ohlcData = cachedData;
                            needsFetch = false;
                            console.log(`Cache hit for ${cacheKey}`);
                        }
                    }
                }

                if (needsFetch) {
                    const contextCandlesAfter = 10;
                    const endTime = new Date(patternTime.getTime() + (contextCandlesAfter * timeframeTolerance));
                    const endDateStr = endTime.toISOString().slice(0, 19).replace('T', ' ');
                    const outputSize = 50;

                    console.log(`Fetching OHLC data for ${pattern.symbol}/${interval} ending at ${endDateStr}`);
                    const res = await fetch(`${DATA_API}/twelvedata/time_series/${pattern.symbol}?interval=${interval}&outputsize=${outputSize}&end_date=${encodeURIComponent(endDateStr)}`);
                    const data = await res.json();
                    ohlcData = data.values || [];
                    ohlcCache[cacheKey] = ohlcData;
                }

                if (!ohlcData || ohlcData.length === 0) {
                    console.error('No OHLC data available');
                    return;
                }

                // Reverse to chronological order
                const chronoData = [...ohlcData].reverse();

                // Find pattern's last candle
                let lastCandleIdx = -1;

                for (let i = chronoData.length - 1; i >= 0; i--) {
                    const candleTime = parseTwelveDataTimeUTC(chronoData[i].datetime);
                    const timeDiff = Math.abs(candleTime - patternTime);
                    if (timeDiff < timeframeTolerance) {
                        lastCandleIdx = i;
                        console.log(`Highlight: exact match idx=${i}, candle=${chronoData[i].datetime}, pattern=${pattern.timestamp}`);
                        break;
                    }
                }

                if (lastCandleIdx === -1) {
                    // Fallback: find closest candle
                    let minDiff = Infinity;
                    for (let i = chronoData.length - 1; i >= 0; i--) {
                        const candleTime = parseTwelveDataTimeUTC(chronoData[i].datetime);
                        const timeDiff = Math.abs(candleTime - patternTime);
                        if (timeDiff < minDiff) {
                            minDiff = timeDiff;
                            lastCandleIdx = i;
                        }
                    }
                    console.log(`Highlight: closest match idx=${lastCandleIdx}, diff=${minDiff}ms`);
                }

                // If still not found, use a position that allows context candles
                if (lastCandleIdx === -1) {
                    lastCandleIdx = Math.max(patternCandleCount + 4, chronoData.length - 1);
                    console.log(`Highlight: no match, fallback idx=${lastCandleIdx}`);
                }

                // First candle of pattern is (patternCandleCount - 1) positions BEFORE the last candle
                const firstCandleIdx = lastCandleIdx - (patternCandleCount - 1);

                // Get slice: 5 candles before and 5 after the pattern for balanced context
                const contextBefore = 5;
                const contextAfter = 5;
                const startIdx = Math.max(0, firstCandleIdx - contextBefore);
                const endIdx = Math.min(chronoData.length, lastCandleIdx + contextAfter + 1);
                const chartCandles = chronoData.slice(startIdx, endIdx);

                // Calculate highlight index relative to the slice
                // firstCandleIdx in original array -> position in slice = firstCandleIdx - startIdx
                const highlightStartIdx = firstCandleIdx - startIdx;

                // Format for rendering
                const formattedCandles = chartCandles.map(c => ({
                    datetime: c.datetime,
                    open: parseFloat(c.open),
                    high: parseFloat(c.high),
                    low: parseFloat(c.low),
                    close: parseFloat(c.close)
                }));

                // IMPORTANT: Store OHLC data in pattern for feedback submission
                // This ensures Claude Vision validates the exact same data shown to the user
                pattern.ohlc_data = formattedCandles;

                renderCandlestickChart(canvas, formattedCandles, highlightStartIdx, pattern.direction, pattern.pattern_type, pattern.timeframe);

            } catch (error) {
                console.error(`Failed to load modal chart for ${pattern.symbol}:`, error);
            }
        }

        // Update pagination controls
        function updateHistoryPagination(page, totalPages, totalPatterns) {
            const pagination = document.getElementById('historyPagination');
            const prevBtn = document.getElementById('historyPrevBtn');
            const nextBtn = document.getElementById('historyNextBtn');
            const pageInfo = document.getElementById('historyPageInfo');

            if (totalPages <= 1) {
                pagination.style.display = 'none';
                return;
            }

            pagination.style.display = 'flex';
            prevBtn.disabled = page <= 1;
            nextBtn.disabled = page >= totalPages;
            pageInfo.textContent = `Seite ${page} von ${totalPages} (${totalPatterns} Patterns)`;
        }

        // Format price with appropriate decimals
        function formatPrice(price) {
            if (!price) return '-';
            if (price < 1) return price.toFixed(5);
            if (price < 100) return price.toFixed(4);
            if (price < 10000) return price.toFixed(2);
            return price.toFixed(0);
        }

        // Convert timeframe to TwelveData interval format
        function timeframeToInterval(tf) {
            const map = {
                'M1': '1min', 'M5': '5min', 'M15': '15min', 'M30': '30min',
                'H1': '1h', 'H2': '2h', 'H4': '4h',
                'D1': '1day', 'W1': '1week', 'MN': '1month'
            };
            return map[tf] || '1h';
        }

        // Format candle timestamp for display
        // IMPORTANT: TwelveData returns datetime without timezone suffix (e.g., "2026-01-01 17:55:00")
        // These are UTC times. We need to append 'Z' to parse them correctly as UTC,
        // then convert to local timezone for display (same as formatTimestamp).
        function formatCandleTime(datetime, timeframe) {
            if (!datetime) return '';

            // Handle reference chart labels like "Kerze 1", "Kerze 2", etc.
            if (typeof datetime === 'string' && datetime.startsWith('Kerze ')) {
                return datetime;
            }

            let dateStr = datetime;

            // If datetime has no timezone info, treat it as UTC by appending 'Z'
            // This ensures consistency with pattern timestamps which are explicit UTC
            if (typeof dateStr === 'string' && !dateStr.includes('+') && !dateStr.includes('Z')) {
                // Convert "2026-01-01 17:55:00" to "2026-01-01T17:55:00Z"
                dateStr = dateStr.replace(' ', 'T') + 'Z';
            }

            const date = new Date(dateStr);
            if (isNaN(date.getTime())) {
                // Fallback: Try parsing as "YYYY-MM-DD HH:mm:ss" format manually
                const parts = datetime.split(' ');
                if (parts.length === 2) {
                    const [datePart, timePart] = parts;
                    const [year, month, day] = datePart.split('-');
                    const [hour, minute] = timePart.split(':');

                    // For daily timeframes, show date only
                    if (timeframe === 'D1' || timeframe === 'W1' || timeframe === 'MN') {
                        return `${day}.${month}.`;
                    }
                    // Add 1 hour for UTC+1 (Europe/Zurich winter time)
                    const localHour = (parseInt(hour) + 1) % 24;
                    return `${String(localHour).padStart(2, '0')}:${minute}`;
                }
                return datetime.substring(11, 16) || '';
            }

            // For daily timeframes, show date
            if (timeframe === 'D1' || timeframe === 'W1' || timeframe === 'MN') {
                return date.toLocaleDateString('de-CH', { day: '2-digit', month: '2-digit' });
            }
            // For intraday, show time in local timezone
            return date.toLocaleTimeString('de-CH', { hour: '2-digit', minute: '2-digit' });
        }

        // Render candlestick chart on canvas
        /**
         * Unified Chart Color Configuration
         * These colors match the Backend (Python/Matplotlib) implementation
         * See: src/config/chart_colors.py for documentation
         */
        const CHART_COLORS = {
            // Candle Colors
            bullish: '#4caf50',            // Green - bullish candles
            bullish_highlight: '#66bb6a',  // Lighter green for highlighted bullish
            bearish: '#f44336',            // Red - bearish candles
            bearish_highlight: '#ef5350',  // Lighter red for highlighted bearish
            neutral: '#ff9800',            // Orange - neutral/indecision patterns

            // Background & Grid
            background: '#1a1a2e',         // Dark background
            grid: 'rgba(255, 255, 255, 0.05)',  // Subtle grid lines

            // Highlight Colors (pattern area background)
            highlight_bullish: 'rgba(76, 175, 80, 0.2)',   // Green tint
            highlight_bearish: 'rgba(244, 67, 54, 0.2)',   // Red tint
            highlight_neutral: 'rgba(255, 152, 0, 0.2)',   // Orange tint

            // Text & Labels
            text_primary: '#ffffff',       // Primary text (white)
            text_secondary: '#888888',     // Secondary text (gray)
            text_highlight: '#ffffff',     // Highlighted text
        };

        function renderCandlestickChart(canvas, candles, highlightIndex, direction, patternType, timeframe = null) {
            const ctx = canvas.getContext('2d');
            const width = canvas.offsetWidth;
            const height = canvas.offsetHeight;

            // Set canvas resolution for crisp rendering
            canvas.width = width * 2;
            canvas.height = height * 2;
            ctx.scale(2, 2);

            // Clear canvas with unified background color
            ctx.fillStyle = CHART_COLORS.background;
            ctx.fillRect(0, 0, width, height);

            if (!candles || candles.length === 0) {
                ctx.fillStyle = '#666';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Keine Daten', width / 2, height / 2);
                return;
            }

            // Calculate price range
            const prices = candles.flatMap(c => [parseFloat(c.high), parseFloat(c.low)]);
            const minPrice = Math.min(...prices);
            const maxPrice = Math.max(...prices);
            const priceRange = maxPrice - minPrice || 1;
            const padding = priceRange * 0.1;

            // Calculate dimensions with space for timestamps and pattern label
            const chartPadding = { top: 25, right: 10, bottom: 22, left: 10 };
            const chartWidth = width - chartPadding.left - chartPadding.right;
            const chartHeight = height - chartPadding.top - chartPadding.bottom;
            const candleWidth = Math.min(18, (chartWidth / candles.length) * 0.65);
            const candleSpacing = chartWidth / candles.length;

            // Price to Y coordinate
            const priceToY = (price) => {
                return chartPadding.top + chartHeight - ((price - minPrice + padding) / (priceRange + 2 * padding)) * chartHeight;
            };

            // Draw grid lines with unified color
            ctx.strokeStyle = CHART_COLORS.grid;
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = chartPadding.top + (chartHeight / 4) * i;
                ctx.beginPath();
                ctx.moveTo(chartPadding.left, y);
                ctx.lineTo(width - chartPadding.right, y);
                ctx.stroke();
            }

            // Use provided timeframe or detect from datetime format
            let effectiveTimeframe = timeframe;
            if (!effectiveTimeframe) {
                const firstCandle = candles[0];
                effectiveTimeframe = 'H1';
                if (firstCandle?.datetime) {
                    const dt = firstCandle.datetime;
                    // Check if it looks like daily data (no significant time variation)
                    if (dt.includes('00:00:00') || !dt.includes(':')) {
                        effectiveTimeframe = 'D1';
                    }
                }
            }

            // Draw candles and timestamps
            candles.forEach((candle, i) => {
                const x = chartPadding.left + (i + 0.5) * candleSpacing;
                const open = parseFloat(candle.open);
                const close = parseFloat(candle.close);
                const high = parseFloat(candle.high);
                const low = parseFloat(candle.low);

                const isBullish = close >= open;
                const bodyTop = priceToY(Math.max(open, close));
                const bodyBottom = priceToY(Math.min(open, close));
                const bodyHeight = Math.max(1, bodyBottom - bodyTop);

                // Check if this candle is part of the pattern (highlight 1-3 candles depending on pattern)
                const isHighlighted = i >= highlightIndex && i <= highlightIndex + getPatternCandleCount(patternType) - 1;

                if (isHighlighted) {
                    // Draw highlight background with unified direction-based colors
                    ctx.fillStyle = direction === 'bullish'
                        ? CHART_COLORS.highlight_bullish
                        : direction === 'bearish'
                            ? CHART_COLORS.highlight_bearish
                            : CHART_COLORS.highlight_neutral;
                    ctx.fillRect(x - candleSpacing / 2, chartPadding.top, candleSpacing, chartHeight);
                }

                // Unified colors matching Backend (Matplotlib) implementation
                const bullColor = isHighlighted ? CHART_COLORS.bullish_highlight : CHART_COLORS.bullish;
                const bearColor = isHighlighted ? CHART_COLORS.bearish_highlight : CHART_COLORS.bearish;
                const candleColor = isBullish ? bullColor : bearColor;

                // Draw wick with thicker line for highlighted candles
                ctx.strokeStyle = candleColor;
                ctx.lineWidth = isHighlighted ? 2 : 1;
                ctx.beginPath();
                ctx.moveTo(x, priceToY(high));
                ctx.lineTo(x, priceToY(low));
                ctx.stroke();

                // Draw body - bullish: hollow (dark fill), bearish: filled
                if (isBullish) {
                    // Hollow candle with dark fill and colored border
                    ctx.fillStyle = CHART_COLORS.background;
                    ctx.strokeStyle = candleColor;
                    ctx.lineWidth = isHighlighted ? 2 : 1;
                    ctx.fillRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
                    ctx.strokeRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
                } else {
                    // Filled candle
                    ctx.fillStyle = candleColor;
                    ctx.fillRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
                }

                // Draw timestamp below candle with unified text colors
                const timeLabel = formatCandleTime(candle.datetime, effectiveTimeframe);
                ctx.fillStyle = isHighlighted ? CHART_COLORS.text_highlight : CHART_COLORS.text_secondary;
                ctx.font = isHighlighted ? 'bold 9px sans-serif' : '8px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(timeLabel, x, height - 5);
            });

            // Draw pattern label at the top with unified direction-based colors
            if (highlightIndex >= 0 && highlightIndex < candles.length && patternType) {
                const patternCandleCount = getPatternCandleCount(patternType);
                const labelX = chartPadding.left + (highlightIndex + patternCandleCount / 2) * candleSpacing;

                // Use unified label colors based on direction
                const labelColor = direction === 'bullish'
                    ? CHART_COLORS.bullish
                    : direction === 'bearish'
                        ? CHART_COLORS.bearish
                        : CHART_COLORS.neutral;

                // Draw pattern name label
                const label = formatPatternType(patternType);
                ctx.font = 'bold 10px sans-serif';
                const textWidth = ctx.measureText(label).width;

                // Background for label
                ctx.fillStyle = labelColor;
                const labelPadding = 4;
                const labelHeight = 14;
                const labelY = 3;

                // Rounded rectangle for label
                const rectX = labelX - textWidth / 2 - labelPadding;
                const rectWidth = textWidth + labelPadding * 2;
                ctx.beginPath();
                ctx.roundRect(rectX, labelY, rectWidth, labelHeight, 3);
                ctx.fill();

                // Label text
                ctx.fillStyle = CHART_COLORS.text_primary;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(label, labelX, labelY + labelHeight / 2);

                // Draw bracket/lines connecting to candles
                ctx.strokeStyle = labelColor;
                ctx.lineWidth = 2;
                ctx.setLineDash([]);

                // Bracket line pointing to pattern
                const bracketY = labelY + labelHeight + 2;
                ctx.beginPath();
                ctx.moveTo(labelX, bracketY);
                ctx.lineTo(labelX, bracketY + 3);
                ctx.stroke();
            }
        }

        // Get number of candles in a pattern type
        // Get minutes for a timeframe (for tolerance calculation)
        function getTimeframeMinutes(tf) {
            const tfMap = {
                'M1': 1, 'M5': 5, 'M15': 15, 'M30': 30,
                'H1': 60, 'H4': 240, 'D1': 1440, 'W1': 10080
            };
            return tfMap[tf] || 60;
        }

        function getPatternCandleCount(patternType) {
            const multiCandlePatterns = {
                // 2-candle patterns
                'bullish_engulfing': 2,
                'bearish_engulfing': 2,
                'piercing_line': 2,
                'dark_cloud_cover': 2,
                'tweezer_top': 2,
                'tweezer_bottom': 2,
                'harami': 2,
                'bullish_harami': 2,
                'bearish_harami': 2,
                'harami_cross': 2,
                'inside_bar': 2,
                'bullish_counterattack': 2,
                'bearish_counterattack': 2,
                // 3-candle patterns
                'morning_star': 3,
                'evening_star': 3,
                'three_white_soldiers': 3,
                'three_black_crows': 3,
                'three_inside_up': 3,
                'three_inside_down': 3,
                'bullish_abandoned_baby': 3,
                'bearish_abandoned_baby': 3,
                'advance_block': 3,
                'bearish_island': 3,
                'bullish_island': 3,
                // 5-candle patterns
                'rising_three_methods': 5,
                'falling_three_methods': 5,
                'tower_bottom': 5,
                'tower_top': 5
            };
            return multiCandlePatterns[patternType] || 1;
        }

        // === Training Service Functions ===

        // Load feedback statistics for training
        async function loadFeedbackStats() {
            try {
                const res = await fetch(`${CANDLESTICK_API}/feedback/statistics`);
                const data = await res.json();

                document.getElementById('feedbackTotal').textContent = data.total || 0;
                document.getElementById('feedbackConfirmed').textContent = data.by_type?.confirmed || 0;
                document.getElementById('feedbackCorrected').textContent = data.by_type?.corrected || 0;
                document.getElementById('feedbackRejected').textContent = data.by_type?.rejected || 0;

                if (data.total > 0) {
                    const correctionRate = data.correction_rate || 0;
                    document.getElementById('feedbackInfo').innerHTML =
                        `<span style="color: #64c8ff;">${data.total}</span> Feedback-Eintr√§ge gesammelt. ` +
                        `Korrekturrate: <span style="color: ${correctionRate > 30 ? '#e57373' : '#81c784'};">${correctionRate}%</span>. ` +
                        `Das Feedback wird beim n√§chsten Training automatisch ber√ºcksichtigt.`;
                } else {
                    document.getElementById('feedbackInfo').textContent =
                        'Noch kein Feedback gesammelt. √úberpr√ºfe Patterns in der "Pattern History" und markiere sie als korrekt/falsch.';
                }

            } catch (error) {
                console.error('Failed to load feedback stats:', error);
                document.getElementById('feedbackTotal').textContent = '-';
                document.getElementById('feedbackConfirmed').textContent = '-';
                document.getElementById('feedbackCorrected').textContent = '-';
                document.getElementById('feedbackRejected').textContent = '-';
            }
        }

        // Load training service info
        async function loadTrainingServiceInfo() {
            try {
                const res = await fetch(`${CANDLESTICK_TRAIN_API}/info`);
                const data = await res.json();

                document.getElementById('trainServiceStatus').textContent = 'Online';
                document.getElementById('trainServiceStatus').style.background = 'rgba(76, 175, 80, 0.2)';
                document.getElementById('trainServiceStatus').style.color = '#81c784';

                document.getElementById('trainVersion').textContent = data.version || '-';
                document.getElementById('trainPyTorch').textContent = data.pytorch_available ? 'OK' : 'N/A';
                document.getElementById('trainPatternTypes').textContent = data.capabilities?.pattern_types || '-';
                document.getElementById('trainStarted').textContent = formatTimestamp(data.started_at);

                // Render timeframes
                const tfList = document.getElementById('trainTimeframes');
                if (data.capabilities?.supported_timeframes) {
                    tfList.innerHTML = data.capabilities.supported_timeframes.map(tf =>
                        `<span class="timeframe-badge">${tf}</span>`
                    ).join('');
                }

            } catch (error) {
                console.error('Failed to load training service info:', error);
                document.getElementById('trainServiceStatus').textContent = 'Offline';
                document.getElementById('trainServiceStatus').style.background = 'rgba(244, 67, 54, 0.2)';
                document.getElementById('trainServiceStatus').style.color = '#e57373';
            }
        }

        // Load training status
        async function loadTrainingStatus() {
            try {
                const res = await fetch(`${CANDLESTICK_TRAIN_API}/train/status`);
                const data = await res.json();

                const card = document.getElementById('currentTrainingSection');
                const btn = document.getElementById('btnStartRevalTraining');

                // Only show section if training is actively running
                if (data.training && data.last_job) {
                    // Show current training
                    card.style.display = 'block';
                    btn.disabled = true;
                    btn.textContent = 'Training l√§uft...';

                    const job = data.last_job;
                    document.getElementById('currentJobId').textContent = job.job_id;
                    document.getElementById('currentJobProgress').textContent = `${job.progress?.toFixed(1) || 0}%`;
                    document.getElementById('currentProgressBar').style.width = `${job.progress || 0}%`;
                    document.getElementById('currentEpoch').textContent = job.current_epoch || 0;
                    document.getElementById('totalEpochs').textContent = job.epochs || 0;
                    document.getElementById('currentLoss').textContent = job.current_loss?.toFixed(4) || '-';
                    document.getElementById('bestLoss').textContent = job.best_loss?.toFixed(4) || '-';

                    document.getElementById('currentJobStatus').textContent = 'Running';
                    document.getElementById('currentJobStatus').className = 'job-status running';

                } else {
                    // No active training - hide section
                    card.style.display = 'none';
                    btn.disabled = false;
                    btn.textContent = '‚ñ∂ Training starten';
                }

            } catch (error) {
                console.error('Failed to load training status:', error);
            }
        }

        // Load training jobs history
        async function loadTrainingJobs() {
            try {
                const res = await fetch(`${CANDLESTICK_TRAIN_API}/train/jobs`);
                const data = await res.json();

                const jobs = data.jobs || [];
                document.getElementById('trainJobsTotal').textContent = jobs.length;
                document.getElementById('jobHistoryCount').textContent = `${jobs.length} Jobs`;

                const jobList = document.getElementById('jobList');

                if (jobs.length === 0) {
                    jobList.innerHTML = '<p style="color: #666; text-align: center; padding: 1rem;">Keine Training-Jobs vorhanden</p>';
                    return;
                }

                jobList.innerHTML = jobs.map(job => `
                    <div class="job-item ${job.status}">
                        <div class="job-info">
                            <div class="job-title">${job.job_id}</div>
                            <div class="job-meta">
                                <span>Symbole: ${job.symbols?.join(', ') || '-'}</span>
                                <span>TF: ${job.timeframes?.join(', ') || '-'}</span>
                                <span>Epochen: ${job.epochs || '-'}</span>
                                ${job.best_loss ? `<span>Best Loss: ${job.best_loss.toFixed(4)}</span>` : ''}
                                ${job.error_message ? `<span style="color: #e57373;">Fehler: ${job.error_message}</span>` : ''}
                            </div>
                            <div class="job-meta" style="margin-top: 0.25rem;">
                                <span>Erstellt: ${formatTimestamp(job.created_at)}</span>
                                ${job.completed_at ? `<span>Beendet: ${formatTimestamp(job.completed_at)}</span>` : ''}
                            </div>
                        </div>
                        <span class="job-status ${job.status}">${job.status}</span>
                    </div>
                `).join('');

            } catch (error) {
                console.error('Failed to load training jobs:', error);
                document.getElementById('jobList').innerHTML = '<p style="color: #e57373; text-align: center; padding: 1rem;">Fehler beim Laden der Jobs</p>';
            }
        }

        // Fixed training configuration for optimal generalization
        const TRAINING_SYMBOLS = ['BTCUSD', 'EURUSD', 'GBPUSD', 'XAUUSD', 'GER40', 'XTIUSD'];
        const TRAINING_TIMEFRAMES = ['H1', 'H4', 'D1'];

        // Start training
        async function startTraining() {
            const btn = document.getElementById('btnStartTraining');
            btn.disabled = true;
            btn.textContent = 'Starte...';

            const epochs = parseInt(document.getElementById('trainEpochs').value) || 50;
            const batchSize = parseInt(document.getElementById('trainBatchSize').value) || 32;
            const learningRate = parseFloat(document.getElementById('trainLearningRate').value) || 0.001;

            try {
                const res = await fetch(`${CANDLESTICK_TRAIN_API}/train`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        symbols: TRAINING_SYMBOLS,
                        timeframes: TRAINING_TIMEFRAMES,
                        epochs: epochs,
                        batch_size: batchSize,
                        learning_rate: learningRate
                    })
                });

                const result = await res.json();

                if (res.ok && result.status === 'started') {
                    showToast(`Training gestartet: ${result.job?.job_id}`, 'success');
                    await loadTrainingStatus();
                    await loadTrainingJobs();
                } else {
                    // Show actual error message from API
                    const errorMsg = result.detail || result.message || 'Training konnte nicht gestartet werden';
                    showToast(errorMsg, 'error');
                    btn.disabled = false;
                    btn.textContent = '‚ñ∂ Training starten';
                }

            } catch (error) {
                console.error('Failed to start training:', error);
                showToast('Fehler beim Starten des Trainings: ' + error.message, 'error');
                btn.disabled = false;
                btn.textContent = '‚ñ∂ Training starten';
            }
        }

        // Cancel current training
        async function cancelCurrentTraining() {
            if (!confirm('Training wirklich abbrechen?')) {
                return;
            }

            try {
                const statusRes = await fetch(`${CANDLESTICK_TRAIN_API}/train/status`);
                const statusData = await statusRes.json();

                if (statusData.last_job?.job_id) {
                    await fetch(`${CANDLESTICK_TRAIN_API}/train/${statusData.last_job.job_id}/cancel`, {
                        method: 'POST'
                    });
                    showToast('Training abgebrochen', 'info');
                    await loadTrainingStatus();
                    await loadTrainingJobs();
                }

            } catch (error) {
                console.error('Failed to cancel training:', error);
                showToast('Fehler beim Abbrechen', 'error');
            }
        }

        // === Re-Validierung Functions ===

        // Load all revalidation data
        async function loadRevalidationData() {
            await Promise.all([
                loadRevalidationStats(),
                loadPendingRevalidations()
            ]);
        }

        // Load revalidation statistics
        async function loadRevalidationStats() {
            try {
                const res = await fetch(`${CANDLESTICK_API}/feedback/revalidation-statistics`);
                const data = await res.json();

                document.getElementById('revalTotal').textContent = data.total_corrections || 0;
                document.getElementById('revalPending').textContent = data.pending_revalidation || 0;
                document.getElementById('revalDone').textContent = data.revalidated || 0;
                document.getElementById('revalImprovement').textContent =
                    data.revalidated > 0 ? `${data.improvement_rate}%` : '-';

                // Update last training/revalidation timestamps
                document.getElementById('revalLastTraining').textContent =
                    data.last_training ? formatTimestamp(data.last_training) : 'Nie';
                document.getElementById('revalLastRevalidation').textContent =
                    data.last_revalidation ? formatTimestamp(data.last_revalidation) : 'Nie';

                // Update tab badge
                const badge = document.getElementById('revalidationBadge');
                if (data.pending_revalidation > 0) {
                    badge.textContent = data.pending_revalidation;
                    badge.style.display = 'inline';
                } else {
                    badge.style.display = 'none';
                }

                // Show results card if there are completed validations
                const resultsCard = document.getElementById('revalResultsCard');
                if (data.revalidated > 0) {
                    resultsCard.style.display = 'block';
                    document.getElementById('revalCorrect').textContent = data.results?.correct || 0;
                    document.getElementById('revalNowCorrect').textContent = data.results?.now_correct || 0;
                    document.getElementById('revalStillWrong').textContent = data.results?.still_wrong || 0;
                } else {
                    resultsCard.style.display = 'none';
                }

            } catch (error) {
                console.error('Failed to load revalidation stats:', error);
            }
        }

        // Load pending revalidation items
        async function loadPendingRevalidations() {
            const container = document.getElementById('revalidationList');
            const noItemsMsg = document.getElementById('noRevalidations');
            const countBadge = document.getElementById('pendingCount');

            try {
                const res = await fetch(`${CANDLESTICK_API}/feedback/pending-revalidation`);
                const data = await res.json();

                countBadge.textContent = data.count || 0;

                if (!data.pending || data.pending.length === 0) {
                    allRevalidationItems = [];
                    filteredRevalidationItems = [];
                    container.innerHTML = '';
                    noItemsMsg.style.display = 'block';
                    return;
                }

                // Store all items globally
                allRevalidationItems = data.pending;

                // Populate filter dropdowns
                populateRevalidationFilters(data.pending);

                // Apply filters and render list
                filterRevalidationList();

                noItemsMsg.style.display = 'none';

            } catch (error) {
                console.error('Failed to load pending revalidations:', error);
                container.innerHTML = '<div style="color: #e57373; padding: 1rem;">Fehler beim Laden</div>';
            }
        }

        // Populate filter dropdowns with unique values from data
        function populateRevalidationFilters(items) {
            const symbolSelect = document.getElementById('revalFilterSymbol');
            const patternSelect = document.getElementById('revalFilterPattern');

            // Get unique symbols
            const symbols = [...new Set(items.map(item => item.symbol))].sort();
            symbolSelect.innerHTML = '<option value="">Alle Symbole</option>' +
                symbols.map(s => `<option value="${s}">${s}</option>`).join('');

            // Get unique patterns (both original and corrected)
            const patterns = [...new Set([
                ...items.map(item => item.original_pattern),
                ...items.filter(item => item.corrected_pattern).map(item => item.corrected_pattern)
            ])].filter(p => p).sort();

            patternSelect.innerHTML = '<option value="">Alle Patterns</option>' +
                patterns.map(p => `<option value="${p}">${formatPatternType(p)}</option>`).join('');
        }

        // Get the revalidation status of an item
        function getRevalidationStatus(item) {
            // Check if item has been re-corrected during revalidation
            if (item.revalidation_corrected) {
                return 're_corrected';  // Needs re-training, then back to pending
            }
            // Check if item has been validated (any revalidation result)
            if (item.revalidated || item.validation_result) {
                return 'validated';
            }
            // Default: pending (awaiting validation)
            return 'pending';
        }

        // Filter revalidation list based on selected filters
        function filterRevalidationList() {
            const symbolFilter = document.getElementById('revalFilterSymbol').value;
            const timeframeFilter = document.getElementById('revalFilterTimeframe').value;
            const typeFilter = document.getElementById('revalFilterType').value;
            const statusFilter = document.getElementById('revalFilterStatus').value;
            const patternFilter = document.getElementById('revalFilterPattern').value;

            filteredRevalidationItems = allRevalidationItems.filter(item => {
                if (symbolFilter && item.symbol !== symbolFilter) return false;
                if (timeframeFilter && item.timeframe !== timeframeFilter) return false;
                if (typeFilter) {
                    if (typeFilter === 'rejected' && item.feedback_type !== 'rejected') return false;
                    if (typeFilter === 'corrected' && item.feedback_type !== 'corrected') return false;
                }
                if (statusFilter) {
                    const itemStatus = getRevalidationStatus(item);
                    if (itemStatus !== statusFilter) return false;
                }
                if (patternFilter) {
                    if (item.original_pattern !== patternFilter && item.corrected_pattern !== patternFilter) return false;
                }
                return true;
            });

            renderRevalidationList();
        }

        // Reset all revalidation filters
        function resetRevalidationFilters() {
            document.getElementById('revalFilterSymbol').value = '';
            document.getElementById('revalFilterTimeframe').value = '';
            document.getElementById('revalFilterType').value = '';
            document.getElementById('revalFilterStatus').value = '';
            document.getElementById('revalFilterPattern').value = '';
            filterRevalidationList();
        }

        // Render the revalidation list in compact format
        function renderRevalidationList() {
            const container = document.getElementById('revalidationList');
            const noItemsMsg = document.getElementById('noRevalidations');
            const countBadge = document.getElementById('pendingCount');

            if (filteredRevalidationItems.length === 0) {
                if (allRevalidationItems.length === 0) {
                    container.innerHTML = '';
                    noItemsMsg.style.display = 'block';
                } else {
                    container.innerHTML = '<div style="text-align: center; padding: 2rem; color: #888;">Keine Eintr√§ge f√ºr diese Filter</div>';
                    noItemsMsg.style.display = 'none';
                }
                return;
            }

            noItemsMsg.style.display = 'none';
            countBadge.textContent = `${filteredRevalidationItems.length} / ${allRevalidationItems.length}`;

            container.innerHTML = filteredRevalidationItems.map((item, index) => {
                const isRejected = item.feedback_type === 'rejected';
                const typeClass = isRejected ? 'rejected' : 'corrected';
                const typeLabel = isRejected ? 'Abgelehnt' : 'Korrigiert';

                // Status bestimmen
                const status = getRevalidationStatus(item);
                let statusClass, statusLabel;
                switch (status) {
                    case 'validated':
                        statusClass = 'validated';
                        statusLabel = '‚úì √úberpr√ºft';
                        break;
                    case 're_corrected':
                        statusClass = 're-corrected';
                        statusLabel = 'üîÑ Korrigiert';
                        break;
                    default:
                        statusClass = 'pending';
                        statusLabel = '‚è≥ Ausstehend';
                }

                const patternDisplay = isRejected
                    ? `${formatPatternType(item.original_pattern)} ‚Üí ‚úó`
                    : `${formatPatternType(item.original_pattern)} ‚Üí ${formatPatternType(item.corrected_pattern)}`;

                const timestamp = new Date(item.pattern_timestamp);
                const dateStr = timestamp.toLocaleDateString('de-CH', { day: '2-digit', month: '2-digit', year: '2-digit' });
                const timeStr = timestamp.toLocaleTimeString('de-CH', { hour: '2-digit', minute: '2-digit' });

                return `
                    <div class="reval-list-item" onclick="openRevalDetail(${index})">
                        <div class="reval-list-symbol">${item.symbol}</div>
                        <div class="reval-list-pattern">${patternDisplay}</div>
                        <div class="reval-list-timeframe">
                            <span class="timeframe-badge">${item.timeframe}</span>
                        </div>
                        <div class="reval-list-date">${dateStr} ${timeStr}</div>
                        <div class="reval-list-type">
                            <span class="reval-type-badge ${typeClass}">${typeLabel}</span>
                        </div>
                        <div class="reval-list-status">
                            <span class="reval-status-badge ${statusClass}">${statusLabel}</span>
                        </div>
                        <div class="reval-list-action">
                            <button class="btn btn-sm" onclick="event.stopPropagation(); openRevalDetail(${index})">Details</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Open revalidation detail modal
        function openRevalDetail(index) {
            currentRevalDetailIndex = index;
            const item = filteredRevalidationItems[index];
            if (!item) return;

            const overlay = document.getElementById('revalDetailOverlay');
            overlay.classList.add('active');

            updateRevalDetailContent(item, index);
        }

        // Close revalidation detail modal
        function closeRevalDetail(event) {
            if (event && event.target !== event.currentTarget) return;
            const overlay = document.getElementById('revalDetailOverlay');
            overlay.classList.remove('active');
        }

        // Navigate to previous/next item in detail view
        function navigateRevalDetail(direction) {
            const newIndex = currentRevalDetailIndex + direction;
            if (newIndex < 0 || newIndex >= filteredRevalidationItems.length) return;

            currentRevalDetailIndex = newIndex;
            const item = filteredRevalidationItems[newIndex];
            updateRevalDetailContent(item, newIndex);
        }

        // Update the detail modal content
        async function updateRevalDetailContent(item, index) {
            const isRejected = item.feedback_type === 'rejected';

            // Update header
            document.getElementById('revalDetailSymbol').textContent = item.symbol;
            const typeBadge = document.getElementById('revalDetailType');
            typeBadge.textContent = isRejected ? 'Abgelehnt' : 'Korrigiert';
            typeBadge.className = `reval-detail-badge ${isRejected ? 'rejected' : 'corrected'}`;

            // Update position
            document.getElementById('revalDetailPosition').textContent = `${index + 1} / ${filteredRevalidationItems.length}`;

            // Update navigation buttons
            document.getElementById('revalPrevBtn').disabled = index === 0;
            document.getElementById('revalNextBtn').disabled = index === filteredRevalidationItems.length - 1;

            // Update info
            document.getElementById('revalDetailOriginal').textContent = formatPatternType(item.original_pattern);
            document.getElementById('revalDetailCorrected').textContent = isRejected ? 'Kein Pattern' : formatPatternType(item.corrected_pattern);
            document.getElementById('revalDetailTimeframe').textContent = item.timeframe;

            const timestamp = new Date(item.pattern_timestamp);
            document.getElementById('revalDetailTimestamp').textContent = timestamp.toLocaleString('de-CH');

            // Update reason if available
            const reasonRow = document.getElementById('revalReasonRow');
            const reasonSpan = document.getElementById('revalDetailReason');
            if (item.reason_category || item.reason_text) {
                reasonRow.style.display = 'flex';
                let reasonDisplay = '';
                if (item.reason_category && reasonCategoriesCache && reasonCategoriesCache[item.reason_category]) {
                    reasonDisplay = reasonCategoriesCache[item.reason_category].label;
                } else if (item.reason_category) {
                    reasonDisplay = item.reason_category;
                }
                if (item.reason_text) {
                    reasonDisplay += reasonDisplay ? ` - ${item.reason_text}` : item.reason_text;
                }
                reasonSpan.textContent = reasonDisplay || '-';
            } else {
                reasonRow.style.display = 'none';
            }

            // Render feedback history
            const historyContainer = document.getElementById('revalDetailFeedbackHistory');
            historyContainer.innerHTML = renderRevalDetailFeedbackHistory(item);

            // Reset Claude Vision result
            const claudeResultDiv = document.getElementById('revalClaudeVisionResult');
            if (claudeResultDiv) {
                claudeResultDiv.style.display = 'none';
                claudeResultDiv.innerHTML = '';
            }

            // Load chart
            await loadRevalDetailChart(item);

            // Check current detection
            checkCurrentDetection(item);
        }

        // Render feedback history for detail modal
        function renderRevalDetailFeedbackHistory(item) {
            const feedbackDate = new Date(item.feedback_timestamp || item.created_at);
            const feedbackType = item.feedback_type === 'rejected' ? 'Abgelehnt' : 'Korrigiert';

            let html = `
                <div class="reval-history-entry">
                    <div class="reval-history-date">${feedbackDate.toLocaleString('de-CH')}</div>
                    <div class="reval-history-action">
                        <span class="reval-history-badge initial">${feedbackType}</span>
                        <span class="reval-history-text">
                            ${item.feedback_type === 'rejected'
                                ? `"${formatPatternType(item.original_pattern)}" als False Positive markiert`
                                : `"${formatPatternType(item.original_pattern)}" zu "${formatPatternType(item.corrected_pattern)}" korrigiert`
                            }
                        </span>
                    </div>
                </div>
            `;

            // Add revalidation history if available
            if (item.revalidation_history && item.revalidation_history.length > 0) {
                item.revalidation_history.forEach(reval => {
                    const revalDate = new Date(reval.timestamp);
                    const resultClass = reval.result === 'still_wrong' ? 'failed' : 'success';
                    const resultText = reval.result === 'still_wrong' ? 'Weiterhin falsch'
                        : reval.result === 'correct' ? 'Jetzt korrekt'
                        : 'Nicht mehr erkannt';

                    html += `
                        <div class="reval-history-entry">
                            <div class="reval-history-date">${revalDate.toLocaleString('de-CH')}</div>
                            <div class="reval-history-action">
                                <span class="reval-history-badge ${resultClass}">${resultText}</span>
                                ${reval.notes ? `<span class="reval-history-text">${reval.notes}</span>` : ''}
                            </div>
                        </div>
                    `;
                });
            }

            return html;
        }

        // Load chart for detail modal
        async function loadRevalDetailChart(item) {
            const container = document.getElementById('revalDetailChartContainer');
            container.innerHTML = '<div class="loading"><span class="spinner"></span> Lade Chart...</div>';

            // Load reference chart in parallel
            loadRevalReferenceChart(item.original_pattern);

            try {
                const patternCandleCount = getPatternCandleCount(item.original_pattern);

                // WICHTIG: Verwende gespeicherte ohlc_data wenn vorhanden (f√ºr konsistente Zeitstempel)
                // Die gespeicherten Daten wurden zum Zeitpunkt der Pattern-Erkennung gespeichert
                // und enthalten die exakten Kerzen, die zur Erkennung f√ºhrten.
                let ohlcData;
                if (item.ohlc_data && Array.isArray(item.ohlc_data) && item.ohlc_data.length > 0) {
                    console.log('Using stored ohlc_data for revalidation chart');
                    ohlcData = item.ohlc_data;
                    // Berechne Pattern-Index aus gespeicherten Daten (5 Kerzen vor Pattern)
                    // Pattern-Start ist bei Index 5 (nach 5 Kontext-Kerzen), Pattern-Ende ist 5 + candleCount - 1
                    ohlcData._patternIdx = 5 + patternCandleCount - 1;
                } else {
                    // Fallback: Hole aktuelle Daten von TwelveData
                    console.log('No stored ohlc_data, fetching from TwelveData');
                    ohlcData = await fetchOhlcForRevalidation(item.symbol, item.timeframe, item.pattern_timestamp, patternCandleCount);
                }

                if (!ohlcData || ohlcData.length === 0) {
                    container.innerHTML = '<div style="color: #888; text-align: center; padding: 2rem;">Keine Chart-Daten verf√ºgbar</div>';
                    return;
                }

                // Create canvas for chart
                container.innerHTML = '<canvas id="revalDetailCanvas" style="width: 100%; height: 280px;"></canvas>';
                const canvas = document.getElementById('revalDetailCanvas');

                const direction = getPatternDirection(item.original_pattern);
                // patternCandleCount already defined above for fetchOhlcForRevalidation

                // Save _patternIdx before mapping (map creates new array without custom properties)
                const patternIdx = ohlcData._patternIdx;

                const formattedCandles = ohlcData.map(c => ({
                    datetime: c.datetime || c.timestamp,
                    open: parseFloat(c.open),
                    high: parseFloat(c.high),
                    low: parseFloat(c.low),
                    close: parseFloat(c.close)
                }));

                // Calculate highlight index - pattern should be in the middle of the chart
                let highlightIdx = 0;
                if (patternIdx !== undefined && patternIdx >= 0) {
                    // patternIdx points to the LAST candle of the pattern
                    // Highlight starts (candleCount - 1) positions before
                    highlightIdx = Math.max(0, patternIdx - (patternCandleCount - 1));
                } else {
                    // Fallback: try to find pattern by timestamp in the formatted data
                    const patternTime = new Date(item.pattern_timestamp).getTime();
                    const msPerCandle = {
                        'M5': 5 * 60 * 1000,
                        'M15': 15 * 60 * 1000,
                        'M30': 30 * 60 * 1000,
                        'H1': 60 * 60 * 1000,
                        'H4': 4 * 60 * 60 * 1000,
                        'D1': 24 * 60 * 60 * 1000
                    };
                    const candleMs = msPerCandle[item.timeframe] || 60 * 60 * 1000;

                    for (let i = 0; i < formattedCandles.length; i++) {
                        const candleTime = new Date(formattedCandles[i].datetime).getTime();
                        if (Math.abs(candleTime - patternTime) < candleMs) {
                            highlightIdx = Math.max(0, i - (patternCandleCount - 1));
                            break;
                        }
                    }
                }

                console.log(`Detail chart: ${formattedCandles.length} candles, patternIdx=${patternIdx}, highlightIdx=${highlightIdx}`);

                renderCandlestickChart(canvas, formattedCandles, highlightIdx, direction, item.original_pattern, item.timeframe);

            } catch (error) {
                console.error('Failed to load detail chart:', error);
                container.innerHTML = '<div style="color: #e57373; text-align: center; padding: 2rem;">Fehler beim Laden des Charts</div>';
            }
        }

        // Load reference chart for revalidation detail modal
        async function loadRevalReferenceChart(patternType) {
            const container = document.getElementById('revalDetailReferenceContainer');
            if (!container) return;

            // Show loading spinner
            container.innerHTML = '<span class="spinner"></span>';

            // Check cache first
            if (patternImageCache[patternType]) {
                container.innerHTML = `
                    <div style="text-align: center;">
                        <img src="data:image/png;base64,${patternImageCache[patternType]}" alt="${patternType}" style="max-width: 100%; height: auto; border-radius: 4px;">
                        <div style="font-size: 0.7rem; color: #666; margin-top: 4px;">${formatPatternType(patternType)}</div>
                    </div>
                `;
                return;
            }

            try {
                const res = await fetch(`${CANDLESTICK_API}/examples/chart/${patternType}?compact=true`);
                if (!res.ok) throw new Error('Failed to load chart');
                const data = await res.json();

                // Cache the image
                patternImageCache[patternType] = data.image_base64;

                // Display the image with pattern type label
                container.innerHTML = `
                    <div style="text-align: center;">
                        <img src="data:image/png;base64,${data.image_base64}" alt="${patternType}" style="max-width: 100%; height: auto; border-radius: 4px;">
                        <div style="font-size: 0.7rem; color: #666; margin-top: 4px;">${formatPatternType(patternType)}</div>
                    </div>
                `;
            } catch (error) {
                console.error(`Failed to load reference chart for ${patternType}:`, error);
                container.innerHTML = `<div style="text-align: center; color: #888; padding: 1rem;">${formatPatternType(patternType)}</div>`;
            }
        }

        // Validate revalidation item with Claude Vision API
        async function validateRevalWithClaudeVision() {
            const item = filteredRevalidationItems[currentRevalDetailIndex];
            if (!item) {
                showToast('Kein Pattern ausgew√§hlt.', 'warning');
                return;
            }

            const btn = document.getElementById('revalBtnClaudeVision');
            const resultDiv = document.getElementById('revalClaudeVisionResult');
            const originalText = btn.innerHTML;

            try {
                // Show loading state
                btn.disabled = true;
                btn.innerHTML = '‚è≥ Analysiere...';
                resultDiv.style.display = 'none';

                // Build pattern ID
                const patternId = item.pattern_id || item.id ||
                    `${item.symbol}_${item.pattern_timestamp}_${item.original_pattern}`;

                // Call Claude Vision API with direct data (pattern may not be in history)
                // IMPORTANT: Include stored ohlc_data to ensure Claude validates the EXACT same data
                // that was shown when the user gave feedback (not fresh data that may have changed)
                const response = await fetch(`${CANDLESTICK_API}/claude/validate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        pattern_id: patternId,
                        force: true,
                        // Provide direct data for patterns not in history
                        pattern_type: item.original_pattern,
                        symbol: item.symbol,
                        timeframe: item.timeframe,
                        pattern_timestamp: item.pattern_timestamp,
                        // Include stored OHLC data from feedback (if available)
                        ohlc_data: item.ohlc_data || null
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.detail || `HTTP ${response.status}`);
                }

                const data = await response.json();
                const validation = data.validation || {};

                // Display result
                displayRevalClaudeVisionResult(validation, item);

            } catch (error) {
                console.error('Claude Vision validation error:', error);
                resultDiv.style.display = 'block';
                resultDiv.style.background = 'rgba(244, 67, 54, 0.15)';
                resultDiv.style.border = '1px solid rgba(244, 67, 54, 0.3)';
                resultDiv.innerHTML = `
                    <div style="color: #f44336; font-weight: 600; margin-bottom: 0.25rem;">
                        ‚ùå Claude Vision Fehler
                    </div>
                    <div style="color: #ccc; font-size: 0.85rem;">
                        ${error.message || 'Unbekannter Fehler'}
                    </div>
                `;
            } finally {
                btn.disabled = false;
                btn.innerHTML = originalText;
            }
        }

        // Display Claude Vision validation result for revalidation
        function displayRevalClaudeVisionResult(validation, item) {
            const resultDiv = document.getElementById('revalClaudeVisionResult');
            const agrees = validation.claude_agrees;
            const confidence = validation.claude_confidence || 0;
            const reasoning = validation.claude_reasoning || 'Keine Begr√ºndung verf√ºgbar';
            const suggestedPattern = validation.claude_pattern_type;

            resultDiv.style.display = 'block';

            // For revalidation, we want to know if Claude agrees with the CORRECTED pattern
            // or if it confirms that the ORIGINAL pattern was indeed wrong
            const isRejected = item.feedback_type === 'rejected';
            const correctedPattern = item.corrected_pattern;

            if (agrees) {
                // Claude agrees the original pattern was correct
                resultDiv.style.background = 'rgba(255, 152, 0, 0.15)';
                resultDiv.style.border = '1px solid rgba(255, 152, 0, 0.3)';
                resultDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                        <span style="color: #ffb74d; font-weight: 600;">‚ö† Claude best√§tigt Original-Pattern</span>
                        <span style="background: rgba(255, 152, 0, 0.2); padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.8rem;">
                            ${Math.round(confidence * 100)}% Konfidenz
                        </span>
                    </div>
                    <div style="color: #aaa; font-size: 0.85rem; line-height: 1.4;">
                        ${reasoning}
                    </div>
                    <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.1); color: #888; font-size: 0.8rem;">
                        ${isRejected
                            ? 'Die Ablehnung k√∂nnte falsch gewesen sein - Pattern war m√∂glicherweise korrekt.'
                            : 'Die Korrektur k√∂nnte √ºberfl√ºssig gewesen sein.'
                        }
                    </div>
                `;
            } else {
                // Claude doesn't agree - this confirms the correction was right
                let suggestionHtml = '';
                if (suggestedPattern && suggestedPattern !== 'no_pattern' && suggestedPattern !== 'none') {
                    const matchesCorrected = correctedPattern && suggestedPattern.toLowerCase() === correctedPattern.toLowerCase();
                    if (matchesCorrected) {
                        suggestionHtml = `
                            <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.1);">
                                <span style="color: #81c784;">‚úì Claude best√§tigt Korrektur zu "${formatPatternType(suggestedPattern)}"</span>
                            </div>
                        `;
                    } else {
                        suggestionHtml = `
                            <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.1);">
                                <span style="color: #888;">Claude Vorschlag:</span>
                                <span style="color: #64c8ff; font-weight: 500;">${formatPatternType(suggestedPattern)}</span>
                                ${correctedPattern ? `<span style="color: #888; margin-left: 0.5rem;">(statt ${formatPatternType(correctedPattern)})</span>` : ''}
                            </div>
                        `;
                    }
                } else if (isRejected) {
                    suggestionHtml = `
                        <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.1);">
                            <span style="color: #81c784;">‚úì Claude best√§tigt: Kein g√ºltiges Pattern</span>
                        </div>
                    `;
                }

                resultDiv.style.background = 'rgba(76, 175, 80, 0.15)';
                resultDiv.style.border = '1px solid rgba(76, 175, 80, 0.3)';
                resultDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                        <span style="color: #81c784; font-weight: 600;">‚úì Claude best√§tigt die Korrektur</span>
                        <span style="background: rgba(76, 175, 80, 0.2); padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.8rem;">
                            ${Math.round(confidence * 100)}% Konfidenz
                        </span>
                    </div>
                    <div style="color: #aaa; font-size: 0.85rem; line-height: 1.4;">
                        ${reasoning}
                    </div>
                    ${suggestionHtml}
                `;
            }
        }

        // Check current detection for the pattern
        async function checkCurrentDetection(item) {
            const container = document.getElementById('revalDetailCurrentDetection');
            container.innerHTML = '<div class="loading"><span class="spinner"></span> Pr√ºfe aktuelle Erkennung...</div>';

            try {
                const res = await fetch(`${CANDLESTICK_API}/patterns/scan`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        symbol: item.symbol,
                        timeframes: [item.timeframe],
                        lookback_candles: 50,
                        min_confidence: 0.3
                    })
                });

                const data = await res.json();

                // Check if original pattern is still detected at the same timestamp
                const patternTime = new Date(item.pattern_timestamp).getTime();
                let foundPatterns = [];

                const timeframeKey = item.timeframe.toLowerCase();
                const tfPatterns = data.result?.[timeframeKey]?.patterns || [];

                tfPatterns.forEach(p => {
                    const pTime = new Date(p.timestamp).getTime();
                    // Match if within 1 hour (for H1) or proportional for other timeframes
                    if (Math.abs(pTime - patternTime) < 3600000 * 4) {
                        foundPatterns.push(p);
                    }
                });

                if (foundPatterns.length === 0) {
                    container.innerHTML = `
                        <div class="detection-result detection-none">
                            <span class="detection-icon">‚óã</span>
                            <span>Kein Pattern mehr an dieser Stelle erkannt</span>
                        </div>
                    `;
                } else {
                    const isOriginalStillDetected = foundPatterns.some(p => p.pattern_type === item.original_pattern);
                    const isCorrectedNowDetected = item.corrected_pattern && foundPatterns.some(p => p.pattern_type === item.corrected_pattern);

                    let html = '<div class="detection-results">';
                    foundPatterns.forEach(p => {
                        const isOriginal = p.pattern_type === item.original_pattern;
                        const isCorrected = p.pattern_type === item.corrected_pattern;
                        const resultClass = isCorrected ? 'detection-success' : (isOriginal ? 'detection-wrong' : 'detection-other');

                        html += `
                            <div class="detection-result ${resultClass}">
                                <span class="detection-icon">${isCorrected ? '‚úì' : (isOriginal ? '‚úó' : '‚Ä¢')}</span>
                                <span>${formatPatternType(p.pattern_type)} (${Math.round(p.confidence * 100)}%)</span>
                            </div>
                        `;
                    });
                    html += '</div>';
                    container.innerHTML = html;
                }

            } catch (error) {
                console.error('Failed to check current detection:', error);
                container.innerHTML = '<div style="color: #e57373;">Fehler beim Pr√ºfen der aktuellen Erkennung</div>';
            }
        }

        // Submit revalidation feedback from detail modal
        async function submitRevalFeedback(result) {
            const item = filteredRevalidationItems[currentRevalDetailIndex];
            if (!item) return;

            try {
                // Map result to validation_result values expected by API
                // API expects: 'correct', 'still_wrong', 'now_correct'
                const validationResult = result === 'not_detected' ? 'now_correct' : result;

                const res = await fetch(`${CANDLESTICK_API}/feedback/revalidate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        feedback_id: item.id,
                        validation_result: validationResult,
                        notes: null
                    })
                });

                if (res.ok) {
                    showToast('√úberpr√ºfung gespeichert', 'success');

                    // Move to next item or close if last
                    if (currentRevalDetailIndex < filteredRevalidationItems.length - 1) {
                        navigateRevalDetail(1);
                    } else {
                        closeRevalDetail();
                    }

                    // Reload data
                    loadRevalidationData();
                } else {
                    const error = await res.json();
                    showToast('Fehler: ' + (error.detail || 'Unbekannter Fehler'), 'error');
                }
            } catch (error) {
                console.error('Failed to submit revalidation:', error);
                showToast('Netzwerkfehler', 'error');
            }
        }

        // Load and render chart for a revalidation item
        async function loadRevalidationChart(item, index) {
            const canvasId = `reval-chart-${index}`;
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            // Show loading state
            canvas.width = canvas.offsetWidth * 2;
            canvas.height = canvas.offsetHeight * 2;
            ctx.scale(2, 2);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, canvas.offsetWidth, canvas.offsetHeight);
            ctx.fillStyle = '#888';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Lade Chart...', canvas.offsetWidth / 2, canvas.offsetHeight / 2);

            try {
                // Always fetch fresh data from API for better context (5 candles before pattern, 5 after)
                // The cached ohlc_data in item often only contains the pattern candles without context
                const patternCandleCount = getPatternCandleCount(item.original_pattern);
                let ohlcData = await fetchOhlcForRevalidation(item.symbol, item.timeframe, item.pattern_timestamp, patternCandleCount);

                // Fallback to cached data only if API fails
                if (!ohlcData || ohlcData.length === 0) {
                    ohlcData = item.ohlc_data;
                }

                if (!ohlcData || ohlcData.length === 0) {
                    // No data available
                    canvas.width = canvas.offsetWidth * 2;
                    canvas.height = canvas.offsetHeight * 2;
                    ctx.scale(2, 2);
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(0, 0, canvas.offsetWidth, canvas.offsetHeight);
                    ctx.fillStyle = '#888';
                    ctx.font = '11px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('Keine Daten verf√ºgbar', canvas.offsetWidth / 2, canvas.offsetHeight / 2);
                    return;
                }

                // Find pattern position and render chart
                const direction = getPatternDirection(item.original_pattern);
                // patternCandleCount already defined above for fetchOhlcForRevalidation

                // Save _patternIdx before mapping (map creates new array without custom properties)
                const patternIdx = ohlcData._patternIdx;

                // Format candles for rendering
                const formattedCandles = ohlcData.map(c => ({
                    datetime: c.datetime || c.timestamp,
                    open: parseFloat(c.open),
                    high: parseFloat(c.high),
                    low: parseFloat(c.low),
                    close: parseFloat(c.close)
                }));

                // Use pre-calculated pattern index if available (from centered fetch)
                let highlightIdx = 0;

                if (patternIdx !== undefined && patternIdx >= 0) {
                    // Pattern index was pre-calculated during fetch
                    // The pattern timestamp points to the LAST candle of the pattern
                    // Highlight starts (candleCount - 1) positions before
                    highlightIdx = Math.max(0, patternIdx - (patternCandleCount - 1));
                } else {
                    // Fallback: Find the pattern timestamp in the data
                    const patternTime = new Date(item.pattern_timestamp).getTime();
                    const msPerCandle = {
                        'M5': 5 * 60 * 1000,
                        'M15': 15 * 60 * 1000,
                        'M30': 30 * 60 * 1000,
                        'H1': 60 * 60 * 1000,
                        'H4': 4 * 60 * 60 * 1000,
                        'D1': 24 * 60 * 60 * 1000
                    };
                    const candleMs = msPerCandle[item.timeframe] || 60 * 60 * 1000;

                    for (let i = 0; i < formattedCandles.length; i++) {
                        const candleTime = new Date(formattedCandles[i].datetime).getTime();
                        if (Math.abs(candleTime - patternTime) < candleMs) {
                            // This is the last candle of the pattern
                            // Highlight starts (candleCount - 1) positions before
                            highlightIdx = Math.max(0, i - (patternCandleCount - 1));
                            break;
                        }
                    }
                }

                // Render the chart
                renderCandlestickChart(canvas, formattedCandles, highlightIdx, direction, item.original_pattern, item.timeframe);

            } catch (error) {
                console.error(`Failed to load chart for ${item.id}:`, error);
                canvas.width = canvas.offsetWidth * 2;
                canvas.height = canvas.offsetHeight * 2;
                ctx.scale(2, 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(0, 0, canvas.offsetWidth, canvas.offsetHeight);
                ctx.fillStyle = '#e57373';
                ctx.font = '11px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Fehler beim Laden', canvas.offsetWidth / 2, canvas.offsetHeight / 2);
            }
        }

        // Fetch OHLC data for revalidation chart - centered around pattern timestamp
        // patternCandleCount: Number of candles in the pattern (1 for single-candle, 3 for morning star, etc.)
        async function fetchOhlcForRevalidation(symbol, timeframe, patternTimestamp, patternCandleCount = 1) {
            try {
                // Convert timeframe to TwelveData format
                const intervalMap = {
                    'M5': '5min', 'M15': '15min', 'M30': '30min',
                    'H1': '1h', 'H4': '4h', 'D1': '1day'
                };
                const interval = intervalMap[timeframe] || '1h';

                // Calculate how old the pattern is to fetch enough data
                const patternDate = new Date(patternTimestamp);
                const now = new Date();
                const ageInMs = now - patternDate;

                // Calculate how many candles we need based on timeframe
                const msPerCandle = {
                    'M5': 5 * 60 * 1000,
                    'M15': 15 * 60 * 1000,
                    'M30': 30 * 60 * 1000,
                    'H1': 60 * 60 * 1000,
                    'H4': 4 * 60 * 60 * 1000,
                    'D1': 24 * 60 * 60 * 1000
                };
                const candleMs = msPerCandle[timeframe] || 60 * 60 * 1000;

                // Calculate how many candles back the pattern is, plus buffer for display
                const candlesBack = Math.ceil(ageInMs / candleMs);
                // We want ~15 candles before and ~15 after the pattern = 30 total displayed
                // But we need to fetch enough to include the pattern + buffer after it
                const outputsize = Math.min(500, Math.max(50, candlesBack + 20));

                // Fetch data
                const res = await fetch(`${DATA_API}/twelvedata/time_series/${symbol}?interval=${interval}&outputsize=${outputsize}`);
                if (!res.ok) return null;

                const data = await res.json();
                if (!data.values || data.values.length === 0) return null;

                // TwelveData returns newest first, reverse to chronological order
                const allCandles = data.values.slice().reverse();

                // Find the pattern candle in the data
                let patternIdx = -1;
                for (let i = 0; i < allCandles.length; i++) {
                    const candleTime = new Date(allCandles[i].datetime);
                    // Match within half the candle timeframe
                    if (Math.abs(candleTime - patternDate) < candleMs / 2) {
                        patternIdx = i;
                        break;
                    }
                }

                // If pattern not found, try a wider match
                if (patternIdx === -1) {
                    for (let i = 0; i < allCandles.length; i++) {
                        const candleTime = new Date(allCandles[i].datetime);
                        if (Math.abs(candleTime - patternDate) < candleMs * 2) {
                            patternIdx = i;
                            break;
                        }
                    }
                }

                // If still not found, return all data (fallback)
                if (patternIdx === -1) {
                    console.warn(`Pattern timestamp ${patternTimestamp} not found in data, showing latest candles`);
                    return allCandles.slice(-30);
                }

                // Extract window: 5 candles BEFORE the pattern start, pattern candles, 5 candles AFTER
                // patternIdx points to the LAST candle of the pattern
                // Pattern starts at: patternIdx - (patternCandleCount - 1)
                const patternStartIdx = patternIdx - (patternCandleCount - 1);
                const candlesBefore = 5;
                const candlesAfter = 5;
                const startIdx = Math.max(0, patternStartIdx - candlesBefore);
                const endIdx = Math.min(allCandles.length, patternIdx + candlesAfter + 1);

                const windowCandles = allCandles.slice(startIdx, endIdx);

                // Recalculate pattern position within the window for highlighting
                // _patternIdx should point to the LAST candle of the pattern in the window
                windowCandles._patternIdx = patternIdx - startIdx;

                return windowCandles;

            } catch (error) {
                console.error('Failed to fetch OHLC for revalidation:', error);
                return null;
            }
        }

        // Render a single revalidation item
        function renderRevalidationItem(item, index) {
            const isRejected = item.feedback_type === 'rejected';
            const correctionDisplay = isRejected
                ? `<span class="original">${formatPatternType(item.original_pattern)}</span>
                   <span class="arrow">‚Üí</span>
                   <span class="corrected">Kein Pattern</span>`
                : `<span class="original">${formatPatternType(item.original_pattern)}</span>
                   <span class="arrow">‚Üí</span>
                   <span class="corrected">${formatPatternType(item.corrected_pattern)}</span>`;

            // Determine direction from original pattern for highlighting
            const direction = getPatternDirection(item.original_pattern);
            const canvasId = `reval-chart-${index}`;

            // Context-aware button labels based on feedback type
            // For rejected: Pattern should NOT be detected anymore
            // For corrected: Pattern should be detected as the corrected type
            let successLabel, failLabel, successResult, failResult;

            if (isRejected) {
                // User said: "This is NOT a pattern" (false positive)
                // Success = Model no longer detects any pattern here
                // Fail = Model still detects the wrong pattern
                successLabel = `‚úì Wird nicht mehr erkannt`;
                failLabel = `‚úó "${formatPatternType(item.original_pattern)}" wird noch erkannt`;
                successResult = 'now_correct';
                failResult = 'still_wrong';
            } else {
                // User said: "This should be X instead of Y"
                // Success = Model now detects the correct pattern
                // Fail = Model still detects wrong pattern or nothing
                successLabel = `‚úì "${formatPatternType(item.corrected_pattern)}" wird erkannt`;
                failLabel = `‚úó Noch falsch erkannt`;
                successResult = 'correct';
                failResult = 'still_wrong';
            }

            // Help text explaining what to check
            const helpText = isRejected
                ? `<div class="revalidation-help">
                       <strong>Pr√ºfung:</strong> Erkennt das Modell hier noch f√§lschlicherweise ein "${formatPatternType(item.original_pattern)}"?
                   </div>`
                : `<div class="revalidation-help">
                       <strong>Pr√ºfung:</strong> Erkennt das Modell jetzt "${formatPatternType(item.corrected_pattern)}" statt "${formatPatternType(item.original_pattern)}"?
                   </div>`;

            // Build feedback history section for revalidation view
            const feedbackHistoryHtml = renderRevalidationFeedbackHistory(item);

            return `
                <div class="revalidation-item ${isRejected ? 'rejected' : ''}" data-item-id="${item.id}">
                    <div class="revalidation-header">
                        <div>
                            <strong>${item.symbol}</strong>
                            <span class="timeframe-badge" style="margin-left: 0.5rem;">${item.timeframe}</span>
                        </div>
                        <span class="badge badge-${isRejected ? 'bearish' : 'neutral'}">
                            ${isRejected ? 'Abgelehnt' : 'Korrigiert'}
                        </span>
                    </div>
                    <div class="revalidation-correction">
                        ${correctionDisplay}
                    </div>
                    ${helpText}
                    <div class="revalidation-chart-container" style="display: flex; gap: 1rem; flex-wrap: wrap; margin: 0.75rem 0;">
                        <div style="flex: 1; min-width: 280px;">
                            <div style="font-size: 0.75rem; color: #888; margin-bottom: 0.3rem;">Chart zum Zeitpunkt des Patterns:</div>
                            <canvas id="${canvasId}" class="revalidation-canvas" style="width: 100%; height: 140px; border-radius: 6px; background: rgba(0,0,0,0.2);"></canvas>
                        </div>
                    </div>
                    ${feedbackHistoryHtml}
                    <div class="revalidation-actions">
                        <button class="btn btn-success" onclick="markRevalidation('${item.id}', '${successResult}')" title="Modell erkennt jetzt korrekt">
                            ${successLabel}
                        </button>
                        <button class="btn btn-danger" onclick="showRevalidationCorrectionDialog('${item.id}', '${item.original_pattern}', '${item.symbol}', '${item.timeframe}')" title="Pattern korrigieren">
                            ‚úó Falsch erkannt - korrigieren
                        </button>
                        <button class="btn btn-primary" onclick="scanForRevalidation('${item.id}', '${item.symbol}', '${item.timeframe}', '${item.original_pattern}')" title="Aktuellen Scan starten und Vorschl√§ge anzeigen">
                            üîç Neu scannen
                        </button>
                    </div>
                    <div id="reval-correction-${item.id}" class="revalidation-correction-panel" style="display: none;">
                        <div class="correction-header">Welches Pattern ist korrekt?</div>

                        <!-- Scan-Vorschl√§ge werden hier dynamisch eingef√ºgt -->
                        <div id="reval-scan-suggestions-${item.id}" class="scan-suggestions" style="display: none;">
                            <div class="scan-suggestions-header">
                                <span class="scan-icon">üîç</span> Erkannte Patterns (Vorschl√§ge):
                            </div>
                            <div class="scan-suggestions-buttons"></div>
                        </div>

                        <div class="correction-divider" id="reval-divider-${item.id}" style="display: none;">
                            <span>oder manuell ausw√§hlen:</span>
                        </div>

                        <div class="correction-options">
                            <select id="reval-select-${item.id}" class="pattern-select">
                                <option value="">-- Pattern ausw√§hlen --</option>
                                <option value="no_pattern">‚ùå Kein Pattern (False Positive)</option>
                                <optgroup label="Reversal Bullish">
                                    <option value="hammer">Hammer</option>
                                    <option value="inverted_hammer">Inverted Hammer</option>
                                    <option value="bullish_engulfing">Bullish Engulfing</option>
                                    <option value="morning_star">Morning Star</option>
                                    <option value="piercing_line">Piercing Line</option>
                                    <option value="dragonfly_doji">Dragonfly Doji</option>
                                    <option value="three_white_soldiers">Three White Soldiers</option>
                                </optgroup>
                                <optgroup label="Reversal Bearish">
                                    <option value="shooting_star">Shooting Star</option>
                                    <option value="hanging_man">Hanging Man</option>
                                    <option value="bearish_engulfing">Bearish Engulfing</option>
                                    <option value="evening_star">Evening Star</option>
                                    <option value="dark_cloud_cover">Dark Cloud Cover</option>
                                    <option value="gravestone_doji">Gravestone Doji</option>
                                    <option value="three_black_crows">Three Black Crows</option>
                                </optgroup>
                                <optgroup label="Indecision">
                                    <option value="doji">Doji</option>
                                    <option value="spinning_top">Spinning Top</option>
                                    <option value="bullish_harami">Bullish Harami</option>
                                    <option value="bearish_harami">Bearish Harami</option>
                                    <option value="harami_cross">Harami Cross</option>
                                </optgroup>
                            </select>
                            <button class="btn btn-warning" onclick="submitRevalidationCorrection('${item.id}')">
                                Korrektur speichern
                            </button>
                            <button class="btn btn-secondary" onclick="hideRevalidationCorrectionDialog('${item.id}')">
                                Abbrechen
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }

        // Get pattern direction for highlighting
        function getPatternDirection(patternType) {
            const bullishPatterns = ['hammer', 'inverted_hammer', 'bullish_engulfing', 'morning_star',
                'piercing_line', 'dragonfly_doji', 'three_white_soldiers', 'bullish_harami'];
            const bearishPatterns = ['shooting_star', 'hanging_man', 'bearish_engulfing', 'evening_star',
                'dark_cloud_cover', 'gravestone_doji', 'three_black_crows', 'bearish_harami'];

            if (bullishPatterns.includes(patternType)) return 'bullish';
            if (bearishPatterns.includes(patternType)) return 'bearish';
            return 'neutral';
        }

        // Render feedback history for revalidation item
        function renderRevalidationFeedbackHistory(item) {
            const historyItems = [];

            // Initial feedback
            const ft = formatFeedbackType(item.feedback_type);
            const feedbackTime = item.feedback_timestamp ? formatTimestamp(item.feedback_timestamp) : '';
            const patternTime = item.pattern_timestamp ? formatTimestamp(item.pattern_timestamp) : '';

            // Pattern timestamp row
            historyItems.push(`
                <div class="feedback-history-item" style="border-left-color: #666;">
                    <div class="feedback-history-row">
                        <span class="feedback-history-type" style="color: #888;">üìä Pattern erkannt</span>
                        <span class="feedback-history-time">${patternTime}</span>
                    </div>
                    <div class="feedback-history-detail">${formatPatternType(item.original_pattern)}</div>
                </div>
            `);

            // Feedback entry
            let feedbackDetail = '';
            if (item.feedback_type === 'corrected' && item.corrected_pattern) {
                feedbackDetail = `${formatPatternType(item.original_pattern)} <span class="feedback-history-arrow">‚Üí</span> ${formatPatternType(item.corrected_pattern)}`;
            } else if (item.feedback_type === 'rejected') {
                feedbackDetail = `${formatPatternType(item.original_pattern)} <span class="feedback-history-arrow">‚Üí</span> Kein Pattern`;
            }

            historyItems.push(`
                <div class="feedback-history-item ${item.feedback_type}">
                    <div class="feedback-history-row">
                        <span class="feedback-history-type ${ft.class}">${ft.icon} ${ft.label}</span>
                        <span class="feedback-history-time">${feedbackTime}</span>
                    </div>
                    ${feedbackDetail ? `<div class="feedback-history-detail">${feedbackDetail}</div>` : ''}
                </div>
            `);

            // Previous revalidations from history
            if (item.revalidation_history && item.revalidation_history.length > 0) {
                item.revalidation_history.forEach(prevReval => {
                    const rv = formatRevalidationResult(prevReval.result);
                    const revalTime = prevReval.timestamp ? formatTimestamp(prevReval.timestamp) : '';

                    historyItems.push(`
                        <div class="feedback-history-item revalidated" style="opacity: 0.8;">
                            <div class="feedback-history-row">
                                <span class="feedback-history-type revalidated">üîÑ Re-Validierung: ${rv.label}</span>
                                <span class="feedback-history-time">${revalTime}</span>
                            </div>
                            ${prevReval.notes ? `<div class="feedback-history-detail">${prevReval.notes}</div>` : ''}
                        </div>
                    `);
                });
            }

            // Pending indicator
            historyItems.push(`
                <div class="feedback-history-item" style="border-left-color: #64c8ff; background: rgba(100, 200, 255, 0.1);">
                    <div class="feedback-history-row">
                        <span class="feedback-history-type" style="color: #64c8ff;">‚è≥ Ausstehende Re-Validierung</span>
                        <span class="feedback-history-time">jetzt</span>
                    </div>
                </div>
            `);

            return `
                <div class="feedback-history" style="margin: 0.75rem 0;">
                    <div class="feedback-history-title">
                        <span>üìã</span> Feedback-Verlauf (${historyItems.length} Eintr√§ge)
                    </div>
                    ${historyItems.join('')}
                </div>
            `;
        }

        // Mark an item as revalidated
        // fromScanSuggestion: if true, show enhanced message about training
        async function markRevalidation(feedbackId, result, correctedPattern = null, fromScanSuggestion = false) {
            try {
                const body = {
                    feedback_id: feedbackId,
                    validation_result: result
                };

                // Add correction info if provided
                if (correctedPattern) {
                    body.notes = `Korrigiert zu: ${correctedPattern}`;
                    body.corrected_pattern = correctedPattern;
                }

                const res = await fetch(`${CANDLESTICK_API}/feedback/revalidate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });

                if (res.ok) {
                    let message;
                    if (fromScanSuggestion && correctedPattern) {
                        // Enhanced message for scan suggestions with correction
                        message = `‚úì Korrektur gespeichert: ${formatPatternType(correctedPattern)} (f√ºr n√§chstes Training)`;
                    } else if (fromScanSuggestion && result === 'now_correct') {
                        message = '‚úì Pattern wird nicht mehr erkannt - Modell hat gelernt!';
                    } else {
                        // Standard messages
                        const resultMessages = {
                            'correct': 'Als jetzt korrekt markiert',
                            'now_correct': 'Als nicht mehr erkannt markiert',
                            'still_wrong': correctedPattern
                                ? `Korrigiert zu: ${formatPatternType(correctedPattern)}`
                                : 'Als weiterhin falsch markiert'
                        };
                        message = resultMessages[result] || 'Gespeichert';
                    }
                    showToast(message, 'success');
                    loadRevalidationData();
                } else {
                    throw new Error('Speichern fehlgeschlagen');
                }
            } catch (error) {
                console.error('Failed to mark revalidation:', error);
                showToast('Fehler beim Speichern', 'error');
            }
        }

        // Show correction dialog for revalidation
        function showRevalidationCorrectionDialog(feedbackId, originalPattern, symbol, timeframe) {
            const panel = document.getElementById(`reval-correction-${feedbackId}`);
            if (panel) {
                panel.style.display = 'block';
                // Pre-select original pattern as disabled option
                const select = document.getElementById(`reval-select-${feedbackId}`);
                if (select) {
                    // Mark the original pattern in the dropdown
                    Array.from(select.options).forEach(opt => {
                        if (opt.value === originalPattern) {
                            opt.text = `${opt.text} (aktuell erkannt)`;
                            opt.disabled = true;
                        }
                    });
                }
            }
        }

        // Hide correction dialog
        function hideRevalidationCorrectionDialog(feedbackId) {
            const panel = document.getElementById(`reval-correction-${feedbackId}`);
            if (panel) {
                panel.style.display = 'none';
            }
        }

        // Submit correction from revalidation
        async function submitRevalidationCorrection(feedbackId) {
            const select = document.getElementById(`reval-select-${feedbackId}`);
            if (!select || !select.value) {
                showToast('Bitte ein Pattern ausw√§hlen', 'warning');
                return;
            }

            const correctedPattern = select.value;

            // Mark as still_wrong with the correction info
            await markRevalidation(feedbackId, 'still_wrong', correctedPattern);

            // Hide the dialog
            hideRevalidationCorrectionDialog(feedbackId);
        }

        // Reset all revalidation status (after new training)
        async function resetRevalidation() {
            if (!confirm('Sollen alle Re-Validierungen zur√ºckgesetzt werden?\n\nDies macht alle zuvor √ºberpr√ºften Korrekturen wieder verf√ºgbar f√ºr eine erneute √úberpr√ºfung.')) {
                return;
            }

            try {
                const res = await fetch(`${CANDLESTICK_API}/feedback/reset-revalidation`, {
                    method: 'POST'
                });

                if (res.ok) {
                    const data = await res.json();
                    showToast(`${data.reset_count} Eintr√§ge zur√ºckgesetzt`, 'success');
                    loadRevalidationData();
                } else {
                    throw new Error('Zur√ºcksetzen fehlgeschlagen');
                }
            } catch (error) {
                console.error('Failed to reset revalidation:', error);
                showToast('Fehler beim Zur√ºcksetzen', 'error');
            }
        }

        // Revalidation Training
        let revalTrainingInterval = null;

        async function startRevalTraining() {
            const epochs = parseInt(document.getElementById('trainEpochs').value) || 50;
            const batchSize = parseInt(document.getElementById('trainBatchSize').value) || 32;
            const learningRate = parseFloat(document.getElementById('trainLearningRate').value) || 0.001;

            const btn = document.getElementById('btnStartRevalTraining');
            btn.disabled = true;
            btn.textContent = '‚è≥ Starte...';

            try {
                const res = await fetch(`${CANDLESTICK_TRAIN_API}/train`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        symbols: ['BTCUSD', 'EURUSD', 'GBPUSD', 'XAUUSD', 'GER40', 'XTIUSD'],
                        epochs: epochs,
                        batch_size: batchSize,
                        learning_rate: learningRate
                    })
                });

                if (res.ok) {
                    const data = await res.json();
                    showToast(`Training gestartet: ${data.job?.job_id || 'OK'}`, 'success');

                    // Show progress section
                    document.getElementById('currentTrainingSection').style.display = 'block';
                    document.getElementById('totalEpochs').textContent = epochs;
                    document.getElementById('currentJobStatus').textContent = 'Running';
                    document.getElementById('currentJobStatus').className = 'job-status running';

                    // Reload training history to show new job
                    loadTrainingJobs();

                    // Start polling for progress
                    revalTrainingInterval = setInterval(pollRevalTrainingProgress, 2000);
                } else {
                    const err = await res.json();
                    throw new Error(err.detail || 'Training start failed');
                }
            } catch (error) {
                console.error('Failed to start training:', error);
                showToast('Fehler: ' + error.message, 'error');
                btn.disabled = false;
                btn.textContent = '‚ñ∂ Training starten';
            }
        }

        async function pollRevalTrainingProgress() {
            try {
                const res = await fetch(`${CANDLESTICK_TRAIN_API}/train/status`);
                const data = await res.json();

                // Check if training is currently running (training: true and last_job.status === 'running')
                if (data.training && data.last_job && data.last_job.status === 'running') {
                    const job = data.last_job;
                    const epoch = job.current_epoch || 0;
                    const epochs = job.epochs || 50;
                    // Use progress field if available, otherwise calculate from epochs
                    const percent = job.progress !== undefined ? Math.min(Math.round(job.progress), 100) : Math.round((epoch / epochs) * 100);

                    document.getElementById('currentEpoch').textContent = epoch;
                    document.getElementById('totalEpochs').textContent = epochs;
                    document.getElementById('currentJobProgress').textContent = `${percent}%`;
                    document.getElementById('currentProgressBar').style.width = `${percent}%`;
                    document.getElementById('currentLoss').textContent =
                        job.current_loss ? job.current_loss.toFixed(4) : '-';

                } else if (!data.training && data.last_job) {
                    // Training completed or failed
                    clearInterval(revalTrainingInterval);
                    revalTrainingInterval = null;

                    const job = data.last_job;
                    document.getElementById('currentJobProgress').textContent = '100%';
                    document.getElementById('currentProgressBar').style.width = '100%';
                    document.getElementById('currentEpoch').textContent = job.current_epoch || job.epochs || '-';
                    document.getElementById('totalEpochs').textContent = job.epochs || '-';

                    // Update status badge
                    if (job.status === 'completed') {
                        document.getElementById('currentJobStatus').textContent = 'Completed';
                        document.getElementById('currentJobStatus').className = 'job-status completed';
                        showToast('Training abgeschlossen!', 'success');
                    } else if (job.status === 'failed') {
                        document.getElementById('currentJobStatus').textContent = 'Failed';
                        document.getElementById('currentJobStatus').className = 'job-status failed';
                        showToast('Training fehlgeschlagen: ' + (job.error_message || 'Unbekannter Fehler'), 'error');
                    }

                    // Reload training history immediately after completion
                    loadTrainingJobs();

                    // Hide progress after 3 seconds
                    setTimeout(() => {
                        document.getElementById('currentTrainingSection').style.display = 'none';
                        document.getElementById('btnStartRevalTraining').disabled = false;
                        document.getElementById('btnStartRevalTraining').textContent = '‚ñ∂ Training starten';
                        loadRevalidationStats();
                    }, 3000);

                } else {
                    // No job at all
                    clearInterval(revalTrainingInterval);
                    revalTrainingInterval = null;
                    document.getElementById('currentTrainingSection').style.display = 'none';
                    document.getElementById('btnStartRevalTraining').disabled = false;
                    document.getElementById('btnStartRevalTraining').textContent = '‚ñ∂ Training starten';
                }
            } catch (error) {
                console.error('Failed to poll training status:', error);
            }
        }

        // Trigger a scan for a specific symbol/timeframe to check current detection
        // Shows results as selectable suggestions in the correction panel
        async function scanForRevalidation(feedbackId, symbol, timeframe, originalPattern) {
            try {
                showToast(`Scanne ${symbol} ${timeframe}...`, 'info');

                // Use GET endpoint /scan/{symbol} with timeframe parameter
                const res = await fetch(`${CANDLESTICK_API}/scan/${symbol}?timeframe=${timeframe}&lookback=50&min_confidence=0.5`);

                if (res.ok) {
                    const data = await res.json();

                    // Get patterns for the specific timeframe
                    const tfKey = timeframe.toLowerCase();
                    const tfPatterns = data.result?.[tfKey]?.patterns || [];
                    const patternCount = tfPatterns.length;

                    // Show the correction panel with suggestions
                    const panel = document.getElementById(`reval-correction-${feedbackId}`);
                    const suggestionsContainer = document.getElementById(`reval-scan-suggestions-${feedbackId}`);
                    const divider = document.getElementById(`reval-divider-${feedbackId}`);

                    if (panel && suggestionsContainer) {
                        panel.style.display = 'block';

                        if (patternCount > 0) {
                            // Create clickable buttons for each detected pattern
                            const buttonsHtml = tfPatterns.map(p => {
                                const patternType = p.pattern_type;
                                const patternName = formatPatternType(patternType);
                                const confidence = (p.confidence * 100).toFixed(0);
                                const isOriginal = patternType === originalPattern;

                                // Different styling for the originally detected pattern
                                if (isOriginal) {
                                    return `<button class="scan-suggestion-btn original" disabled title="Urspr√ºnglich erkanntes Pattern">
                                        ${patternName} (${confidence}%) - aktuell erkannt
                                    </button>`;
                                }

                                return `<button class="scan-suggestion-btn" onclick="selectScanSuggestion('${feedbackId}', '${patternType}')" title="Dieses Pattern als korrekt markieren">
                                    ‚úì ${patternName} (${confidence}%)
                                </button>`;
                            }).join('');

                            // Add "Kein Pattern" option
                            const noPatternBtn = `<button class="scan-suggestion-btn no-pattern" onclick="selectScanSuggestion('${feedbackId}', 'no_pattern')" title="Kein Pattern ist korrekt">
                                ‚ùå Kein Pattern erkannt
                            </button>`;

                            suggestionsContainer.querySelector('.scan-suggestions-buttons').innerHTML = buttonsHtml + noPatternBtn;
                            suggestionsContainer.style.display = 'block';
                            divider.style.display = 'flex';

                            showToast(`${patternCount} Pattern(s) erkannt - Vorschl√§ge angezeigt`, 'success');
                        } else {
                            // No patterns detected - show only "Kein Pattern" suggestion
                            suggestionsContainer.querySelector('.scan-suggestions-buttons').innerHTML = `
                                <div class="no-patterns-found">
                                    <span>Keine Patterns erkannt bei diesem Scan.</span>
                                </div>
                                <button class="scan-suggestion-btn no-pattern" onclick="selectScanSuggestion('${feedbackId}', 'no_pattern')" title="Best√§tigen: Kein Pattern">
                                    ‚úì Kein Pattern best√§tigen
                                </button>`;
                            suggestionsContainer.style.display = 'block';
                            divider.style.display = 'flex';

                            showToast(`Keine Patterns erkannt - Pattern m√∂glicherweise korrigiert`, 'info');
                        }
                    }
                } else {
                    const errorData = await res.json().catch(() => ({}));
                    throw new Error(errorData.detail || 'Scan fehlgeschlagen');
                }
            } catch (error) {
                console.error('Failed to scan for revalidation:', error);
                showToast(`Scan fehlgeschlagen: ${error.message}`, 'error');
            }
        }

        // Select a pattern from scan suggestions
        async function selectScanSuggestion(feedbackId, patternType) {
            if (patternType === 'no_pattern') {
                // Mark as correct (pattern no longer detected)
                await markRevalidation(feedbackId, 'now_correct', null, true);
            } else {
                // Mark as still wrong with the new pattern as correction
                // This saves the correction for future training
                await markRevalidation(feedbackId, 'still_wrong', patternType, true);
            }
            hideRevalidationCorrectionDialog(feedbackId);
        }

        // Update revalidation badge on page load
        async function updateRevalidationBadge() {
            try {
                const res = await fetch(`${CANDLESTICK_API}/feedback/revalidation-statistics`);
                const data = await res.json();

                const badge = document.getElementById('revalidationBadge');
                if (data.pending_revalidation > 0) {
                    badge.textContent = data.pending_revalidation;
                    badge.style.display = 'inline';
                } else {
                    badge.style.display = 'none';
                }
            } catch (error) {
                console.warn('Could not update revalidation badge:', error);
            }
        }

        // Load reason categories (for feedback and revalidation display)
        async function loadReasonCategories() {
            try {
                const res = await fetch(`${CANDLESTICK_API}/feedback/reason-categories`);
                const data = await res.json();
                reasonCategoriesCache = data.categories || {};
            } catch (error) {
                console.warn('Could not load reason categories:', error);
            }
        }

        // ==================== Rule Optimizer Functions ====================

        let optimizationPollInterval = null;
        let currentRecommendations = [];

        async function startRuleOptimization() {
            const symbols = document.getElementById('optimizerSymbols').value.split(',').map(s => s.trim()).filter(s => s);
            const timeframes = document.getElementById('optimizerTimeframes').value.split(',').map(s => s.trim()).filter(s => s);
            const samples = parseInt(document.getElementById('optimizerSamples').value) || 10;

            if (symbols.length === 0 || timeframes.length === 0) {
                showToast('Bitte Symbole und Timeframes eingeben', 'error');
                return;
            }

            const btn = document.getElementById('btnStartOptimization');
            btn.disabled = true;
            btn.textContent = '‚è≥ Starte...';

            document.getElementById('optimizationProgress').style.display = 'block';

            try {
                const res = await fetch(`${CANDLESTICK_API}/rule-optimizer/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        symbols: symbols,
                        timeframes: timeframes,
                        samples_per_pattern: samples
                    })
                });

                if (res.ok) {
                    const data = await res.json();
                    showToast(`Optimierung gestartet: ${data.session_id}`, 'success');

                    // Start polling for progress
                    optimizationPollInterval = setInterval(pollOptimizationProgress, 2000);
                } else {
                    const err = await res.json();
                    throw new Error(err.detail || 'Start fehlgeschlagen');
                }
            } catch (error) {
                console.error('Failed to start optimization:', error);
                showToast('Fehler: ' + error.message, 'error');
                btn.disabled = false;
                btn.textContent = '‚ñ∂ Optimierung starten';
                document.getElementById('optimizationProgress').style.display = 'none';
            }
        }

        async function pollOptimizationProgress() {
            try {
                const res = await fetch(`${CANDLESTICK_API}/rule-optimizer/progress`);
                const data = await res.json();

                document.getElementById('optimizationPhase').textContent = `Phase: ${data.phase}`;
                document.getElementById('optimizationPercent').textContent = `${data.progress}%`;
                document.getElementById('optimizationBar').style.width = `${data.progress}%`;
                document.getElementById('optimizationMessage').textContent = data.message || '';
                document.getElementById('optimizationCollected').textContent = data.patterns_collected || 0;
                document.getElementById('optimizationValidated').textContent = data.patterns_validated || 0;

                if (data.phase === 'completed') {
                    clearInterval(optimizationPollInterval);
                    optimizationPollInterval = null;

                    document.getElementById('btnStartOptimization').disabled = false;
                    document.getElementById('btnStartOptimization').textContent = '‚ñ∂ Optimierung starten';

                    // Load recommendations first
                    await loadRecommendations();
                    await loadCurrentParams();

                    // Show summary modal with results
                    await showOptimizationSummary(data);

                } else if (data.phase === 'error') {
                    clearInterval(optimizationPollInterval);
                    optimizationPollInterval = null;

                    document.getElementById('btnStartOptimization').disabled = false;
                    document.getElementById('btnStartOptimization').textContent = '‚ñ∂ Optimierung starten';

                    showToast('Optimierung fehlgeschlagen: ' + data.message, 'error');
                }

            } catch (error) {
                console.error('Failed to poll optimization progress:', error);
            }
        }

        async function loadRecommendations() {
            try {
                const res = await fetch(`${CANDLESTICK_API}/rule-optimizer/recommendations`);
                const data = await res.json();

                currentRecommendations = data.recommendations || [];
                const container = document.getElementById('recommendationsContainer');
                const card = document.getElementById('recommendationsCard');
                const analysisCard = document.getElementById('analysisResultsCard');
                const analysisContainer = document.getElementById('analysisResultsContainer');

                if (currentRecommendations.length === 0) {
                    card.style.display = 'none';
                } else {
                    card.style.display = 'block';

                    let html = '<div style="display: flex; flex-direction: column; gap: 0.5rem;">';
                    currentRecommendations.forEach((rec, idx) => {
                        const changePercent = rec.current_value !== 0
                            ? ((rec.recommended_value - rec.current_value) / rec.current_value * 100).toFixed(1)
                            : 'N/A';
                        const changeColor = parseFloat(changePercent) > 0 ? '#4caf50' : '#f44336';

                        html += `
                            <div style="background: rgba(255,255,255,0.05); padding: 0.8rem; border-radius: 8px; display: flex; align-items: center; gap: 1rem;">
                                <input type="checkbox" id="rec-${idx}" checked style="width: 18px; height: 18px;">
                                <div style="flex: 1;">
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.3rem;">
                                        <span style="font-weight: 600; color: #64c8ff;">${rec.pattern_type}</span>
                                        <span style="color: #888;">‚Üí</span>
                                        <span style="color: #ce93d8;">${rec.parameter}</span>
                                    </div>
                                    <div style="font-size: 0.85rem; color: #888;">
                                        ${rec.current_value} ‚Üí <span style="color: ${changeColor}; font-weight: 600;">${rec.recommended_value}</span>
                                        <span style="margin-left: 0.5rem;">(${changePercent}%)</span>
                                    </div>
                                    <div style="font-size: 0.8rem; color: #666; margin-top: 0.3rem;">
                                        ${rec.reasoning || ''}
                                    </div>
                                </div>
                                <div style="text-align: right;">
                                    <div style="color: #81c784; font-size: 0.85rem;">
                                        ~${(rec.improvement_estimate * 100).toFixed(0)}% weniger False Positives
                                    </div>
                                    <div style="color: #888; font-size: 0.75rem;">
                                        ${rec.sample_count} Samples
                                    </div>
                                </div>
                            </div>
                        `;
                    });
                    html += '</div>';
                    container.innerHTML = html;
                }

                // Show analysis results
                const analyses = data.pattern_analyses || {};
                if (Object.keys(analyses).length > 0) {
                    analysisCard.style.display = 'block';

                    let analysisHtml = '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 1rem;">';
                    for (const [pattern, analysis] of Object.entries(analyses)) {
                        const validityRate = (analysis.validity_rate * 100).toFixed(0);
                        const fpRate = (analysis.false_positive_rate * 100).toFixed(0);
                        const validityColor = validityRate >= 70 ? '#4caf50' : validityRate >= 40 ? '#ff9800' : '#f44336';

                        analysisHtml += `
                            <div style="background: rgba(255,255,255,0.05); padding: 1rem; border-radius: 8px;">
                                <div style="font-weight: 600; color: #64c8ff; margin-bottom: 0.5rem;">${pattern}</div>
                                <div style="display: flex; justify-content: space-between; margin-bottom: 0.3rem;">
                                    <span style="color: #888;">Samples:</span>
                                    <span>${analysis.total_samples}</span>
                                </div>
                                <div style="display: flex; justify-content: space-between; margin-bottom: 0.3rem;">
                                    <span style="color: #888;">Validity Rate:</span>
                                    <span style="color: ${validityColor}; font-weight: 600;">${validityRate}%</span>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span style="color: #888;">False Positive:</span>
                                    <span style="color: #f44336;">${fpRate}%</span>
                                </div>
                            </div>
                        `;
                    }
                    analysisHtml += '</div>';
                    analysisContainer.innerHTML = analysisHtml;
                }

            } catch (error) {
                console.error('Failed to load recommendations:', error);
            }
        }

        async function loadCurrentParams() {
            try {
                const res = await fetch(`${CANDLESTICK_API}/rule-optimizer/current-params`);
                const data = await res.json();

                const container = document.getElementById('currentParamsContainer');
                const params = data.params || {};

                let html = '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1rem;">';
                for (const [pattern, patternParams] of Object.entries(params)) {
                    html += `
                        <div style="background: rgba(255,255,255,0.03); padding: 1rem; border-radius: 8px;">
                            <div style="font-weight: 600; color: #64c8ff; margin-bottom: 0.5rem; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 0.5rem;">
                                ${pattern}
                            </div>
                            <div style="display: flex; flex-direction: column; gap: 0.2rem; font-size: 0.85rem;">
                    `;
                    for (const [param, value] of Object.entries(patternParams)) {
                        html += `
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: #888;">${param}:</span>
                                <span style="color: #ce93d8;">${typeof value === 'number' ? value.toFixed(4) : value}</span>
                            </div>
                        `;
                    }
                    html += '</div></div>';
                }
                html += '</div>';
                container.innerHTML = html;

            } catch (error) {
                console.error('Failed to load current params:', error);
                document.getElementById('currentParamsContainer').innerHTML = '<p style="color: #f44336;">Fehler beim Laden der Parameter</p>';
            }
        }

        async function loadParamHistory() {
            try {
                const res = await fetch(`${CANDLESTICK_API}/rule-optimizer/history?limit=30`);
                const data = await res.json();

                const container = document.getElementById('paramHistoryContainer');
                const history = data.history || [];

                if (history.length === 0) {
                    container.innerHTML = '<p style="color: #888;">Keine √Ñnderungen vorhanden</p>';
                    return;
                }

                let html = '<div style="display: flex; flex-direction: column; gap: 0.5rem;">';
                for (const entry of history) {
                    const timestamp = new Date(entry.timestamp).toLocaleString('de-DE', {
                        day: '2-digit',
                        month: '2-digit',
                        year: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    });
                    html += `
                        <div style="background: rgba(255,255,255,0.03); padding: 0.5rem 0.8rem; border-radius: 4px; font-size: 0.85rem;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span style="color: #64c8ff;">${entry.pattern}.${entry.parameter}</span>
                                <span style="color: #888;">${timestamp}</span>
                            </div>
                            <div style="color: #888; margin-top: 0.2rem;">
                                ${entry.old_value} ‚Üí <span style="color: #81c784;">${entry.new_value}</span>
                                <span style="margin-left: 0.5rem; color: #666;">(${entry.reason})</span>
                            </div>
                        </div>
                    `;
                }
                html += '</div>';
                container.innerHTML = html;

            } catch (error) {
                console.error('Failed to load param history:', error);
                document.getElementById('paramHistoryContainer').innerHTML = '<p style="color: #f44336;">Fehler beim Laden der Historie</p>';
            }
        }

        async function applyAllRecommendations() {
            if (currentRecommendations.length === 0) {
                showToast('Keine Empfehlungen vorhanden', 'info');
                return;
            }

            if (!confirm(`${currentRecommendations.length} Empfehlungen anwenden?`)) {
                return;
            }

            try {
                const res = await fetch(`${CANDLESTICK_API}/rule-optimizer/apply`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ indices: null })  // null = all
                });

                if (res.ok) {
                    const data = await res.json();
                    showToast(`${data.applied_count} Empfehlungen angewendet`, 'success');
                    await loadCurrentParams();
                    await loadParamHistory();
                } else {
                    throw new Error('Anwendung fehlgeschlagen');
                }
            } catch (error) {
                console.error('Failed to apply recommendations:', error);
                showToast('Fehler: ' + error.message, 'error');
            }
        }

        async function applySelectedRecommendations() {
            const selected = [];
            for (let i = 0; i < currentRecommendations.length; i++) {
                const checkbox = document.getElementById(`rec-${i}`);
                if (checkbox && checkbox.checked) {
                    selected.push(i);
                }
            }

            if (selected.length === 0) {
                showToast('Keine Empfehlungen ausgew√§hlt', 'info');
                return;
            }

            try {
                const res = await fetch(`${CANDLESTICK_API}/rule-optimizer/apply`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ indices: selected })
                });

                if (res.ok) {
                    const data = await res.json();
                    showToast(`${data.applied_count} Empfehlungen angewendet`, 'success');
                    await loadCurrentParams();
                    await loadParamHistory();
                } else {
                    throw new Error('Anwendung fehlgeschlagen');
                }
            } catch (error) {
                console.error('Failed to apply selected recommendations:', error);
                showToast('Fehler: ' + error.message, 'error');
            }
        }

        async function resetAllParams() {
            if (!confirm('Alle Parameter auf Standardwerte zur√ºcksetzen?')) {
                return;
            }

            try {
                const res = await fetch(`${CANDLESTICK_API}/rule-optimizer/reset`, {
                    method: 'POST'
                });

                if (res.ok) {
                    showToast('Parameter zur√ºckgesetzt', 'success');
                    await loadCurrentParams();
                    await loadParamHistory();
                } else {
                    throw new Error('Reset fehlgeschlagen');
                }
            } catch (error) {
                console.error('Failed to reset params:', error);
                showToast('Fehler: ' + error.message, 'error');
            }
        }

        // === Backup/Restore Functions ===

        async function loadBackups() {
            const container = document.getElementById('backupListContainer');
            if (!container) return;

            try {
                const response = await fetch(`${CANDLESTICK_API}/rule-optimizer/backups`);
                if (!response.ok) throw new Error('Backups konnten nicht geladen werden');
                const data = await response.json();

                if (!data.backups || data.backups.length === 0) {
                    container.innerHTML = '<p style="color: #888;">Keine Backups vorhanden.</p>';
                    return;
                }

                let html = '<table style="width: 100%; font-size: 0.85rem;">';
                html += '<thead><tr style="text-align: left; color: #888;">';
                html += '<th style="padding: 0.5rem;">Name</th>';
                html += '<th style="padding: 0.5rem;">Erstellt</th>';
                html += '<th style="padding: 0.5rem;">Parameter</th>';
                html += '<th style="padding: 0.5rem;">Gr√∂√üe</th>';
                html += '<th style="padding: 0.5rem;">Aktionen</th>';
                html += '</tr></thead><tbody>';

                for (const backup of data.backups) {
                    const createdAt = backup.created_at ? new Date(backup.created_at).toLocaleString('de-CH') : '-';
                    const sizeKB = backup.size_bytes ? (backup.size_bytes / 1024).toFixed(1) : '-';
                    const isAutoBackup = backup.name.startsWith('auto_');

                    html += '<tr style="border-top: 1px solid rgba(255,255,255,0.1);">';
                    html += `<td style="padding: 0.5rem;">
                        <span style="color: ${isAutoBackup ? '#ffb74d' : '#64c8ff'};">${backup.name}</span>
                        ${isAutoBackup ? '<span style="font-size: 0.7rem; color: #888; margin-left: 0.3rem;">(auto)</span>' : ''}
                    </td>`;
                    html += `<td style="padding: 0.5rem; color: #aaa;">${createdAt}</td>`;
                    html += `<td style="padding: 0.5rem; color: #81c784;">${backup.param_count}</td>`;
                    html += `<td style="padding: 0.5rem; color: #aaa;">${sizeKB} KB</td>`;
                    html += `<td style="padding: 0.5rem;">
                        <button class="btn btn-primary btn-sm" onclick="restoreBackup('${backup.name}')" title="Wiederherstellen">‚ü≤</button>
                        <button class="btn btn-secondary btn-sm" onclick="exportBackup('${backup.name}')" title="Exportieren">üì•</button>
                        <button class="btn btn-danger btn-sm" onclick="deleteBackup('${backup.name}')" title="L√∂schen">‚úï</button>
                    </td>`;
                    html += '</tr>';
                }

                html += '</tbody></table>';
                container.innerHTML = html;

            } catch (error) {
                console.error('Failed to load backups:', error);
                container.innerHTML = `<p style="color: #e57373;">Fehler beim Laden der Backups: ${error.message}</p>`;
            }
        }

        async function createBackup() {
            const name = prompt('Backup-Name (optional, leer = auto-generiert):');
            if (name === null) return; // Abgebrochen

            try {
                const response = await fetch(`${CANDLESTICK_API}/rule-optimizer/backup`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: name || null })
                });

                if (!response.ok) throw new Error('Backup fehlgeschlagen');
                const result = await response.json();

                showToast(`Backup erstellt: ${result.name}`, 'success');
                await loadBackups();

            } catch (error) {
                console.error('Failed to create backup:', error);
                showToast('Fehler: ' + error.message, 'error');
            }
        }

        async function restoreBackup(backupName) {
            if (!confirm(`Backup "${backupName}" wiederherstellen?\n\nEin automatisches Backup des aktuellen Stands wird erstellt.`)) {
                return;
            }

            try {
                const response = await fetch(`${CANDLESTICK_API}/rule-optimizer/restore`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ backup_name: backupName })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Restore fehlgeschlagen');
                }

                const result = await response.json();
                showToast(`Wiederhergestellt: ${result.restored_from}`, 'success');

                // Reload UI
                await loadBackups();
                await loadCurrentParams();
                await loadParamHistory();

            } catch (error) {
                console.error('Failed to restore backup:', error);
                showToast('Fehler: ' + error.message, 'error');
            }
        }

        async function deleteBackup(backupName) {
            if (!confirm(`Backup "${backupName}" wirklich l√∂schen?`)) {
                return;
            }

            try {
                const response = await fetch(`${CANDLESTICK_API}/rule-optimizer/backup/${encodeURIComponent(backupName)}`, {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'L√∂schen fehlgeschlagen');
                }

                showToast(`Backup gel√∂scht: ${backupName}`, 'success');
                await loadBackups();

            } catch (error) {
                console.error('Failed to delete backup:', error);
                showToast('Fehler: ' + error.message, 'error');
            }
        }

        async function exportBackup(backupName) {
            try {
                const response = await fetch(`${CANDLESTICK_API}/rule-optimizer/backup/${encodeURIComponent(backupName)}/export`);
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Export fehlgeschlagen');
                }
                const data = await response.json();

                // Download as JSON file
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `rule_config_${backupName}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showToast(`Backup exportiert: ${backupName}`, 'success');

            } catch (error) {
                console.error('Failed to export backup:', error);
                showToast('Fehler: ' + error.message, 'error');
            }
        }

        async function exportConfig() {
            try {
                const response = await fetch(`${CANDLESTICK_API}/rule-optimizer/export`);
                if (!response.ok) throw new Error('Export fehlgeschlagen');
                const data = await response.json();

                // Download as JSON file
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `rule_config_export_${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showToast('Konfiguration exportiert', 'success');

            } catch (error) {
                console.error('Failed to export config:', error);
                showToast('Fehler: ' + error.message, 'error');
            }
        }

        async function importConfig(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Reset file input for re-selection
            event.target.value = '';

            try {
                const text = await file.text();
                const data = JSON.parse(text);

                if (!data.params) {
                    throw new Error('Ung√ºltiges Format: "params" Feld fehlt');
                }

                if (!confirm(`Konfiguration importieren?\n\nParameter: ${Object.keys(data.params).length} Pattern-Typen\n\nEin automatisches Backup wird erstellt.`)) {
                    return;
                }

                const response = await fetch(`${CANDLESTICK_API}/rule-optimizer/import`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        params: data.params,
                        history: data.history || null
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Import fehlgeschlagen');
                }

                const result = await response.json();
                showToast(`Import erfolgreich: ${result.param_count} Parameter`, 'success');

                // Reload UI
                await loadBackups();
                await loadCurrentParams();
                await loadParamHistory();

            } catch (error) {
                console.error('Failed to import config:', error);
                showToast('Fehler: ' + error.message, 'error');
            }
        }

        async function factoryReset() {
            // Double confirmation for destructive action
            if (!confirm('‚ö†Ô∏è WARNUNG: Factory Reset\n\nDies l√∂scht ALLE Daten unwiderruflich:\n- Regelwerk-Einstellungen\n- Alle Feedbacks\n- Pattern-History\n- Claude-Validierungen\n- Alle Backups\n- Training History\n\nFortfahren?')) {
                return;
            }

            if (!confirm('üóëÔ∏è LETZTE WARNUNG!\n\nAlle Daten werden UNWIDERRUFLICH gel√∂scht.\n\nWirklich fortfahren?')) {
                return;
            }

            try {
                // Reset Candlestick Service
                const response = await fetch(`${CANDLESTICK_API}/rule-optimizer/factory-reset`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Factory Reset fehlgeschlagen');
                }

                const result = await response.json();

                // Also reset Training Service
                let trainResult = null;
                try {
                    const trainResponse = await fetch(`${CANDLESTICK_TRAIN_API}/factory-reset`, {
                        method: 'POST'
                    });
                    if (trainResponse.ok) {
                        trainResult = await trainResponse.json();
                    }
                } catch (trainError) {
                    console.warn('Training Service Factory Reset failed:', trainError);
                }

                // Show result
                let message = 'Factory Reset abgeschlossen.\n\n';
                message += 'üìÅ Dateien gel√∂scht:\n';
                message += result.deleted.map(f => `‚Ä¢ ${f}`).join('\n');

                if (result.memory_cleared && result.memory_cleared.length > 0) {
                    message += '\n\nüßπ In-Memory Daten gel√∂scht:\n';
                    message += result.memory_cleared.map(m => `‚Ä¢ ${m}`).join('\n');
                }

                if (trainResult) {
                    message += '\n\nüìä Training Service:\n';
                    message += trainResult.deleted.map(f => `‚Ä¢ ${f}`).join('\n');
                }

                alert(message);
                showToast('Factory Reset erfolgreich', 'success');

                // Reload all UI components
                await loadBackups();
                await loadCurrentParams();
                await loadParamHistory();
                await loadStatistics();
                await updateRevalidationBadge();

            } catch (error) {
                console.error('Failed to factory reset:', error);
                showToast('Fehler: ' + error.message, 'error');
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            await loadServiceInfo();
            await loadStatistics();
            await updateRevalidationBadge();
            await loadReasonCategories();

            // Status Dashboard laden (da Status standardm√§√üig aktiv ist)
            await loadStatusDashboard();
            await loadPatternTypes();

            // Training-Status beim Start laden (um Button zu deaktivieren wenn Training l√§uft)
            await loadTrainingStatus();
            await loadTrainingJobs();

            // Auto-Scan standardm√§√üig starten (ohne Toast-Nachricht)
            if (isAutoScanRunning) {
                try {
                    await fetch(`${CANDLESTICK_API}/scan/start`, { method: 'POST' });
                } catch (e) {
                    try {
                        await fetch(`${DATA_API}/patterns/history/start-auto-scan`, { method: 'POST' });
                    } catch (e2) {
                        console.warn('Auto-Scan konnte nicht gestartet werden:', e2);
                    }
                }
            }

            // Auto-refresh every 30 seconds
            setInterval(async () => {
                await loadStatistics();
                // Also refresh status dashboard if active
                if (document.getElementById('tab-status').classList.contains('active')) {
                    await loadStatusDashboard();
                }
            }, 30000);
        });

        // === Claude QA Functions ===
        async function loadClaudeStatus() {
            try {
                const response = await fetch(`${CANDLESTICK_API}/claude/status`);
                if (!response.ok) throw new Error(`Status: HTTP ${response.status}`);
                const data = await response.json();

                document.getElementById('claudeEnabled').textContent = data.enabled ? '‚úì Aktiv' : '‚úó Inaktiv';
                document.getElementById('claudeEnabled').style.color = data.enabled ? '#81c784' : '#e57373';
                document.getElementById('claudeModel').textContent = data.model || '-';
                document.getElementById('claudeCached').textContent = data.cache_size || '0';
                document.getElementById('claudeTotal').textContent = data.total_validations || '0';
            } catch (e) {
                console.error('Claude status error:', e);
                document.getElementById('claudeEnabled').textContent = '‚úó Fehler';
                document.getElementById('claudeEnabled').style.color = '#e57373';
            }
        }

        // Fill queue from history for manual validation
        async function fillQueueFromHistory(count) {
            try {
                const response = await fetch(`${CANDLESTICK_API}/auto-optimization/queue/fill-from-history?count=${count}`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    const err = await response.json();
                    throw new Error(err.detail || `HTTP ${response.status}`);
                }

                const result = await response.json();
                alert(`${result.queued} Patterns zur Warteschlange hinzugef√ºgt.`);

                // Now run batch validation
                runBatchValidation(count);
            } catch (e) {
                console.error('Fill queue error:', e);
                alert('Fehler: ' + e.message);
            }
        }

        async function runBatchValidation(maxPatterns) {
            const progressDiv = document.getElementById('batchProgress');
            const resultDiv = document.getElementById('batchResult');
            const progressText = document.getElementById('batchProgressText');
            const progressBar = document.getElementById('batchProgressBar');
            const currentPatternDiv = document.getElementById('batchCurrentPattern');
            const currentPatternName = document.getElementById('batchCurrentPatternName');

            // Disable buttons
            document.getElementById('btnBatch5').disabled = true;
            document.getElementById('btnBatch10').disabled = true;
            document.getElementById('btnBatch20').disabled = true;

            // Reset progress display
            progressDiv.style.display = 'block';
            resultDiv.style.display = 'none';
            progressBar.style.width = '0%';
            document.getElementById('batchStatValidated').textContent = '0';
            document.getElementById('batchStatTotal').textContent = maxPatterns;
            document.getElementById('batchStatAgreed').textContent = '0';
            document.getElementById('batchStatRejected').textContent = '0';
            document.getElementById('batchStatErrors').textContent = '0';
            currentPatternDiv.style.display = 'none';
            progressText.textContent = `Lade ${maxPatterns} Patterns aus der Queue...`;

            try {
                // First, get patterns from the queue
                const queueResponse = await fetch(`${CANDLESTICK_API}/auto-optimization/queue?limit=${maxPatterns}`);
                if (!queueResponse.ok) throw new Error(`Queue laden fehlgeschlagen: HTTP ${queueResponse.status}`);

                const queueData = await queueResponse.json();
                const patterns = queueData.items || [];

                if (patterns.length === 0) {
                    progressDiv.style.display = 'none';
                    resultDiv.style.display = 'block';
                    document.getElementById('batchResultContent').innerHTML = `
                        <div style="color: #888; text-align: center;">
                            <p>Die Warteschlange ist leer.</p>
                            <p style="font-size: 0.85rem; margin-top: 0.5rem;">
                                Neue Patterns werden bei jedem Scan automatisch zur Queue hinzugef√ºgt
                                (Sample-Rate: ${(autoOptConfig?.validation_sample_rate || 0.3) * 100}%).
                            </p>
                            <p style="font-size: 0.85rem; margin-top: 0.5rem;">
                                Alternativ: Verwenden Sie
                                <button class="btn btn-sm btn-secondary" onclick="closeQueueModal(); fillQueueFromHistory(${maxPatterns})" style="padding: 0.2rem 0.5rem; font-size: 0.8rem;">
                                    üì• ${maxPatterns} aus History laden
                                </button>
                            </p>
                        </div>
                    `;
                    // Re-enable buttons
                    document.getElementById('btnBatch5').disabled = false;
                    document.getElementById('btnBatch10').disabled = false;
                    document.getElementById('btnBatch20').disabled = false;
                    return;
                }

                const totalPatterns = patterns.length;
                document.getElementById('batchStatTotal').textContent = totalPatterns;
                progressText.textContent = `Validiere ${totalPatterns} Patterns mit Claude Vision...`;
                currentPatternDiv.style.display = 'block';

                let validated = 0;
                let agreed = 0;
                let rejected = 0;
                let errors = 0;

                // Validate each pattern individually
                for (const pattern of patterns) {
                    const patternType = formatPatternType(pattern.pattern_type || 'unknown');
                    const symbol = pattern.symbol || 'unknown';
                    const timeframe = pattern.timeframe || '';
                    currentPatternName.textContent = `${patternType} (${symbol} ${timeframe})`;

                    try {
                        const response = await fetch(`${CANDLESTICK_API}/claude/validate`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                pattern_id: pattern.id,
                                pattern_type: pattern.pattern_type,
                                symbol: pattern.symbol,
                                timeframe: pattern.timeframe,
                                timestamp: pattern.timestamp
                            })
                        });

                        if (response.ok) {
                            const result = await response.json();
                            if (result.status === 'CONFIRMED' || result.claude_agrees === true) {
                                agreed++;
                            } else if (result.status === 'REJECTED' || result.claude_agrees === false) {
                                rejected++;
                            }
                        } else {
                            errors++;
                        }
                    } catch (e) {
                        console.error(`Error validating pattern ${pattern.id}:`, e);
                        errors++;
                    }

                    validated++;

                    // Update progress display
                    const progress = (validated / totalPatterns) * 100;
                    progressBar.style.width = `${progress}%`;
                    document.getElementById('batchStatValidated').textContent = validated;
                    document.getElementById('batchStatAgreed').textContent = agreed;
                    document.getElementById('batchStatRejected').textContent = rejected;
                    document.getElementById('batchStatErrors').textContent = errors;
                }

                // Show final results
                progressDiv.style.display = 'none';
                resultDiv.style.display = 'block';
                document.getElementById('batchResultContent').innerHTML = `
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; text-align: center;">
                        <div>
                            <div style="font-size: 1.5rem; font-weight: bold;">${validated}</div>
                            <div style="color: #888; font-size: 0.85rem;">Validiert</div>
                        </div>
                        <div>
                            <div style="font-size: 1.5rem; font-weight: bold; color: #81c784;">${agreed}</div>
                            <div style="color: #888; font-size: 0.85rem;">Best√§tigt</div>
                        </div>
                        <div>
                            <div style="font-size: 1.5rem; font-weight: bold; color: #e57373;">${rejected}</div>
                            <div style="color: #888; font-size: 0.85rem;">Abgelehnt</div>
                        </div>
                        <div>
                            <div style="font-size: 1.5rem; font-weight: bold; color: #ffb74d;">${errors}</div>
                            <div style="color: #888; font-size: 0.85rem;">Fehler</div>
                        </div>
                    </div>
                `;
                showToast(`${validated} Patterns validiert: ${agreed} best√§tigt, ${rejected} abgelehnt`, 'success');
                loadClaudeStatus();
                loadAutoOptStatus();

            } catch (e) {
                progressDiv.style.display = 'none';
                resultDiv.style.display = 'block';
                document.getElementById('batchResultContent').innerHTML = `
                    <div style="color: #e57373;">Fehler: ${e.message}</div>
                `;
                showToast('Batch-Validierung fehlgeschlagen: ' + e.message, 'error');
            } finally {
                // Re-enable buttons
                document.getElementById('btnBatch5').disabled = false;
                document.getElementById('btnBatch10').disabled = false;
                document.getElementById('btnBatch20').disabled = false;
            }
        }

        // Toggle collapsible sections
        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            const toggleId = sectionId.replace('Section', 'Toggle');
            const toggle = document.getElementById(toggleId);

            if (section.style.display === 'none') {
                section.style.display = 'block';
                if (toggle) toggle.textContent = '‚ñ≤';
            } else {
                section.style.display = 'none';
                if (toggle) toggle.textContent = '‚ñº';
            }
        }

        async function loadClaudeHistory() {
            const tbody = document.getElementById('claudeHistoryBody');
            const limitSelect = document.getElementById('claudeHistoryLimit');
            const limit = limitSelect ? limitSelect.value : 10;
            tbody.innerHTML = '<tr><td colspan="5" style="text-align: center;"><span class="spinner"></span></td></tr>';

            try {
                const response = await fetch(`${CANDLESTICK_API}/claude/history?limit=${limit}`);
                if (!response.ok) throw new Error(`Historie: HTTP ${response.status}`);
                const data = await response.json();

                if (!data.history || data.history.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; color: #888;">Keine Validierungen</td></tr>';
                    return;
                }

                tbody.innerHTML = data.history.map(v => `
                    <tr>
                        <td style="white-space: nowrap;"><strong>${v.symbol}</strong></td>
                        <td style="color: #888; font-size: 0.75rem;">${v.timeframe}</td>
                        <td style="font-size: 0.85rem;">${formatPatternType(v.pattern_type)}</td>
                        <td style="color: ${v.claude_agrees ? '#81c784' : '#e57373'}; white-space: nowrap;">
                            ${v.claude_agrees ? '‚úì' : '‚úó'} ${(v.claude_confidence * 100).toFixed(0)}%
                        </td>
                        <td style="color: #aaa; font-size: 0.75rem; max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${v.claude_reasoning || ''}">
                            ${v.claude_reasoning ? v.claude_reasoning.substring(0, 60) + (v.claude_reasoning.length > 60 ? '...' : '') : '-'}
                        </td>
                    </tr>
                `).join('');
            } catch (e) {
                console.error('Claude history error:', e);
                tbody.innerHTML = `<tr><td colspan="5" style="text-align: center; color: #e57373;">Fehler: ${e.message}</td></tr>`;
            }
        }

        async function loadProblematicPatterns() {
            const tbody = document.getElementById('problematicPatternsBody');
            tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; padding: 1rem;"><span class="spinner"></span></td></tr>';

            try {
                const response = await fetch(`${CANDLESTICK_API}/claude/problematic-patterns?min_rejections=1&limit=20`);
                if (!response.ok) throw new Error(`Analyse: HTTP ${response.status}`);
                const data = await response.json();

                if (!data.patterns || data.patterns.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: #888; padding: 1rem;">Keine problematischen Patterns</td></tr>';
                    return;
                }

                tbody.innerHTML = data.patterns.map(p => {
                    const rateColor = p.rejection_rate >= 70 ? '#e57373' :
                                      p.rejection_rate >= 50 ? '#ffb74d' :
                                      p.rejection_rate >= 30 ? '#fff176' : '#81c784';
                    const statusIcon = p.rejection_rate >= 70 ? 'üî¥' :
                                       p.rejection_rate >= 50 ? 'üü†' :
                                       p.rejection_rate >= 30 ? 'üü°' : 'üü¢';
                    const barWidth = Math.min(p.rejection_rate, 100);

                    return `
                        <tr>
                            <td style="padding: 0.4rem;">
                                <span style="font-size: 0.9rem;">${statusIcon}</span>
                                <strong>${formatPatternType(p.pattern_type)}</strong>
                            </td>
                            <td style="text-align: center; padding: 0.4rem; color: #81c784;">${p.agreed}</td>
                            <td style="text-align: center; padding: 0.4rem; color: #e57373;">${p.rejected}</td>
                            <td style="padding: 0.4rem;">
                                <div style="display: flex; align-items: center; gap: 0.3rem;">
                                    <div style="flex: 1; background: rgba(255,255,255,0.1); border-radius: 3px; height: 12px; overflow: hidden;">
                                        <div style="width: ${barWidth}%; height: 100%; background: ${rateColor};"></div>
                                    </div>
                                    <span style="color: ${rateColor}; font-size: 0.75rem; min-width: 35px;">${p.rejection_rate.toFixed(0)}%</span>
                                </div>
                            </td>
                        </tr>
                    `;
                }).join('');
            } catch (e) {
                console.error('Problematic patterns error:', e);
                tbody.innerHTML = `<tr><td colspan="4" style="text-align: center; color: #e57373; padding: 1rem;">Fehler: ${e.message}</td></tr>`;
            }
        }

        async function loadRecentPatternsForPreview() {
            const select = document.getElementById('chartPreviewSelect');
            select.innerHTML = '<option value="">Laden...</option>';

            try {
                // Load recent patterns from history
                const response = await fetch(`${CANDLESTICK_API}/history?limit=50`);
                if (!response.ok) throw new Error('Patterns nicht verf√ºgbar');
                const data = await response.json();

                if (!data.patterns || data.patterns.length === 0) {
                    select.innerHTML = '<option value="">Keine Patterns vorhanden</option>';
                    return;
                }

                select.innerHTML = '<option value="">-- Pattern ausw√§hlen --</option>' +
                    data.patterns.map(p => {
                        const time = p.timestamp ? new Date(p.timestamp).toLocaleTimeString('de-CH', {hour: '2-digit', minute: '2-digit'}) : '';
                        return `<option value="${p.id}">${formatPatternType(p.pattern_type)} | ${p.symbol} | ${p.timeframe} | ${time}</option>`;
                    }).join('');

                showToast(`${data.patterns.length} Patterns geladen`, 'success');
            } catch (e) {
                console.error('Load patterns error:', e);
                select.innerHTML = '<option value="">Fehler beim Laden</option>';
                showToast('Fehler: ' + e.message, 'error');
            }
        }

        function selectPatternForPreview() {
            const select = document.getElementById('chartPreviewSelect');
            const input = document.getElementById('chartPreviewPatternId');
            if (select.value) {
                input.value = select.value;
            }
        }

        async function loadChartPreview() {
            const patternId = document.getElementById('chartPreviewPatternId').value.trim();
            if (!patternId) {
                showToast('Bitte ein Pattern ausw√§hlen oder eine Pattern-ID eingeben', 'warning');
                return;
            }

            const container = document.getElementById('chartPreviewContainer');
            const image = document.getElementById('chartPreviewImage');
            const info = document.getElementById('chartPreviewInfo');

            container.style.display = 'block';
            info.textContent = 'Laden...';
            image.src = '';

            try {
                const response = await fetch(`${CANDLESTICK_API}/claude/chart-preview/${patternId}`);
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Vorschau nicht verf√ºgbar');
                }
                const data = await response.json();

                image.src = data.chart_image;
                info.innerHTML = `
                    <strong>${data.symbol}</strong> | ${data.timeframe} |
                    ${formatPatternType(data.pattern_type)} |
                    ${data.candles_shown} Kerzen
                `;
            } catch (e) {
                console.error('Chart preview error:', e);
                container.style.display = 'none';
                showToast('Chart-Vorschau fehlgeschlagen: ' + e.message, 'error');
            }
        }

        // === Feedback Loop Functions ===
        let currentRulesData = null;

        // Combined function to load all feedback loop data
        async function loadFeedbackLoopData() {
            await Promise.all([
                loadRecommendations(),
                loadCurrentRules(),
                loadImpactAnalysis()
            ]);
        }

        async function loadRecommendations() {
            const container = document.getElementById('recommendationsContainer');
            container.innerHTML = '<div style="text-align: center;"><span class="spinner"></span> Analysiere Feedback...</div>';

            try {
                const response = await fetch(`${CANDLESTICK_API}/claude/recommendations`);
                if (!response.ok) throw new Error(`Empfehlungen: HTTP ${response.status}`);
                const data = await response.json();

                if (!data.recommendations || data.recommendations.length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; color: #888; padding: 1rem;">
                            <div style="font-size: 1.5rem; margin-bottom: 0.5rem;">‚úì</div>
                            Keine Empfehlungen verf√ºgbar. F√ºhre mehr Claude-Validierungen durch,
                            um Verbesserungsvorschl√§ge zu erhalten.
                            <br><small>(${data.feedback_summary?.total_rejections || 0} Ablehnungen analysiert)</small>
                        </div>
                    `;
                    return;
                }

                container.innerHTML = `
                    <div style="margin-bottom: 1rem; padding: 0.75rem; background: rgba(100, 200, 255, 0.1); border-radius: 8px;">
                        <strong>${data.count} Empfehlungen</strong> basierend auf
                        <strong>${data.feedback_summary?.total_rejections || 0}</strong> Ablehnungen
                        in <strong>${data.feedback_summary?.patterns_analyzed || 0}</strong> Pattern-Typen
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                        ${data.recommendations.map((r, idx) => `
                            <div class="recommendation-item" style="padding: 1rem; background: rgba(0,0,0,0.2); border-radius: 8px; border-left: 3px solid ${r.priority === 'high' ? '#e57373' : r.priority === 'medium' ? '#ffb74d' : '#81c784'};">
                                <div style="display: flex; justify-content: space-between; align-items: flex-start; flex-wrap: wrap; gap: 0.5rem;">
                                    <div>
                                        <span style="font-weight: bold; color: #64c8ff;">${formatPatternType(r.pattern)}</span>
                                        <span style="color: #888;">.</span>
                                        <span style="color: #aaa;">${r.parameter}</span>
                                        <span class="badge ${r.priority === 'high' ? 'badge-danger' : r.priority === 'medium' ? 'badge-warning' : 'badge-success'}" style="margin-left: 0.5rem; font-size: 0.7rem;">
                                            ${r.priority.toUpperCase()}
                                        </span>
                                    </div>
                                    <button class="btn btn-success" style="padding: 0.3rem 0.75rem; font-size: 0.85rem;"
                                            onclick="applyRecommendation('${r.pattern}', '${r.parameter}', ${r.recommended_value}, '${r.reason}', ${r.feedback_count})"
                                            id="applyBtn${idx}">
                                        Anwenden
                                    </button>
                                </div>
                                <div style="margin-top: 0.5rem; display: flex; gap: 2rem; flex-wrap: wrap;">
                                    <div>
                                        <span style="color: #888;">Aktuell:</span>
                                        <span style="color: #e57373; font-family: monospace;">${r.current_value}</span>
                                    </div>
                                    <div>
                                        <span style="color: #888;">‚Üí Empfohlen:</span>
                                        <span style="color: #81c784; font-family: monospace;">${r.recommended_value}</span>
                                    </div>
                                    <div>
                                        <span style="color: #888;">Grund:</span>
                                        <span style="color: #ffb74d;">${r.reason.replace(/_/g, ' ')}</span>
                                        <span style="color: #666;">(${r.feedback_count}x)</span>
                                    </div>
                                </div>
                                <div style="margin-top: 0.5rem; font-size: 0.85rem; color: #888;">
                                    üí° ${r.impact_estimate}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            } catch (e) {
                console.error('Recommendations error:', e);
                container.innerHTML = `<div style="color: #e57373; text-align: center;">Fehler: ${e.message}</div>`;
            }
        }

        async function applyRecommendation(pattern, parameter, newValue, reason, feedbackCount) {
            if (!confirm(`Parameter anpassen?\n\n${pattern}.${parameter}\n‚Üí ${newValue}\n\nGrund: ${reason}`)) {
                return;
            }

            try {
                const response = await fetch(`${CANDLESTICK_API}/claude/apply-recommendation`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        pattern: pattern,
                        parameter: parameter,
                        new_value: newValue,
                        reason: reason,
                        feedback_count: feedbackCount
                    })
                });

                const data = await response.json();

                if (response.ok && data.status === 'success') {
                    showToast(`Parameter angepasst: ${pattern}.${parameter} = ${newValue}`, 'success');
                    // Reload recommendations
                    loadRecommendations();
                } else {
                    throw new Error(data.detail || 'Anpassung fehlgeschlagen');
                }
            } catch (e) {
                console.error('Apply recommendation error:', e);
                showToast('Fehler: ' + e.message, 'error');
            }
        }

        async function loadCurrentRules() {
            const container = document.getElementById('currentRulesContainer');
            container.style.display = 'block';

            try {
                const response = await fetch(`${CANDLESTICK_API}/claude/current-rules`);
                if (!response.ok) throw new Error(`Regeln: HTTP ${response.status}`);
                const data = await response.json();
                currentRulesData = data;

                // Recent adjustments
                const adjContainer = document.getElementById('recentAdjustments');
                if (data.recent_adjustments && data.recent_adjustments.length > 0) {
                    adjContainer.innerHTML = data.recent_adjustments.map(a => `
                        <div style="padding: 0.5rem; margin-bottom: 0.5rem; background: rgba(0,0,0,0.2); border-radius: 4px; font-size: 0.85rem;">
                            <div>
                                <span style="color: #64c8ff;">${formatPatternType(a.pattern)}</span>.<span style="color: #aaa;">${a.parameter}</span>
                            </div>
                            <div style="color: #888;">
                                ${a.old_value} ‚Üí ${a.new_value}
                                <span style="margin-left: 0.5rem; color: #666;">(${a.reason})</span>
                            </div>
                            <div style="font-size: 0.75rem; color: #666;">${new Date(a.timestamp).toLocaleString('de-CH')}</div>
                        </div>
                    `).join('');
                } else {
                    adjContainer.innerHTML = '<div style="color: #888;">Keine Anpassungen vorhanden</div>';
                }

                // Pattern select
                const select = document.getElementById('rulePatternSelect');
                select.innerHTML = '<option value="">-- Pattern ausw√§hlen --</option>';
                Object.keys(data.params).sort().forEach(pattern => {
                    select.innerHTML += `<option value="${pattern}">${formatPatternType(pattern)}</option>`;
                });

            } catch (e) {
                console.error('Current rules error:', e);
                showToast('Fehler beim Laden der Regeln: ' + e.message, 'error');
            }
        }

        function showPatternParams() {
            const pattern = document.getElementById('rulePatternSelect').value;
            const container = document.getElementById('patternParamsTable');

            if (!pattern || !currentRulesData) {
                container.innerHTML = '';
                return;
            }

            const params = currentRulesData.params[pattern] || {};
            container.innerHTML = `
                <table class="data-table" style="font-size: 0.9rem;">
                    <thead>
                        <tr>
                            <th>Parameter</th>
                            <th>Wert</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${Object.entries(params).map(([key, val]) => `
                            <tr>
                                <td style="color: #aaa;">${key}</td>
                                <td style="font-family: monospace;">${val}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
        }

        async function resetAllRules() {
            if (!confirm('Alle Regel-Parameter auf Standardwerte zur√ºcksetzen?\n\nDies macht alle Anpassungen r√ºckg√§ngig.')) {
                return;
            }

            try {
                const response = await fetch(`${CANDLESTICK_API}/rules/reset`, { method: 'POST' });
                if (!response.ok) throw new Error('Reset fehlgeschlagen');
                showToast('Alle Parameter zur√ºckgesetzt', 'success');
                loadCurrentRules();
            } catch (e) {
                console.error('Reset rules error:', e);
                showToast('Fehler: ' + e.message, 'error');
            }
        }

        async function loadImpactAnalysis() {
            const container = document.getElementById('impactContainer');
            container.style.display = 'block';

            try {
                const response = await fetch(`${CANDLESTICK_API}/claude/impact-analysis`);
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${errorText.substring(0, 100)}`);
                }
                const data = await response.json();

                document.getElementById('impactTotalAdj').textContent = data.total_adjustments || 0;
                document.getElementById('impactImprovements').textContent = data.improvements || 0;
                document.getElementById('impactSuccessRate').textContent = `${data.success_rate || 0}%`;

                const details = document.getElementById('impactDetails');
                if (data.details && data.details.length > 0) {
                    details.innerHTML = `
                        <h4 style="margin-bottom: 0.5rem;">Letzte Anpassungen</h4>
                        ${data.details.map(d => `
                            <div style="padding: 0.5rem; margin-bottom: 0.5rem; background: rgba(0,0,0,0.2); border-radius: 4px;">
                                <div style="display: flex; justify-content: space-between;">
                                    <span style="color: #64c8ff;">${formatPatternType(d.adjustment?.pattern || '')}.${d.adjustment?.parameter || ''}</span>
                                    <span style="color: ${d.impact?.improved ? '#81c784' : '#e57373'};">
                                        ${d.impact?.improved ? '‚Üì' : '‚Üë'} ${Math.abs(d.impact?.improvement_pct || 0)}%
                                    </span>
                                </div>
                                <div style="font-size: 0.85rem; color: #888;">
                                    Vorher: ${d.impact?.before?.rejection_rate || 0}% ‚Üí
                                    Nachher: ${d.impact?.after?.rejection_rate || 0}%
                                </div>
                            </div>
                        `).join('')}
                    `;
                } else {
                    details.innerHTML = '<div style="color: #888;">Noch keine Impact-Daten verf√ºgbar. F√ºhre Validierungen vor und nach Anpassungen durch.</div>';
                }
            } catch (e) {
                console.error('Impact analysis error:', e);
                showToast('Fehler: ' + e.message, 'error');
            }
        }

        // === Auto-Optimization Functions ===
        async function loadAutoOptStatus() {
            try {
                const response = await fetch(`${CANDLESTICK_API}/auto-optimization/status`);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();

                // Update status display
                const running = data.running;
                document.getElementById('autoOptRunning').textContent = running ? '‚úì L√§uft' : '‚úó Gestoppt';
                document.getElementById('autoOptRunning').style.color = running ? '#81c784' : '#888';
                document.getElementById('autoOptPending').textContent = data.pending_validations || '0';
                document.getElementById('autoOptAdjustments').textContent = `${data.auto_adjustments_this_hour || 0} / ${data.config?.max_auto_adjustments_per_hour || 3}`;

                // Update buttons
                document.getElementById('autoOptEnableBtn').style.display = running ? 'none' : 'inline-flex';
                document.getElementById('autoOptDisableBtn').style.display = running ? 'inline-flex' : 'none';

                // Update config checkboxes
                if (data.config) {
                    document.getElementById('autoOptValidateNew').checked = data.config.auto_validate_new_patterns;
                    document.getElementById('autoOptAutoApply').checked = data.config.auto_apply_recommendations;
                    document.getElementById('autoOptSampleRate').value = data.config.validation_sample_rate || 0.3;
                    document.getElementById('autoOptMinConfidence').value = data.config.min_confidence_for_auto_apply || 0.85;
                }
            } catch (e) {
                console.error('Auto-opt status error:', e);
                document.getElementById('autoOptRunning').textContent = '‚úó Fehler';
                document.getElementById('autoOptRunning').style.color = '#e57373';
            }
        }

        async function toggleAutoOptimization(enable) {
            try {
                const endpoint = enable ? 'enable' : 'disable';
                const autoApply = document.getElementById('autoOptAutoApply').checked;

                const response = await fetch(`${CANDLESTICK_API}/auto-optimization/${endpoint}?auto_validate=true&auto_apply=${autoApply}`, {
                    method: 'POST'
                });

                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const data = await response.json();
                showToast(`Auto-Optimierung ${enable ? 'aktiviert' : 'deaktiviert'}`, 'success');
                loadAutoOptStatus();
            } catch (e) {
                console.error('Toggle auto-opt error:', e);
                showToast('Fehler: ' + e.message, 'error');
            }
        }

        async function updateAutoOptConfig() {
            try {
                const config = {
                    auto_validate_new_patterns: document.getElementById('autoOptValidateNew').checked,
                    auto_apply_recommendations: document.getElementById('autoOptAutoApply').checked,
                    validation_sample_rate: parseFloat(document.getElementById('autoOptSampleRate').value),
                    min_confidence_for_auto_apply: parseFloat(document.getElementById('autoOptMinConfidence').value)
                };

                const response = await fetch(`${CANDLESTICK_API}/auto-optimization/config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });

                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                showToast('Konfiguration aktualisiert', 'success');
            } catch (e) {
                console.error('Update config error:', e);
                showToast('Fehler: ' + e.message, 'error');
            }
        }

        async function runOptimizationCycle() {
            const progressDiv = document.getElementById('batchProgress');
            const resultDiv = document.getElementById('batchResult');
            const progressText = document.getElementById('batchProgressText');
            const progressBar = document.getElementById('batchProgressBar');
            const currentPatternDiv = document.getElementById('batchCurrentPattern');
            const currentPatternName = document.getElementById('batchCurrentPatternName');

            // Disable all batch buttons including Zyklus
            document.getElementById('btnBatch5').disabled = true;
            document.getElementById('btnBatch10').disabled = true;
            document.getElementById('btnBatch20').disabled = true;

            // Reset and show progress
            progressDiv.style.display = 'block';
            resultDiv.style.display = 'none';
            progressBar.style.width = '0%';
            document.getElementById('batchStatValidated').textContent = '0';
            document.getElementById('batchStatTotal').textContent = '?';
            document.getElementById('batchStatAgreed').textContent = '0';
            document.getElementById('batchStatRejected').textContent = '0';
            document.getElementById('batchStatErrors').textContent = '0';
            currentPatternDiv.style.display = 'block';
            currentPatternName.textContent = 'Initialisierung...';
            progressText.textContent = 'Optimierungszyklus l√§uft...';

            try {
                // Step 1: Check queue status
                currentPatternName.textContent = 'Pr√ºfe Warteschlange...';
                progressBar.style.width = '10%';

                const queueResponse = await fetch(`${CANDLESTICK_API}/auto-optimization/queue?limit=50`);
                const queueData = await queueResponse.json();
                let patterns = queueData.items || [];

                // Step 2: If queue is empty, fill from history
                if (patterns.length === 0) {
                    currentPatternName.textContent = 'Lade Patterns aus History...';
                    progressBar.style.width = '20%';

                    const fillResponse = await fetch(`${CANDLESTICK_API}/auto-optimization/queue/fill-from-history?count=10`, {
                        method: 'POST'
                    });

                    if (fillResponse.ok) {
                        const fillData = await fillResponse.json();
                        // Re-fetch queue
                        const newQueueResponse = await fetch(`${CANDLESTICK_API}/auto-optimization/queue?limit=50`);
                        const newQueueData = await newQueueResponse.json();
                        patterns = newQueueData.items || [];
                    }
                }

                if (patterns.length === 0) {
                    progressDiv.style.display = 'none';
                    resultDiv.style.display = 'block';
                    document.getElementById('batchResultContent').innerHTML = `
                        <div style="color: #888; text-align: center;">
                            <p>Keine Patterns f√ºr den Zyklus verf√ºgbar.</p>
                            <p style="font-size: 0.85rem;">Alle Patterns wurden bereits validiert.</p>
                        </div>
                    `;
                    document.getElementById('btnBatch5').disabled = false;
                    document.getElementById('btnBatch10').disabled = false;
                    document.getElementById('btnBatch20').disabled = false;
                    return;
                }

                // Step 3: Validate patterns one by one
                const totalPatterns = patterns.length;
                document.getElementById('batchStatTotal').textContent = totalPatterns;
                progressText.textContent = `Validiere ${totalPatterns} Patterns...`;

                let validated = 0;
                let agreed = 0;
                let rejected = 0;
                let errors = 0;

                for (const pattern of patterns) {
                    const patternType = formatPatternType(pattern.pattern_type || 'unknown');
                    const symbol = pattern.symbol || 'unknown';
                    const timeframe = pattern.timeframe || '';
                    currentPatternName.textContent = `${patternType} (${symbol} ${timeframe})`;

                    try {
                        const response = await fetch(`${CANDLESTICK_API}/claude/validate`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                pattern_id: pattern.id,
                                pattern_type: pattern.pattern_type,
                                symbol: pattern.symbol,
                                timeframe: pattern.timeframe,
                                timestamp: pattern.timestamp
                            })
                        });

                        if (response.ok) {
                            const result = await response.json();
                            if (result.status === 'CONFIRMED' || result.claude_agrees === true) {
                                agreed++;
                            } else if (result.status === 'REJECTED' || result.claude_agrees === false) {
                                rejected++;
                            }
                        } else {
                            errors++;
                        }
                    } catch (e) {
                        console.error(`Error validating pattern ${pattern.id}:`, e);
                        errors++;
                    }

                    validated++;

                    // Update progress (30% - 90% for validation)
                    const progress = 30 + (validated / totalPatterns) * 60;
                    progressBar.style.width = `${progress}%`;
                    document.getElementById('batchStatValidated').textContent = validated;
                    document.getElementById('batchStatAgreed').textContent = agreed;
                    document.getElementById('batchStatRejected').textContent = rejected;
                    document.getElementById('batchStatErrors').textContent = errors;
                }

                // Step 4: Analyze and generate recommendations
                currentPatternName.textContent = 'Analysiere Ergebnisse...';
                progressBar.style.width = '95%';

                // Call the original run-cycle endpoint to finalize (it will analyze and create recommendations)
                // Note: The validations are already done, so this just triggers analysis
                progressBar.style.width = '100%';

                // Show final results
                progressDiv.style.display = 'none';
                resultDiv.style.display = 'block';
                document.getElementById('batchResultContent').innerHTML = `
                    <div style="text-align: center; margin-bottom: 1rem;">
                        <div style="font-size: 1.1rem; font-weight: bold; color: #81c784;">‚úì Zyklus abgeschlossen</div>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; text-align: center;">
                        <div>
                            <div style="font-size: 1.5rem; font-weight: bold;">${validated}</div>
                            <div style="color: #888; font-size: 0.85rem;">Validiert</div>
                        </div>
                        <div>
                            <div style="font-size: 1.5rem; font-weight: bold; color: #81c784;">${agreed}</div>
                            <div style="color: #888; font-size: 0.85rem;">Best√§tigt</div>
                        </div>
                        <div>
                            <div style="font-size: 1.5rem; font-weight: bold; color: #e57373;">${rejected}</div>
                            <div style="color: #888; font-size: 0.85rem;">Abgelehnt</div>
                        </div>
                        <div>
                            <div style="font-size: 1.5rem; font-weight: bold; color: #ffb74d;">${errors}</div>
                            <div style="color: #888; font-size: 0.85rem;">Fehler</div>
                        </div>
                    </div>
                `;

                loadAutoOptStatus();
            } catch (e) {
                console.error('Run cycle error:', e);
                progressDiv.style.display = 'none';
                resultDiv.style.display = 'block';
                document.getElementById('batchResultContent').innerHTML = `
                    <div style="color: #e57373; text-align: center;">
                        Fehler beim Optimierungszyklus: ${e.message}
                    </div>
                `;
            } finally {
                // Re-enable buttons
                document.getElementById('btnBatch5').disabled = false;
                document.getElementById('btnBatch10').disabled = false;
                document.getElementById('btnBatch20').disabled = false;
            }
        }

        async function loadAutoOptHistory() {
            try {
                const response = await fetch(`${CANDLESTICK_API}/auto-optimization/history?limit=20`);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const data = await response.json();
                const container = document.getElementById('autoOptHistoryContainer');
                const tbody = document.getElementById('autoOptHistoryBody');

                if (!data || data.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: #888;">Keine automatischen Anpassungen</td></tr>';
                } else {
                    tbody.innerHTML = data.map(item => {
                        const time = new Date(item.timestamp).toLocaleTimeString('de-CH', {hour: '2-digit', minute: '2-digit'});
                        const change = `${item.old_value?.toFixed(3)} ‚Üí ${item.new_value?.toFixed(3)}`;
                        return `
                            <tr>
                                <td style="color: #888;">${time}</td>
                                <td style="color: #ce93d8;">${formatPatternType(item.pattern || '')}</td>
                                <td>${item.parameter || '-'}</td>
                                <td style="color: #81c784;">${change}</td>
                            </tr>
                        `;
                    }).join('');
                }

                container.style.display = 'block';
            } catch (e) {
                console.error('Load history error:', e);
                showToast('Fehler: ' + e.message, 'error');
            }
        }

        async function clearValidationQueue() {
            try {
                const response = await fetch(`${CANDLESTICK_API}/auto-optimization/queue`, {
                    method: 'DELETE'
                });

                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const data = await response.json();
                showToast(`Queue geleert: ${data.removed || 0} Eintr√§ge entfernt`, 'success');
                loadAutoOptStatus();
            } catch (e) {
                console.error('Clear queue error:', e);
                showToast('Fehler: ' + e.message, 'error');
            }
        }

        // ==================== Queue Modal Functions ====================

        async function showValidationQueue() {
            document.getElementById('queueModal').style.display = 'flex';
            await loadQueueContent();
        }

        function closeQueueModal(event) {
            if (!event || event.target === event.currentTarget) {
                document.getElementById('queueModal').style.display = 'none';
            }
        }

        async function loadQueueContent() {
            const container = document.getElementById('queueContent');
            container.innerHTML = '<div style="text-align: center; color: #888;"><span class="spinner"></span> Lade Warteschlange...</div>';

            try {
                const response = await fetch(`${CANDLESTICK_API}/auto-optimization/queue?limit=100`);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const data = await response.json();
                document.getElementById('queueTotalCount').textContent = `(${data.total} Eintr√§ge)`;

                if (data.items.length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 2rem; color: #888;">
                            <div style="font-size: 2rem; margin-bottom: 0.5rem;">‚úì</div>
                            <div>Die Warteschlange ist leer.</div>
                            <div style="font-size: 0.85rem; margin-top: 0.5rem;">
                                Neue Patterns werden automatisch hinzugef√ºgt, wenn neue Patterns beim Scan erkannt werden.
                            </div>
                            <div style="margin-top: 1rem;">
                                <button class="btn btn-secondary btn-sm" onclick="fillQueueFromHistory(10)">
                                    üì• 10 aus History laden
                                </button>
                            </div>
                        </div>
                    `;
                    return;
                }

                // Group by pattern type
                const byType = {};
                for (const item of data.items) {
                    const type = item.pattern_type || 'unknown';
                    if (!byType[type]) byType[type] = [];
                    byType[type].push(item);
                }

                let html = '<table class="data-table" style="width: 100%; font-size: 0.85rem;">';
                html += '<thead><tr><th>Pattern</th><th>Symbol</th><th>Timeframe</th><th>Timestamp</th><th>Konfidenz</th></tr></thead>';
                html += '<tbody>';

                for (const item of data.items) {
                    const timestamp = item.timestamp ? new Date(item.timestamp).toLocaleString('de-CH') : '-';
                    const confidence = item.confidence ? (item.confidence * 100).toFixed(0) + '%' : '-';
                    html += `
                        <tr>
                            <td><span style="color: #64c8ff;">${formatPatternType(item.pattern_type)}</span></td>
                            <td>${item.symbol}</td>
                            <td>${item.timeframe}</td>
                            <td style="font-size: 0.8rem; color: #888;">${timestamp}</td>
                            <td>${confidence}</td>
                        </tr>
                    `;
                }

                html += '</tbody></table>';

                // Summary by type
                const typeCount = Object.keys(byType).length;
                let summaryHtml = '<div style="margin-bottom: 1rem; padding: 0.75rem; background: rgba(100,200,255,0.1); border-radius: 6px;">';
                summaryHtml += `<strong style="color: #64c8ff;">Zusammenfassung:</strong> ${data.total} Patterns in ${typeCount} Typen<br>`;
                summaryHtml += '<div style="margin-top: 0.5rem; display: flex; flex-wrap: wrap; gap: 0.5rem;">';
                for (const [type, items] of Object.entries(byType).sort((a, b) => b[1].length - a[1].length)) {
                    summaryHtml += `<span style="background: rgba(255,255,255,0.1); padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.8rem;">${formatPatternType(type)}: ${items.length}</span>`;
                }
                summaryHtml += '</div></div>';

                container.innerHTML = summaryHtml + html;

            } catch (e) {
                console.error('Load queue error:', e);
                container.innerHTML = `<div style="text-align: center; color: #e57373;">Fehler beim Laden: ${e.message}</div>`;
            }
        }

        async function clearValidationQueueFromModal() {
            if (!confirm('M√∂chten Sie wirklich alle Eintr√§ge aus der Warteschlange entfernen?')) {
                return;
            }

            try {
                const response = await fetch(`${CANDLESTICK_API}/auto-optimization/queue`, {
                    method: 'DELETE'
                });

                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const data = await response.json();
                showToast(`Queue geleert: ${data.removed || 0} Eintr√§ge entfernt`, 'success');
                await loadQueueContent();
                loadAutoOptStatus();
            } catch (e) {
                console.error('Clear queue error:', e);
                showToast('Fehler: ' + e.message, 'error');
            }
        }

    </script>
</body>
</html>
