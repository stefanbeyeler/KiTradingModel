<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Candlestick Pattern Konfiguration - KI Trading Model</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 50%, #16213e 100%);
            color: #e8e8e8;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1.5rem;
        }

        header {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1rem 0;
            margin-bottom: 1.5rem;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        header .container {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #64c8ff;
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .back-link:hover {
            color: #fff;
        }

        .header-title {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .service-badge {
            background: rgba(156, 39, 176, 0.2);
            color: #ce93d8;
            padding: 0.3rem 0.8rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        /* Card */
        .card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 1.5rem;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .card-title {
            font-size: 1.2rem;
            color: #64c8ff;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .card-description {
            color: #888;
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 600;
            color: #64c8ff;
        }

        .stat-value.success { color: #81c784; }
        .stat-value.warning { color: #ffb74d; }
        .stat-value.error { color: #e57373; }

        .stat-label {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-top: 0.25rem;
        }

        /* Buttons */
        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            font-size: 0.85rem;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
        }

        .btn-primary {
            background: rgba(100, 200, 255, 0.2);
            color: #64c8ff;
            border: 1px solid rgba(100, 200, 255, 0.3);
        }

        .btn-primary:hover {
            background: rgba(100, 200, 255, 0.3);
        }

        .btn-success {
            background: rgba(76, 175, 80, 0.2);
            color: #81c784;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .btn-success:hover {
            background: rgba(76, 175, 80, 0.3);
        }

        .btn-danger {
            background: rgba(244, 67, 54, 0.2);
            color: #e57373;
            border: 1px solid rgba(244, 67, 54, 0.3);
        }

        .btn-danger:hover {
            background: rgba(244, 67, 54, 0.3);
        }

        .btn-warning {
            background: rgba(255, 152, 0, 0.2);
            color: #ffb74d;
            border: 1px solid rgba(255, 152, 0, 0.3);
        }

        .btn-warning:hover {
            background: rgba(255, 152, 0, 0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-group {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        /* Pattern Grid */
        .pattern-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1rem;
        }

        .pattern-card {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 10px;
            padding: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.08);
            transition: all 0.2s;
        }

        .pattern-card:hover {
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .pattern-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .pattern-name {
            font-weight: 600;
            color: #fff;
        }

        .pattern-badges {
            display: flex;
            gap: 0.3rem;
        }

        .pattern-description {
            font-size: 0.85rem;
            color: #888;
            line-height: 1.4;
        }

        /* Badges */
        .badge {
            padding: 0.2rem 0.5rem;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 500;
        }

        .badge-bullish { background: rgba(76, 175, 80, 0.2); color: #81c784; }
        .badge-bearish { background: rgba(244, 67, 54, 0.2); color: #e57373; }
        .badge-neutral { background: rgba(255, 152, 0, 0.2); color: #ffb74d; }
        .badge-reversal { background: rgba(156, 39, 176, 0.2); color: #ce93d8; }
        .badge-continuation { background: rgba(33, 150, 243, 0.2); color: #64b5f6; }
        .badge-indecision { background: rgba(158, 158, 158, 0.2); color: #bdbdbd; }

        /* Category Section */
        .category-section {
            margin-bottom: 1.5rem;
        }

        .category-title {
            font-size: 1rem;
            color: #ce93d8;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .category-count {
            background: rgba(156, 39, 176, 0.2);
            padding: 0.15rem 0.5rem;
            border-radius: 10px;
            font-size: 0.75rem;
        }

        /* Timeframe Config */
        .timeframe-list {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .timeframe-badge {
            padding: 0.4rem 0.8rem;
            border-radius: 6px;
            font-size: 0.85rem;
            background: rgba(100, 200, 255, 0.1);
            color: #64c8ff;
            border: 1px solid rgba(100, 200, 255, 0.2);
        }

        /* Scan Status */
        .scan-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            font-size: 0.9rem;
        }

        .scan-status.running {
            color: #81c784;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .scan-status.stopped {
            color: #e57373;
            border: 1px solid rgba(244, 67, 54, 0.3);
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-dot.running {
            background: #81c784;
        }

        .status-dot.stopped {
            background: #e57373;
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Info Grid */
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .info-label {
            color: #888;
        }

        .info-value {
            color: #64c8ff;
            font-weight: 500;
        }

        /* Pattern SVG Example */
        .pattern-example {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            gap: 2px;
            height: 50px;
            margin: 0.75rem 0;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
        }

        .pattern-example .candle {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .pattern-example .wick {
            width: 1px;
            background: #888;
        }

        .pattern-example .body {
            width: 8px;
            min-height: 2px;
            border-radius: 1px;
        }

        .pattern-example .body.bullish {
            background: #81c784;
            border: 1px solid #4caf50;
        }

        .pattern-example .body.bearish {
            background: #e57373;
            border: 1px solid #f44336;
        }

        .pattern-example .body.doji {
            background: #888;
            border: 1px solid #666;
            height: 2px !important;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            color: #fff;
            font-size: 0.9rem;
            z-index: 2000;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s;
        }

        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }

        .toast-success { background: #2e7d32; }
        .toast-error { background: #c62828; }
        .toast-info { background: #1565c0; }

        /* Loading */
        .loading {
            text-align: center;
            padding: 2rem;
            color: #888;
        }

        .spinner {
            display: inline-block;
            width: 30px;
            height: 30px;
            border: 3px solid rgba(100, 200, 255, 0.3);
            border-radius: 50%;
            border-top-color: #64c8ff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 0;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .tab {
            padding: 0.75rem 1.5rem;
            background: transparent;
            border: none;
            color: #888;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.2s;
            border-bottom: 2px solid transparent;
            margin-bottom: -1px;
        }

        .tab:hover {
            color: #64c8ff;
            background: rgba(100, 200, 255, 0.05);
        }

        .tab.active {
            color: #64c8ff;
            border-bottom-color: #64c8ff;
            background: rgba(100, 200, 255, 0.1);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .tab-badge {
            background: #f44336;
            color: white;
            padding: 0.1rem 0.4rem;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 600;
            margin-left: 0.3rem;
            vertical-align: middle;
        }

        /* Revalidation specific styles */
        .revalidation-item {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            border-left: 3px solid #ffb74d;
        }

        .revalidation-item.rejected {
            border-left-color: #e57373;
        }

        .revalidation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .revalidation-meta {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            font-size: 0.85rem;
            color: #888;
            margin-bottom: 0.75rem;
        }

        .revalidation-correction {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            margin-bottom: 0.75rem;
        }

        .revalidation-correction .original {
            color: #e57373;
            text-decoration: line-through;
        }

        .revalidation-correction .arrow {
            color: #888;
        }

        .revalidation-correction .corrected {
            color: #81c784;
            font-weight: 500;
        }

        .revalidation-actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .revalidation-actions .btn {
            padding: 0.4rem 0.8rem;
            font-size: 0.8rem;
        }

        .revalidation-help {
            background: rgba(100, 200, 255, 0.1);
            border-left: 3px solid #64c8ff;
            padding: 0.5rem 0.75rem;
            margin: 0.5rem 0;
            font-size: 0.85rem;
            color: #b0bec5;
            border-radius: 0 4px 4px 0;
        }

        .revalidation-help strong {
            color: #64c8ff;
        }

        .revalidation-chart {
            max-width: 300px;
            margin: 0.75rem 0;
        }

        .revalidation-correction-panel {
            background: rgba(255, 152, 0, 0.1);
            border: 1px solid rgba(255, 152, 0, 0.3);
            border-radius: 6px;
            padding: 0.75rem;
            margin-top: 0.75rem;
        }

        .revalidation-correction-panel .correction-header {
            font-weight: 500;
            color: #ffb74d;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .revalidation-correction-panel .correction-options {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            align-items: center;
        }

        .revalidation-correction-panel .pattern-select {
            flex: 1;
            min-width: 200px;
            padding: 0.4rem 0.6rem;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            font-size: 0.85rem;
        }

        .revalidation-correction-panel .pattern-select option {
            background: #1a1a2e;
            color: #fff;
        }

        .revalidation-correction-panel .pattern-select optgroup {
            background: #1a1a2e;
            color: #888;
            font-style: normal;
        }

        /* Revalidation List View */
        .reval-list-container {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .reval-list-item {
            display: grid;
            grid-template-columns: 100px 1fr 120px 100px 80px 40px;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s ease;
            border-left: 3px solid transparent;
        }

        .reval-list-item:hover {
            background: rgba(100, 200, 255, 0.1);
            border-left-color: #64c8ff;
        }

        .reval-list-item.rejected {
            border-left-color: #e57373;
        }

        .reval-list-item.corrected {
            border-left-color: #ffb74d;
        }

        .reval-list-item .symbol-col {
            font-weight: 600;
            color: #fff;
        }

        .reval-list-item .pattern-col {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .reval-list-item .pattern-col .arrow {
            color: #888;
        }

        .reval-list-item .pattern-col .original {
            color: #e57373;
            text-decoration: line-through;
            opacity: 0.8;
        }

        .reval-list-item .pattern-col .corrected {
            color: #81c784;
        }

        .reval-list-item .timeframe-col {
            text-align: center;
        }

        .reval-list-item .date-col {
            color: #888;
            font-size: 0.85rem;
        }

        .reval-list-item .type-col {
            text-align: center;
        }

        .reval-list-item .arrow-col {
            color: #666;
            text-align: right;
            font-size: 1.2rem;
        }

        .reval-list-header {
            display: grid;
            grid-template-columns: 100px 1fr 120px 100px 80px 40px;
            gap: 0.75rem;
            padding: 0.5rem 1rem;
            font-size: 0.75rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 0.5rem;
        }

        .reval-filters {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
        }

        .reval-filters select,
        .reval-filters input {
            padding: 0.5rem 0.75rem;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: #1a1a2e;
            color: #fff;
            font-size: 0.85rem;
            min-width: 130px;
            cursor: pointer;
        }

        .reval-filters select:hover,
        .reval-filters input:hover {
            border-color: rgba(255, 255, 255, 0.35);
        }

        .reval-filters select:focus,
        .reval-filters input:focus {
            outline: none;
            border-color: #64c8ff;
        }

        .reval-filters select option {
            background: #1a1a2e;
            color: #fff;
            padding: 8px;
        }

        .reval-filters select optgroup {
            background: #1a1a2e;
            color: #888;
            font-style: normal;
            font-weight: 600;
        }

        .reval-filters label {
            font-size: 0.75rem;
            color: #888;
            margin-bottom: 0.25rem;
            display: block;
        }

        .reval-filter-group {
            display: flex;
            flex-direction: column;
        }

        /* Revalidation Detail Modal */
        .reval-detail-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
        }

        .reval-detail-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .reval-detail-modal {
            background: #1a1a2e;
            border-radius: 12px;
            max-width: 900px;
            width: 95%;
            max-height: 90vh;
            overflow-y: auto;
            padding: 1.5rem;
            position: relative;
        }

        .reval-detail-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            color: #888;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            line-height: 1;
        }

        .reval-detail-close:hover {
            color: #fff;
        }

        .reval-detail-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1.5rem;
            padding-right: 2rem;
        }

        .reval-detail-title {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .reval-detail-nav {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .reval-detail-nav button {
            padding: 0.5rem 1rem;
        }

        .reval-detail-nav .nav-counter {
            color: #888;
            font-size: 0.9rem;
            margin: 0 1rem;
        }

        /* Scan suggestions styles */
        .scan-suggestions {
            margin-bottom: 0.75rem;
        }

        .scan-suggestions-header {
            font-size: 0.85rem;
            color: #64c8ff;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .scan-suggestions-header .scan-icon {
            font-size: 1rem;
        }

        .scan-suggestions-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .scan-suggestion-btn {
            padding: 0.5rem 0.8rem;
            border-radius: 6px;
            border: 1px solid rgba(129, 199, 132, 0.5);
            background: rgba(129, 199, 132, 0.15);
            color: #81c784;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s ease;
        }

        .scan-suggestion-btn:hover {
            background: rgba(129, 199, 132, 0.3);
            border-color: #81c784;
        }

        .scan-suggestion-btn.original {
            border-color: rgba(255, 152, 0, 0.5);
            background: rgba(255, 152, 0, 0.15);
            color: #ffb74d;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .scan-suggestion-btn.no-pattern {
            border-color: rgba(239, 83, 80, 0.5);
            background: rgba(239, 83, 80, 0.15);
            color: #ef9a9a;
        }

        .scan-suggestion-btn.no-pattern:hover {
            background: rgba(239, 83, 80, 0.3);
            border-color: #ef5350;
        }

        .correction-divider {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin: 0.75rem 0;
            color: #666;
            font-size: 0.8rem;
        }

        .correction-divider::before,
        .correction-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: rgba(255, 255, 255, 0.1);
        }

        .no-patterns-found {
            padding: 0.5rem;
            color: #888;
            font-size: 0.85rem;
            font-style: italic;
            width: 100%;
        }

        /* Feedback History Styles */
        .feedback-history {
            margin-top: 0.75rem;
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            border-left: 3px solid #64c8ff;
        }

        .feedback-history-title {
            font-size: 0.8rem;
            color: #64c8ff;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .feedback-history-item {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .feedback-history-item:last-child {
            margin-bottom: 0;
        }

        .feedback-history-item.confirmed {
            border-left: 2px solid #81c784;
        }

        .feedback-history-item.corrected {
            border-left: 2px solid #ffb74d;
        }

        .feedback-history-item.rejected {
            border-left: 2px solid #e57373;
        }

        .feedback-history-item.revalidated {
            border-left: 2px solid #64c8ff;
        }

        .feedback-history-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .feedback-history-type {
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .feedback-history-type.confirmed { color: #81c784; }
        .feedback-history-type.corrected { color: #ffb74d; }
        .feedback-history-type.rejected { color: #e57373; }
        .feedback-history-type.revalidated { color: #64c8ff; }

        .feedback-history-time {
            color: #888;
            font-size: 0.75rem;
        }

        .feedback-history-detail {
            color: #aaa;
            font-size: 0.75rem;
        }

        .feedback-history-arrow {
            color: #888;
            margin: 0 0.3rem;
        }

        .feedback-badge-detailed {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
        }

        .feedback-badge-detailed.confirmed {
            background: rgba(129, 199, 132, 0.2);
            color: #81c784;
        }

        .feedback-badge-detailed.corrected {
            background: rgba(255, 183, 77, 0.2);
            color: #ffb74d;
        }

        .feedback-badge-detailed.rejected {
            background: rgba(229, 115, 115, 0.2);
            color: #e57373;
        }

        .feedback-badge-detailed:hover {
            filter: brightness(1.2);
        }

        .feedback-count-badge {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem;
            margin-left: 0.2rem;
        }

        /* Training specific styles */
        .training-status-card {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .training-progress {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin: 0.5rem 0;
        }

        .training-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #64c8ff, #81c784);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .training-form {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .form-group label {
            font-size: 0.85rem;
            color: #888;
        }

        .form-group input,
        .form-group select {
            padding: 0.5rem 0.75rem;
            background: #1a1a2e;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #fff;
            font-size: 0.9rem;
        }

        .form-group select {
            cursor: pointer;
        }

        .form-group select option {
            background: #1a1a2e;
            color: #fff;
            padding: 0.5rem;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #64c8ff;
        }

        /* Filter Dropdowns */
        .filter-controls select {
            background: #1a1a2e;
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .filter-controls select option {
            background: #1a1a2e;
            color: #fff;
            padding: 8px;
        }

        .job-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .job-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            margin-bottom: 0.5rem;
            border-left: 3px solid #888;
        }

        .job-item.completed { border-left-color: #81c784; }
        .job-item.running { border-left-color: #64c8ff; }
        .job-item.failed { border-left-color: #e57373; }
        .job-item.pending { border-left-color: #ffb74d; }

        .job-info {
            flex: 1;
        }

        .job-title {
            font-weight: 500;
            color: #fff;
            margin-bottom: 0.25rem;
        }

        .job-meta {
            font-size: 0.8rem;
            color: #888;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .job-status {
            padding: 0.2rem 0.6rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .job-status.completed { background: rgba(76, 175, 80, 0.2); color: #81c784; }
        .job-status.running { background: rgba(100, 200, 255, 0.2); color: #64c8ff; }
        .job-status.failed { background: rgba(244, 67, 54, 0.2); color: #e57373; }
        .job-status.pending { background: rgba(255, 152, 0, 0.2); color: #ffb74d; }

        .symbol-chips {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 0.5rem;
        }

        .symbol-chip {
            padding: 0.25rem 0.5rem;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 4px;
            font-size: 0.8rem;
            color: #64c8ff;
            cursor: pointer;
            transition: all 0.2s;
        }

        .symbol-chip:hover {
            background: rgba(100, 200, 255, 0.2);
        }

        .symbol-chip.selected {
            background: rgba(100, 200, 255, 0.3);
            border-color: #64c8ff;
        }

        /* Pattern History Styles */
        .history-filters {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        .history-filters select,
        .history-filters input {
            padding: 0.5rem 0.75rem;
            background: #252540;
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 6px;
            color: #fff;
            font-size: 0.85rem;
            min-width: 120px;
        }

        .history-filters select option {
            background: #252540;
            color: #fff;
            padding: 8px 12px;
        }

        .history-filters select:focus {
            outline: none;
            border-color: #64c8ff;
        }

        /* Timeline Styles */
        .timeline-container {
            position: relative;
            max-height: 600px;
            overflow-y: auto;
            padding: 1rem 0;
        }

        .timeline {
            position: relative;
            padding-left: 140px;
        }

        .timeline::before {
            content: '';
            position: absolute;
            left: 130px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: linear-gradient(180deg, rgba(100, 200, 255, 0.3), rgba(100, 200, 255, 0.1));
        }

        .timeline-date-group {
            margin-bottom: 1.5rem;
        }

        .timeline-date-header {
            position: relative;
            font-size: 0.85rem;
            font-weight: 600;
            color: #64c8ff;
            margin-bottom: 0.75rem;
            padding-left: 25px;
        }

        .timeline-date-header::before {
            content: '';
            position: absolute;
            left: -10px;
            top: 50%;
            transform: translateY(-50%);
            width: 10px;
            height: 10px;
            background: #64c8ff;
            border-radius: 50%;
            border: 2px solid #1a1a2e;
        }

        .timeline-item {
            position: relative;
            display: flex;
            align-items: center;
            padding: 0.6rem 1rem;
            margin-bottom: 0.5rem;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            cursor: pointer;
            transition: all 0.2s;
        }

        .timeline-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateX(4px);
        }

        .timeline-item::before {
            content: '';
            position: absolute;
            left: -25px;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 8px;
            border-radius: 50%;
            border: 2px solid;
        }

        .timeline-item.bullish::before {
            background: #81c784;
            border-color: #4caf50;
        }

        .timeline-item.bearish::before {
            background: #e57373;
            border-color: #f44336;
        }

        .timeline-item.neutral::before {
            background: #ffb74d;
            border-color: #ff9800;
        }

        .timeline-time {
            position: absolute;
            left: -130px;
            width: 95px;
            text-align: right;
            font-size: 0.8rem;
            font-weight: 500;
            color: #888;
        }

        .timeline-item.bullish .timeline-time { color: #81c784; }
        .timeline-item.bearish .timeline-time { color: #e57373; }
        .timeline-item.neutral .timeline-time { color: #ffb74d; }

        .timeline-content {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .timeline-pattern-name {
            font-weight: 600;
            color: #fff;
            font-size: 0.95rem;
            min-width: 150px;
        }

        .timeline-symbol {
            font-size: 0.85rem;
            color: #64c8ff;
            font-weight: 500;
            min-width: 70px;
        }

        .timeline-direction {
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .timeline-direction.bullish {
            background: rgba(76, 175, 80, 0.2);
            color: #81c784;
        }

        .timeline-direction.bearish {
            background: rgba(244, 67, 54, 0.2);
            color: #e57373;
        }

        .timeline-direction.neutral {
            background: rgba(255, 152, 0, 0.2);
            color: #ffb74d;
        }

        .timeline-confidence {
            font-size: 0.8rem;
            color: #888;
            margin-left: auto;
        }

        .timeline-arrow {
            color: #666;
            font-size: 1.2rem;
            margin-left: 0.5rem;
        }

        /* Feedback Status Badges */
        .timeline-feedback {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            font-size: 0.75rem;
            padding: 0.15rem 0.5rem;
            border-radius: 4px;
            margin-left: 0.5rem;
        }

        .timeline-feedback.confirmed {
            background: rgba(76, 175, 80, 0.2);
            color: #81c784;
        }

        .timeline-feedback.corrected {
            background: rgba(255, 152, 0, 0.2);
            color: #ffb74d;
        }

        .timeline-feedback.rejected {
            background: rgba(244, 67, 54, 0.2);
            color: #e57373;
        }

        .timeline-feedback-icon {
            font-size: 0.9rem;
        }

        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(4px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem;
            line-height: 1;
            transition: color 0.2s;
        }

        .modal-close:hover {
            color: #fff;
        }

        .modal-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.2);
            border-radius: 0 0 12px 12px;
        }

        .modal-nav-btn {
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            color: #64c8ff;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            transition: all 0.2s;
            min-width: 120px;
        }

        .modal-nav-btn:hover:not(:disabled) {
            background: rgba(100, 200, 255, 0.25);
            border-color: #64c8ff;
            transform: translateY(-1px);
        }

        .modal-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .modal-nav-prev {
            justify-content: flex-start;
        }

        .modal-nav-next {
            justify-content: flex-end;
        }

        .modal-nav-counter {
            font-size: 1rem;
            color: #64c8ff;
            font-weight: 600;
            min-width: 100px;
            text-align: center;
        }

        .modal-body {
            padding: 1.5rem;
        }

        .modal-chart-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 0.75rem;
            margin-bottom: 1.5rem;
        }

        .modal-chart {
            width: 100%;
            height: 220px;
            display: block;
        }

        .modal-info-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .modal-info-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 0.75rem;
            border-radius: 6px;
        }

        .modal-info-label {
            font-size: 0.75rem;
            color: #888;
            margin-bottom: 0.25rem;
        }

        .modal-info-value {
            font-size: 1rem;
            color: #fff;
            font-weight: 500;
        }

        .modal-description {
            background: rgba(0, 0, 0, 0.2);
            padding: 1rem;
            border-radius: 6px;
            color: #aaa;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .modal-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
        }

        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            margin-top: 1.5rem;
            padding: 1rem;
        }

        .pagination button {
            padding: 0.5rem 1rem;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 6px;
            color: #64c8ff;
            cursor: pointer;
            transition: all 0.2s;
        }

        .pagination button:hover:not(:disabled) {
            background: rgba(100, 200, 255, 0.2);
        }

        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pagination-info {
            color: #888;
            font-size: 0.85rem;
        }

        .empty-state {
            text-align: center;
            padding: 3rem;
            color: #666;
        }

        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .pattern-grid {
                grid-template-columns: 1fr;
            }

            header .container {
                flex-direction: column;
                gap: 1rem;
            }

            .tabs {
                flex-wrap: wrap;
            }

            .tab {
                flex: 1;
                text-align: center;
            }
        }

        /* Additional Revalidation List Styles */
        .reval-list-symbol {
            font-weight: 600;
            color: #fff;
        }

        .reval-list-pattern {
            color: #ccc;
            font-size: 0.9rem;
        }

        .reval-list-timeframe {
            text-align: center;
        }

        .reval-list-date {
            color: #888;
            font-size: 0.85rem;
        }

        .reval-list-type {
            text-align: center;
        }

        .reval-list-action {
            text-align: right;
        }

        .reval-type-badge {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .reval-type-badge.rejected {
            background: rgba(229, 115, 115, 0.2);
            color: #e57373;
        }

        .reval-type-badge.corrected {
            background: rgba(255, 183, 77, 0.2);
            color: #ffb74d;
        }

        .btn-sm {
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
        }

        /* Detail Modal Active State */
        .reval-detail-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .reval-detail-badge {
            display: inline-block;
            padding: 0.25rem 0.6rem;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 500;
            margin-left: 0.75rem;
        }

        .reval-detail-badge.rejected {
            background: rgba(229, 115, 115, 0.2);
            color: #e57373;
        }

        .reval-detail-badge.corrected {
            background: rgba(255, 183, 77, 0.2);
            color: #ffb74d;
        }

        .reval-detail-content {
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
        }

        .reval-detail-info {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 1rem;
        }

        .reval-detail-info-row {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
        }

        .reval-detail-info-item {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .reval-detail-info-item label {
            font-size: 0.75rem;
            color: #888;
            text-transform: uppercase;
        }

        .reval-detail-info-item span {
            font-size: 0.95rem;
            color: #fff;
        }

        .reval-detail-chart {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 1rem;
        }

        .reval-detail-history {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 1rem;
        }

        .reval-detail-history h4 {
            margin: 0 0 0.75rem 0;
            font-size: 0.9rem;
            color: #64c8ff;
        }

        .reval-history-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 4px;
            margin-bottom: 0.5rem;
        }

        .reval-history-entry:last-child {
            margin-bottom: 0;
        }

        .reval-history-date {
            font-size: 0.8rem;
            color: #888;
            min-width: 150px;
        }

        .reval-history-action {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
        }

        .reval-history-badge {
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .reval-history-badge.initial {
            background: rgba(100, 200, 255, 0.2);
            color: #64c8ff;
        }

        .reval-history-badge.success {
            background: rgba(129, 199, 132, 0.2);
            color: #81c784;
        }

        .reval-history-badge.failed {
            background: rgba(229, 115, 115, 0.2);
            color: #e57373;
        }

        .reval-history-text {
            font-size: 0.85rem;
            color: #aaa;
        }

        .reval-detail-current {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 1rem;
        }

        .reval-detail-current h4 {
            margin: 0 0 0.75rem 0;
            font-size: 0.9rem;
            color: #64c8ff;
        }

        .detection-results {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .detection-result {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .detection-result.detection-success {
            background: rgba(129, 199, 132, 0.15);
            color: #81c784;
        }

        .detection-result.detection-wrong {
            background: rgba(229, 115, 115, 0.15);
            color: #e57373;
        }

        .detection-result.detection-other {
            background: rgba(255, 255, 255, 0.05);
            color: #aaa;
        }

        .detection-result.detection-none {
            background: rgba(255, 255, 255, 0.05);
            color: #888;
        }

        .detection-icon {
            font-size: 1.1rem;
        }

        .reval-detail-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
            padding-top: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        @media (max-width: 768px) {
            .reval-list-item {
                grid-template-columns: 1fr 1fr;
                gap: 0.5rem;
            }

            .reval-list-header {
                display: none;
            }

            .reval-detail-info-row {
                grid-template-columns: 1fr 1fr;
            }

            .reval-detail-actions {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <a href="/index.html" class="back-link">‚Üê Dashboard</a>
            <h1 class="header-title">Candlestick Pattern Konfiguration</h1>
            <span class="service-badge" id="serviceStatus">Laden...</span>
        </div>
    </header>

    <main class="container">
        <!-- Tabs -->
        <div class="tabs">
            <button class="tab active" onclick="switchTab('patterns')">Pattern Detection</button>
            <button class="tab" onclick="switchTab('history')">Pattern History</button>
            <button class="tab" onclick="switchTab('training')">Model Training</button>
            <button class="tab" onclick="switchTab('revalidation')">Re-Validierung <span id="revalidationBadge" class="tab-badge" style="display: none;">0</span></button>
        </div>

        <!-- Tab: Pattern Detection -->
        <div id="tab-patterns" class="tab-content active">

        <!-- Combined Stats & Service Info -->
        <div class="card" style="margin-bottom: 1.5rem;">
            <div class="stats-grid" style="margin-bottom: 1rem;">
                <div class="stat-card">
                    <div class="stat-value" id="patternCount">-</div>
                    <div class="stat-label">Pattern-Typen</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="timeframeCount">-</div>
                    <div class="stat-label">Timeframes</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="historyCount">-</div>
                    <div class="stat-label">History</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value success" id="bullishCount">-</div>
                    <div class="stat-label">Bullish</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value error" id="bearishCount">-</div>
                    <div class="stat-label">Bearish</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value warning" id="neutralCount">-</div>
                    <div class="stat-label">Neutral</div>
                </div>
            </div>
            <div style="display: flex; flex-wrap: wrap; gap: 1.5rem; align-items: center; padding-top: 0.75rem; border-top: 1px solid rgba(255,255,255,0.1);">
                <div style="display: flex; gap: 1rem; flex-wrap: wrap; font-size: 0.85rem; color: #888;">
                    <span>Version: <span style="color: #64c8ff;" id="infoVersion">-</span></span>
                    <span>Port: <span style="color: #64c8ff;">3006</span></span>
                    <span>Gestartet: <span style="color: #64c8ff;" id="infoStarted">-</span></span>
                </div>
                <div class="timeframe-list" id="timeframeList" style="flex: 1; min-width: 200px;">
                    <span class="loading" style="padding: 0;"><span class="spinner" style="width: 16px; height: 16px;"></span></span>
                </div>
            </div>
        </div>

        <!-- Scan Controls -->
        <div class="card">
            <div class="card-header">
                <h2 class="card-title">Auto-Scan Steuerung</h2>
                <div class="scan-status running" id="scanStatus">
                    <span class="status-dot running"></span>
                    <span id="scanStatusText">L√§uft</span>
                </div>
            </div>
            <p class="card-description">
                Der Auto-Scan √ºberwacht alle Favoriten-Symbole und erkennt Candlestick-Patterns automatisch.
            </p>
            <div class="btn-group">
                <button class="btn btn-success" id="btnStartScan" onclick="startAutoScan()" style="display: none;">
                    Auto-Scan starten
                </button>
                <button class="btn btn-danger" id="btnStopScan" onclick="stopAutoScan()">
                    Auto-Scan stoppen
                </button>
                <button class="btn btn-primary" onclick="triggerManualScan()">
                    Jetzt scannen
                </button>
                <button class="btn btn-warning" onclick="clearHistory()">
                    History l√∂schen
                </button>
            </div>
        </div>

        <!-- Pattern Categories -->
        <div class="card">
            <div class="card-header">
                <h2 class="card-title">Verf√ºgbare Pattern-Typen</h2>
            </div>

            <!-- Reversal Patterns -->
            <div class="category-section" id="reversalSection">
                <div class="category-title">
                    <span class="badge badge-reversal">Reversal</span>
                    Umkehrmuster
                    <span class="category-count" id="reversalCount">0</span>
                </div>
                <div class="pattern-grid" id="reversalPatterns">
                    <div class="loading"><span class="spinner"></span></div>
                </div>
            </div>

            <!-- Continuation Patterns -->
            <div class="category-section" id="continuationSection">
                <div class="category-title">
                    <span class="badge badge-continuation">Continuation</span>
                    Fortsetzungsmuster
                    <span class="category-count" id="continuationCount">0</span>
                </div>
                <div class="pattern-grid" id="continuationPatterns">
                    <div class="loading"><span class="spinner"></span></div>
                </div>
            </div>

            <!-- Indecision Patterns -->
            <div class="category-section" id="indecisionSection">
                <div class="category-title">
                    <span class="badge badge-indecision">Indecision</span>
                    Unentschlossenheit
                    <span class="category-count" id="indecisionCount">0</span>
                </div>
                <div class="pattern-grid" id="indecisionPatterns">
                    <div class="loading"><span class="spinner"></span></div>
                </div>
            </div>
        </div>

        </div><!-- End Tab: Pattern Detection -->

        <!-- Tab: Pattern History -->
        <div id="tab-history" class="tab-content">

            <!-- Filter Controls -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Erkannte Patterns</h2>
                    <div class="btn-group">
                        <button class="btn btn-secondary" onclick="resetHistoryFilters()" title="Filter zur√ºcksetzen">‚úï Filter</button>
                        <button class="btn btn-primary" onclick="loadPatternHistory()">Aktualisieren</button>
                    </div>
                </div>

                <div class="history-filters">
                    <div class="form-group" style="margin: 0;">
                        <label style="font-size: 0.75rem;">Symbol</label>
                        <select id="historyFilterSymbol" onchange="loadPatternHistory()">
                            <option value="">Alle Symbole</option>
                        </select>
                    </div>
                    <div class="form-group" style="margin: 0;">
                        <label style="font-size: 0.75rem;">Pattern</label>
                        <select id="historyFilterPattern" onchange="loadPatternHistory()">
                            <option value="">Alle Patterns</option>
                        </select>
                    </div>
                    <div class="form-group" style="margin: 0;">
                        <label style="font-size: 0.75rem;">Richtung</label>
                        <select id="historyFilterDirection" onchange="loadPatternHistory()">
                            <option value="">Alle</option>
                            <option value="bullish">Bullish</option>
                            <option value="bearish">Bearish</option>
                            <option value="neutral">Neutral</option>
                        </select>
                    </div>
                    <div class="form-group" style="margin: 0;">
                        <label style="font-size: 0.75rem;">Timeframe</label>
                        <select id="historyFilterTimeframe" onchange="loadPatternHistory()">
                            <option value="">Alle</option>
                            <option value="M5">M5</option>
                            <option value="M15">M15</option>
                            <option value="H1">H1</option>
                            <option value="H4">H4</option>
                            <option value="D1">D1</option>
                        </select>
                    </div>
                    <div class="form-group" style="margin: 0;">
                        <label style="font-size: 0.75rem;">Min. Konfidenz</label>
                        <select id="historyFilterConfidence" onchange="loadPatternHistory()">
                            <option value="0">Alle</option>
                            <option value="0.5">50%+</option>
                            <option value="0.6">60%+</option>
                            <option value="0.7">70%+</option>
                            <option value="0.8">80%+</option>
                        </select>
                    </div>
                </div>

                <!-- Timeline Container -->
                <div class="timeline-container" id="patternTimelineContainer">
                    <div class="timeline" id="patternTimeline">
                        <div class="loading"><span class="spinner"></span> Lade Patterns...</div>
                    </div>
                </div>

                <!-- Pagination -->
                <div class="pagination" id="historyPagination" style="display: none;">
                    <button onclick="loadPatternHistory(currentHistoryPage - 1)" id="historyPrevBtn">Zur√ºck</button>
                    <span class="pagination-info" id="historyPageInfo">Seite 1 von 1</span>
                    <button onclick="loadPatternHistory(currentHistoryPage + 1)" id="historyNextBtn">Weiter</button>
                </div>
            </div>

        </div><!-- End Tab: Pattern History -->

        <!-- Pattern Detail Modal -->
        <div class="modal-overlay" id="patternModal" onclick="closePatternModal(event)">
            <div class="modal" onclick="event.stopPropagation()" style="max-width: 800px;">
                <div class="modal-header">
                    <div class="modal-title">
                        <span id="modalPatternName">-</span>
                        <span class="timeline-direction" id="modalDirection">-</span>
                    </div>
                    <button class="modal-close" onclick="closePatternModal()">&times;</button>
                </div>
                <div class="modal-body">
                    <!-- Chart Comparison -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                        <div>
                            <div style="font-size: 0.8rem; color: #888; margin-bottom: 0.5rem; text-align: center;">Erkanntes Pattern</div>
                            <div class="modal-chart-container" style="margin-bottom: 0;">
                                <canvas class="modal-chart" id="modalChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <div style="font-size: 0.8rem; color: #888; margin-bottom: 0.5rem; text-align: center;">Referenz-Beispiel</div>
                            <div class="modal-chart-container" style="margin-bottom: 0;">
                                <canvas class="modal-chart" id="modalReferenceChart"></canvas>
                            </div>
                        </div>
                    </div>

                    <div class="modal-info-grid">
                        <div class="modal-info-item">
                            <div class="modal-info-label">Symbol</div>
                            <div class="modal-info-value" id="modalSymbol">-</div>
                        </div>
                        <div class="modal-info-item">
                            <div class="modal-info-label">Timeframe</div>
                            <div class="modal-info-value" id="modalTimeframe">-</div>
                        </div>
                        <div class="modal-info-item">
                            <div class="modal-info-label">Zeitpunkt</div>
                            <div class="modal-info-value" id="modalTimestamp">-</div>
                        </div>
                        <div class="modal-info-item">
                            <div class="modal-info-label">Konfidenz</div>
                            <div class="modal-info-value" id="modalConfidence">-</div>
                        </div>
                    </div>

                    <div class="modal-description" id="modalDescription">
                        Pattern-Beschreibung wird geladen...
                    </div>

                    <!-- Correction Section -->
                    <div style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.1);">
                        <div style="font-size: 0.9rem; font-weight: 600; color: #64c8ff; margin-bottom: 0.75rem;">
                            Pattern-Korrektur (f√ºr Training)
                        </div>
                        <div style="display: flex; gap: 0.75rem; align-items: center; flex-wrap: wrap;">
                            <button class="btn btn-success" onclick="confirmPattern()" style="padding: 0.5rem 1rem;">
                                ‚úì Korrekt erkannt
                            </button>
                            <select id="correctionPatternSelect" style="padding: 0.5rem; background: #252540; color: #fff; border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; min-width: 180px;">
                                <option value="">-- Korrektes Pattern w√§hlen --</option>
                            </select>
                            <button class="btn btn-warning" onclick="submitCorrection()" style="padding: 0.5rem 1rem;">
                                Korrektur speichern
                            </button>
                            <button class="btn btn-secondary" onclick="markAsNoPattern()" style="padding: 0.5rem 1rem;">
                                ‚úó Kein Pattern
                            </button>
                        </div>
                        <div id="correctionFeedback" style="margin-top: 0.5rem; font-size: 0.85rem; display: none;"></div>
                    </div>
                </div>
                <!-- Navigation Footer -->
                <div class="modal-footer">
                    <button class="modal-nav-btn modal-nav-prev" id="modalPrevBtn" onclick="navigatePattern(-1)" title="Vorheriges Pattern (‚Üê)">
                        ‚Äπ Zur√ºck
                    </button>
                    <span class="modal-nav-counter" id="modalNavCounter">1 / 100</span>
                    <button class="modal-nav-btn modal-nav-next" id="modalNextBtn" onclick="navigatePattern(1)" title="N√§chstes Pattern (‚Üí)">
                        Weiter ‚Ä∫
                    </button>
                </div>
            </div>
        </div>

        <!-- Tab: Model Training -->
        <div id="tab-training" class="tab-content">

            <!-- Training Service Status -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Training Service Status</h2>
                    <span class="service-badge" id="trainServiceStatus">Laden...</span>
                </div>
                <div class="stats-grid" style="margin-bottom: 1rem;">
                    <div class="stat-card">
                        <div class="stat-value" id="trainVersion">-</div>
                        <div class="stat-label">Version</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="trainPyTorch">-</div>
                        <div class="stat-label">PyTorch</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="trainPatternTypes">-</div>
                        <div class="stat-label">Pattern-Typen</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="trainJobsTotal">-</div>
                        <div class="stat-label">Jobs Total</div>
                    </div>
                </div>
                <div style="display: flex; flex-wrap: wrap; gap: 1.5rem; align-items: center; padding-top: 0.75rem; border-top: 1px solid rgba(255,255,255,0.1);">
                    <div style="display: flex; gap: 1rem; flex-wrap: wrap; font-size: 0.85rem; color: #888;">
                        <span>Port: <span style="color: #64c8ff;">3016</span></span>
                        <span>Gestartet: <span style="color: #64c8ff;" id="trainStarted">-</span></span>
                    </div>
                    <div class="timeframe-list" id="trainTimeframes" style="flex: 1; min-width: 200px;">
                        <span class="loading" style="padding: 0;"><span class="spinner" style="width: 16px; height: 16px;"></span></span>
                    </div>
                </div>
            </div>

            <!-- User Feedback Statistics -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üìù Benutzer-Feedback f√ºr Training</h2>
                    <button class="btn btn-secondary" onclick="loadFeedbackStats()" style="font-size: 0.8rem;">Aktualisieren</button>
                </div>
                <div class="stats-grid" style="margin-bottom: 1rem;">
                    <div class="stat-card">
                        <div class="stat-value" id="feedbackTotal">-</div>
                        <div class="stat-label">Gesamt</div>
                    </div>
                    <div class="stat-card" style="border-color: rgba(76, 175, 80, 0.3);">
                        <div class="stat-value" id="feedbackConfirmed" style="color: #81c784;">-</div>
                        <div class="stat-label">‚úì Best√§tigt</div>
                    </div>
                    <div class="stat-card" style="border-color: rgba(255, 152, 0, 0.3);">
                        <div class="stat-value" id="feedbackCorrected" style="color: #ffb74d;">-</div>
                        <div class="stat-label">‚úé Korrigiert</div>
                    </div>
                    <div class="stat-card" style="border-color: rgba(244, 67, 54, 0.3);">
                        <div class="stat-value" id="feedbackRejected" style="color: #e57373;">-</div>
                        <div class="stat-label">‚úó Abgelehnt</div>
                    </div>
                </div>
                <div style="font-size: 0.85rem; color: #888; padding-top: 0.75rem; border-top: 1px solid rgba(255,255,255,0.1);">
                    <span id="feedbackInfo">Das gesammelte Feedback wird beim n√§chsten Training automatisch ber√ºcksichtigt.</span>
                </div>
            </div>

            <!-- Current Training Status -->
            <div class="card" id="currentTrainingCard" style="display: none;">
                <div class="card-header">
                    <h2 class="card-title">Aktuelles Training</h2>
                    <span class="job-status running" id="currentJobStatus">Running</span>
                </div>
                <div class="training-status-card">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                        <span id="currentJobId">-</span>
                        <span id="currentJobProgress">0%</span>
                    </div>
                    <div class="training-progress">
                        <div class="training-progress-bar" id="currentProgressBar" style="width: 0%;"></div>
                    </div>
                    <div class="job-meta" style="margin-top: 0.5rem;">
                        <span>Epoch: <span id="currentEpoch">0</span>/<span id="totalEpochs">0</span></span>
                        <span>Loss: <span id="currentLoss">-</span></span>
                        <span>Best Loss: <span id="bestLoss">-</span></span>
                    </div>
                </div>
                <div class="btn-group">
                    <button class="btn btn-danger" onclick="cancelCurrentTraining()">Training abbrechen</button>
                </div>
            </div>

            <!-- Start New Training -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Neues Training starten</h2>
                </div>
                <p class="card-description">
                    Trainiere das Candlestick-Pattern-Erkennungsmodell. Das Training verwendet eine optimierte Auswahl
                    von Symbolen und Timeframes f√ºr maximale Generalisierung.
                </p>

                <!-- Training Configuration Info -->
                <div style="background: rgba(0,0,0,0.2); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                        <div>
                            <div style="font-size: 0.8rem; color: #888; margin-bottom: 0.5rem;">Symbole (breit diversifiziert)</div>
                            <div class="symbol-chips" style="margin: 0;">
                                <span class="symbol-chip selected" style="cursor: default;">BTCUSD</span>
                                <span class="symbol-chip selected" style="cursor: default;">EURUSD</span>
                                <span class="symbol-chip selected" style="cursor: default;">GBPUSD</span>
                                <span class="symbol-chip selected" style="cursor: default;">XAUUSD</span>
                                <span class="symbol-chip selected" style="cursor: default;">GER40</span>
                                <span class="symbol-chip selected" style="cursor: default;">XTIUSD</span>
                            </div>
                            <div style="font-size: 0.75rem; color: #666; margin-top: 0.5rem;">
                                Crypto, Forex, Rohstoff, Index, Energie
                            </div>
                        </div>
                        <div>
                            <div style="font-size: 0.8rem; color: #888; margin-bottom: 0.5rem;">Timeframes (multi-timeframe)</div>
                            <div class="timeframe-list" style="margin: 0;">
                                <span class="timeframe-badge">H1</span>
                                <span class="timeframe-badge">H4</span>
                                <span class="timeframe-badge">D1</span>
                            </div>
                            <div style="font-size: 0.75rem; color: #666; margin-top: 0.5rem;">
                                Patterns sind timeframe-unabhangig
                            </div>
                        </div>
                    </div>
                </div>

                <div class="training-form">
                    <div class="form-group">
                        <label for="trainEpochs">Epochen</label>
                        <input type="number" id="trainEpochs" value="50" min="1" max="500">
                    </div>
                    <div class="form-group">
                        <label for="trainBatchSize">Batch Size</label>
                        <input type="number" id="trainBatchSize" value="32" min="8" max="128">
                    </div>
                    <div class="form-group">
                        <label for="trainLearningRate">Learning Rate</label>
                        <input type="number" id="trainLearningRate" value="0.001" min="0.0001" max="0.1" step="0.0001">
                    </div>
                </div>

                <div class="btn-group">
                    <button class="btn btn-success" id="btnStartTraining" onclick="startTraining()">Training starten</button>
                    <button class="btn btn-primary" onclick="loadTrainingStatus()">Status aktualisieren</button>
                </div>
            </div>

            <!-- Training History -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Training History</h2>
                    <span class="badge badge-neutral" id="jobHistoryCount">0 Jobs</span>
                </div>
                <div class="job-list" id="jobList">
                    <div class="loading"><span class="spinner"></span></div>
                </div>
            </div>

        </div><!-- End Tab: Model Training -->

        <!-- Tab: Re-Validierung -->
        <div id="tab-revalidation" class="tab-content">

            <!-- Revalidation Statistics -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üîÑ Re-Validierung nach Training</h2>
                    <div class="btn-group">
                        <button class="btn btn-warning" onclick="resetRevalidation()" title="Nach neuem Training zur√ºcksetzen">Zur√ºcksetzen</button>
                        <button class="btn btn-primary" onclick="loadRevalidationData()">Aktualisieren</button>
                    </div>
                </div>
                <p class="card-description">
                    √úberpr√ºfe zuvor korrigierte oder abgelehnte Patterns nach dem Neu-Training des Modells,
                    um zu verifizieren, dass die Verbesserungen wirksam sind.
                </p>
                <div class="stats-grid" style="margin-top: 1rem;">
                    <div class="stat-card">
                        <div class="stat-value" id="revalTotal">-</div>
                        <div class="stat-label">Korrekturen gesamt</div>
                    </div>
                    <div class="stat-card" style="border-color: rgba(255, 152, 0, 0.3);">
                        <div class="stat-value" id="revalPending" style="color: #ffb74d;">-</div>
                        <div class="stat-label">‚è≥ Ausstehend</div>
                    </div>
                    <div class="stat-card" style="border-color: rgba(76, 175, 80, 0.3);">
                        <div class="stat-value" id="revalDone" style="color: #81c784;">-</div>
                        <div class="stat-label">‚úì √úberpr√ºft</div>
                    </div>
                    <div class="stat-card" style="border-color: rgba(100, 200, 255, 0.3);">
                        <div class="stat-value" id="revalImprovement" style="color: #64c8ff;">-</div>
                        <div class="stat-label">üìà Verbesserungsrate</div>
                    </div>
                </div>
            </div>

            <!-- Pending Revalidation List -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Ausstehende √úberpr√ºfungen</h2>
                    <span class="badge badge-neutral" id="pendingCount">0</span>
                </div>

                <!-- Filter Section -->
                <div class="reval-filters">
                    <div class="reval-filter-group">
                        <label>Symbol</label>
                        <select id="revalFilterSymbol" onchange="filterRevalidationList()">
                            <option value="">Alle Symbole</option>
                        </select>
                    </div>
                    <div class="reval-filter-group">
                        <label>Timeframe</label>
                        <select id="revalFilterTimeframe" onchange="filterRevalidationList()">
                            <option value="">Alle</option>
                            <option value="M5">M5</option>
                            <option value="M15">M15</option>
                            <option value="H1">H1</option>
                            <option value="H4">H4</option>
                            <option value="D1">D1</option>
                        </select>
                    </div>
                    <div class="reval-filter-group">
                        <label>Typ</label>
                        <select id="revalFilterType" onchange="filterRevalidationList()">
                            <option value="">Alle</option>
                            <option value="rejected">Abgelehnt</option>
                            <option value="corrected">Korrigiert</option>
                        </select>
                    </div>
                    <div class="reval-filter-group">
                        <label>Pattern</label>
                        <select id="revalFilterPattern" onchange="filterRevalidationList()">
                            <option value="">Alle Patterns</option>
                        </select>
                    </div>
                    <div class="reval-filter-group" style="align-self: flex-end;">
                        <button class="btn btn-secondary" onclick="resetRevalidationFilters()" style="padding: 0.4rem 0.8rem;">
                            Filter zur√ºcksetzen
                        </button>
                    </div>
                </div>

                <!-- List Header -->
                <div class="reval-list-header">
                    <div>Symbol</div>
                    <div>Pattern-Korrektur</div>
                    <div>Timeframe</div>
                    <div>Datum</div>
                    <div>Typ</div>
                    <div></div>
                </div>

                <!-- List Content -->
                <div id="revalidationList" class="reval-list-container">
                    <div class="loading"><span class="spinner"></span></div>
                </div>

                <div id="noRevalidations" style="display: none; text-align: center; padding: 2rem; color: #888;">
                    <div style="font-size: 2rem; margin-bottom: 0.5rem;">‚úì</div>
                    <div>Alle Korrekturen wurden √ºberpr√ºft!</div>
                    <div style="font-size: 0.85rem; margin-top: 0.5rem;">
                        Nach einem neuen Training kannst du die √úberpr√ºfung mit "Zur√ºcksetzen" erneut starten.
                    </div>
                </div>
            </div>

            <!-- Revalidation Results Summary -->
            <div class="card" id="revalResultsCard" style="display: none;">
                <div class="card-header">
                    <h2 class="card-title">√úberpr√ºfungsergebnisse</h2>
                </div>
                <div class="stats-grid">
                    <div class="stat-card" style="border-color: rgba(76, 175, 80, 0.3);">
                        <div class="stat-value" id="revalCorrect" style="color: #81c784;">0</div>
                        <div class="stat-label">‚úì Jetzt korrekt</div>
                    </div>
                    <div class="stat-card" style="border-color: rgba(76, 175, 80, 0.3);">
                        <div class="stat-value" id="revalNowCorrect" style="color: #81c784;">0</div>
                        <div class="stat-label">‚úì Nicht mehr erkannt</div>
                    </div>
                    <div class="stat-card" style="border-color: rgba(244, 67, 54, 0.3);">
                        <div class="stat-value" id="revalStillWrong" style="color: #e57373;">0</div>
                        <div class="stat-label">‚úó Weiterhin falsch</div>
                    </div>
                </div>
            </div>

        </div><!-- End Tab: Re-Validierung -->

    </main>

    <!-- Revalidation Detail Modal -->
    <div id="revalDetailOverlay" class="reval-detail-overlay" onclick="closeRevalDetail(event)">
        <div class="reval-detail-modal" onclick="event.stopPropagation()">
            <div class="reval-detail-header">
                <div class="reval-detail-title">
                    <span id="revalDetailSymbol">BTCUSD</span>
                    <span class="reval-detail-badge" id="revalDetailType">Korrigiert</span>
                </div>
                <div class="reval-detail-nav">
                    <button class="btn btn-secondary" onclick="navigateRevalDetail(-1)" id="revalPrevBtn" title="Vorheriger">
                        ‚Üê Zur√ºck
                    </button>
                    <span id="revalDetailPosition">1 / 10</span>
                    <button class="btn btn-secondary" onclick="navigateRevalDetail(1)" id="revalNextBtn" title="N√§chster">
                        Weiter ‚Üí
                    </button>
                </div>
                <button class="close-btn" onclick="closeRevalDetail()">&times;</button>
            </div>

            <div class="reval-detail-content">
                <!-- Pattern Info -->
                <div class="reval-detail-info">
                    <div class="reval-detail-info-row">
                        <div class="reval-detail-info-item">
                            <label>Original erkannt</label>
                            <span id="revalDetailOriginal">-</span>
                        </div>
                        <div class="reval-detail-info-item">
                            <label>Korrigiert zu</label>
                            <span id="revalDetailCorrected">-</span>
                        </div>
                        <div class="reval-detail-info-item">
                            <label>Timeframe</label>
                            <span id="revalDetailTimeframe">-</span>
                        </div>
                        <div class="reval-detail-info-item">
                            <label>Zeitpunkt</label>
                            <span id="revalDetailTimestamp">-</span>
                        </div>
                    </div>
                </div>

                <!-- Chart -->
                <div class="reval-detail-chart">
                    <div id="revalDetailChartContainer" style="width: 100%; height: 300px;"></div>
                </div>

                <!-- Feedback History -->
                <div class="reval-detail-history">
                    <h4>Feedback-Verlauf</h4>
                    <div id="revalDetailFeedbackHistory"></div>
                </div>

                <!-- Current Detection -->
                <div class="reval-detail-current">
                    <h4>Aktuelle Erkennung nach Training</h4>
                    <div id="revalDetailCurrentDetection">
                        <div class="loading"><span class="spinner"></span> Pr√ºfe aktuelle Erkennung...</div>
                    </div>
                </div>

                <!-- Actions -->
                <div class="reval-detail-actions">
                    <button class="btn btn-success" onclick="submitRevalFeedback('correct')" id="revalBtnCorrect">
                        ‚úì Jetzt korrekt erkannt
                    </button>
                    <button class="btn btn-primary" onclick="submitRevalFeedback('not_detected')" id="revalBtnNotDetected">
                        ‚úì Nicht mehr erkannt (gut)
                    </button>
                    <button class="btn btn-danger" onclick="submitRevalFeedback('still_wrong')" id="revalBtnStillWrong">
                        ‚úó Weiterhin falsch
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <script>
        const CANDLESTICK_API = '/candlestick/api/v1';
        const CANDLESTICK_TRAIN_API = '/candlestick-train/api/v1';
        const DATA_API = '/data/api/v1';
        let isAutoScanRunning = true;  // Default: aktiv
        let trainingRefreshInterval = null;
        let currentHistoryPage = 1;
        const HISTORY_PAGE_SIZE = 12;
        let ohlcCache = {};  // Cache for OHLC data

        // Revalidation list state
        let allRevalidationItems = [];  // All pending revalidation items
        let filteredRevalidationItems = [];  // Filtered items based on user selection
        let currentRevalDetailIndex = 0;  // Current index in detail view
        let revalDetailChart = null;  // Current chart instance in detail modal

        // Pattern visual examples - each candle: [upperWick, body, lowerWick, type]
        // type: 'bullish', 'bearish', 'doji'
        const patternExamples = {
            // Reversal Bullish
            'hammer': [[2, 8, 22, 'bullish']],
            'inverted_hammer': [[22, 8, 2, 'bullish']],
            'bullish_engulfing': [[4, 18, 4, 'bearish'], [2, 28, 2, 'bullish']],
            'morning_star': [[4, 20, 4, 'bearish'], [8, 4, 8, 'doji'], [2, 22, 4, 'bullish']],
            'three_white_soldiers': [[2, 14, 2, 'bullish'], [2, 16, 2, 'bullish'], [2, 18, 2, 'bullish']],
            'piercing_line': [[4, 22, 4, 'bearish'], [4, 18, 2, 'bullish']],
            'tweezer_bottom': [[4, 16, 12, 'bearish'], [4, 16, 12, 'bullish']],
            'dragonfly_doji': [[0, 2, 28, 'doji']],

            // Reversal Bearish
            'hanging_man': [[2, 8, 22, 'bearish']],
            'shooting_star': [[22, 8, 2, 'bearish']],
            'bearish_engulfing': [[2, 18, 4, 'bullish'], [2, 28, 2, 'bearish']],
            'evening_star': [[2, 20, 4, 'bullish'], [8, 4, 8, 'doji'], [4, 22, 2, 'bearish']],
            'three_black_crows': [[2, 14, 2, 'bearish'], [2, 16, 2, 'bearish'], [2, 18, 2, 'bearish']],
            'dark_cloud_cover': [[2, 22, 4, 'bullish'], [2, 18, 4, 'bearish']],
            'tweezer_top': [[12, 16, 4, 'bullish'], [12, 16, 4, 'bearish']],
            'gravestone_doji': [[28, 2, 0, 'doji']],

            // Continuation
            'rising_three_methods': [[2, 24, 2, 'bullish'], [4, 8, 2, 'bearish'], [4, 6, 2, 'bearish'], [4, 8, 2, 'bearish'], [2, 26, 2, 'bullish']],
            'falling_three_methods': [[2, 24, 2, 'bearish'], [2, 8, 4, 'bullish'], [2, 6, 4, 'bullish'], [2, 8, 4, 'bullish'], [2, 26, 2, 'bearish']],
            'upside_tasuki_gap': [[2, 16, 2, 'bullish'], [2, 16, 2, 'bullish'], [4, 12, 2, 'bearish']],
            'downside_tasuki_gap': [[2, 16, 2, 'bearish'], [2, 16, 2, 'bearish'], [2, 12, 4, 'bullish']],
            'mat_hold': [[2, 20, 2, 'bullish'], [4, 8, 2, 'bearish'], [4, 6, 4, 'bearish'], [2, 8, 4, 'bullish'], [2, 22, 2, 'bullish']],
            'bullish_marubozu': [[0, 30, 0, 'bullish']],
            'bearish_marubozu': [[0, 30, 0, 'bearish']],

            // Indecision
            'doji': [[12, 2, 12, 'doji']],
            'long_legged_doji': [[16, 2, 16, 'doji']],
            'spinning_top': [[10, 8, 10, 'bullish']],
            'high_wave': [[14, 6, 14, 'doji']],
            // Bullish Harami: Abw√§rtstrend (rot) + gro√üe rote Kerze + kleine gr√ºne Kerze
            'harami': [[3, 14, 3, 'bearish'], [2, 16, 2, 'bearish'], [2, 24, 2, 'bearish'], [6, 10, 6, 'bullish']],
            'bullish_harami': [[3, 14, 3, 'bearish'], [2, 16, 2, 'bearish'], [2, 24, 2, 'bearish'], [6, 10, 6, 'bullish']],
            // Bearish Harami: Aufw√§rtstrend (gr√ºn) + gro√üe gr√ºne Kerze + kleine rote Kerze
            'bearish_harami': [[3, 14, 3, 'bullish'], [2, 16, 2, 'bullish'], [2, 24, 2, 'bullish'], [6, 10, 6, 'bearish']],
            // Harami Cross: Abw√§rtstrend (rot) + gro√üe Kerze + Doji
            'harami_cross': [[3, 14, 3, 'bearish'], [2, 16, 2, 'bearish'], [2, 24, 2, 'bearish'], [8, 2, 8, 'doji']],
            'bullish_harami_cross': [[3, 14, 3, 'bearish'], [2, 16, 2, 'bearish'], [2, 24, 2, 'bearish'], [8, 2, 8, 'doji']],
            'bearish_harami_cross': [[3, 14, 3, 'bullish'], [2, 16, 2, 'bullish'], [2, 24, 2, 'bullish'], [8, 2, 8, 'doji']],
            'inside_bar': [[4, 20, 4, 'bearish'], [6, 12, 6, 'bullish']],

            // Default fallback
            'default': [[8, 12, 8, 'doji']]
        };

        // Generate HTML for pattern candles
        function renderPatternExample(patternType) {
            const candles = patternExamples[patternType] || patternExamples['default'];

            return `<div class="pattern-example">${candles.map(([upperWick, body, lowerWick, type]) => `
                <div class="candle">
                    <div class="wick" style="height: ${upperWick}px;"></div>
                    <div class="body ${type}" style="height: ${body}px;"></div>
                    <div class="wick" style="height: ${lowerWick}px;"></div>
                </div>
            `).join('')}</div>`;
        }

        // Show toast notification
        function showToast(message, type = 'info') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast toast-${type} show`;
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        // Format timestamp
        function formatTimestamp(isoString) {
            if (!isoString) return '-';
            const date = new Date(isoString);
            return date.toLocaleString('de-CH', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        // Format pattern type for display
        function formatPatternType(type) {
            return type
                .split('_')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }

        // Load service info
        async function loadServiceInfo() {
            try {
                const res = await fetch(`${CANDLESTICK_API}/info`);
                const data = await res.json();

                document.getElementById('serviceStatus').textContent = 'Online';
                document.getElementById('serviceStatus').style.background = 'rgba(76, 175, 80, 0.2)';
                document.getElementById('serviceStatus').style.color = '#81c784';

                document.getElementById('infoVersion').textContent = data.version || '-';
                document.getElementById('infoStarted').textContent = formatTimestamp(data.started_at);
                document.getElementById('patternCount').textContent = data.pattern_types || 0;
                document.getElementById('timeframeCount').textContent = data.supported_timeframes?.length || 0;

                // Render timeframes
                const tfList = document.getElementById('timeframeList');
                if (data.supported_timeframes && data.supported_timeframes.length > 0) {
                    tfList.innerHTML = data.supported_timeframes.map(tf =>
                        `<span class="timeframe-badge">${tf}</span>`
                    ).join('');
                } else {
                    tfList.innerHTML = '<span style="color: #888;">Keine Timeframes verf√ºgbar</span>';
                }

            } catch (error) {
                console.error('Failed to load service info:', error);
                document.getElementById('serviceStatus').textContent = 'Offline';
                document.getElementById('serviceStatus').style.background = 'rgba(244, 67, 54, 0.2)';
                document.getElementById('serviceStatus').style.color = '#e57373';
            }
        }

        // Load pattern list
        async function loadPatterns() {
            try {
                const res = await fetch(`${CANDLESTICK_API}/patterns`);
                const data = await res.json();

                const categories = data.categories || {};

                // Render reversal patterns
                renderPatternCategory('reversalPatterns', 'reversalCount', categories.reversal || []);

                // Render continuation patterns
                renderPatternCategory('continuationPatterns', 'continuationCount', categories.continuation || []);

                // Render indecision patterns
                renderPatternCategory('indecisionPatterns', 'indecisionCount', categories.indecision || []);

            } catch (error) {
                console.error('Failed to load patterns:', error);
            }
        }

        // Render pattern category
        function renderPatternCategory(containerId, countId, patterns) {
            const container = document.getElementById(containerId);
            document.getElementById(countId).textContent = patterns.length;

            if (patterns.length === 0) {
                container.innerHTML = '<p style="color: #666;">Keine Patterns in dieser Kategorie</p>';
                return;
            }

            container.innerHTML = patterns.map(p => `
                <div class="pattern-card">
                    <div class="pattern-header">
                        <span class="pattern-name">${formatPatternType(p.type)}</span>
                        <div class="pattern-badges">
                            <span class="badge badge-${p.direction}">${p.direction}</span>
                        </div>
                    </div>
                    ${renderPatternExample(p.type)}
                    <p class="pattern-description">${p.description}</p>
                </div>
            `).join('');
        }

        // Load statistics
        async function loadStatistics() {
            try {
                // Try candlestick service first
                const res = await fetch(`${CANDLESTICK_API}/history/statistics`);
                const stats = await res.json();

                document.getElementById('historyCount').textContent = stats.total_patterns || 0;
                document.getElementById('bullishCount').textContent = stats.by_direction?.bullish || 0;
                document.getElementById('bearishCount').textContent = stats.by_direction?.bearish || 0;
                document.getElementById('neutralCount').textContent = stats.by_direction?.neutral || 0;

                // Update scan status
                isAutoScanRunning = stats.scan_running || false;
                updateScanStatus();

            } catch (error) {
                console.error('Failed to load statistics:', error);
                // Try data service as fallback
                try {
                    const res2 = await fetch(`${DATA_API}/patterns/history/statistics`);
                    const stats2 = await res2.json();
                    document.getElementById('historyCount').textContent = stats2.total_patterns || 0;
                    document.getElementById('bullishCount').textContent = stats2.by_direction?.bullish || 0;
                    document.getElementById('bearishCount').textContent = stats2.by_direction?.bearish || 0;
                    document.getElementById('neutralCount').textContent = stats2.by_direction?.neutral || 0;
                } catch (e2) {
                    console.error('Fallback also failed:', e2);
                }
            }
        }

        // Update scan status display
        function updateScanStatus() {
            const statusEl = document.getElementById('scanStatus');
            const statusText = document.getElementById('scanStatusText');
            const statusDot = statusEl.querySelector('.status-dot');
            const btnStart = document.getElementById('btnStartScan');
            const btnStop = document.getElementById('btnStopScan');

            if (isAutoScanRunning) {
                statusEl.classList.remove('stopped');
                statusEl.classList.add('running');
                statusDot.classList.remove('stopped');
                statusDot.classList.add('running');
                statusText.textContent = 'L√§uft';
                btnStart.style.display = 'none';
                btnStop.style.display = 'inline-flex';
            } else {
                statusEl.classList.remove('running');
                statusEl.classList.add('stopped');
                statusDot.classList.remove('running');
                statusDot.classList.add('stopped');
                statusText.textContent = 'Gestoppt';
                btnStart.style.display = 'inline-flex';
                btnStop.style.display = 'none';
            }
        }

        // Start auto scan
        async function startAutoScan() {
            try {
                // Try candlestick service
                await fetch(`${CANDLESTICK_API}/scan/start`, { method: 'POST' });
                isAutoScanRunning = true;
                updateScanStatus();
                showToast('Auto-Scan gestartet', 'success');
            } catch (error) {
                // Try data service fallback
                try {
                    await fetch(`${DATA_API}/patterns/history/start-auto-scan`, { method: 'POST' });
                    isAutoScanRunning = true;
                    updateScanStatus();
                    showToast('Auto-Scan gestartet', 'success');
                } catch (e2) {
                    showToast('Fehler beim Starten', 'error');
                    console.error('Start auto scan failed:', e2);
                }
            }
        }

        // Stop auto scan
        async function stopAutoScan() {
            try {
                // Try candlestick service
                await fetch(`${CANDLESTICK_API}/scan/stop`, { method: 'POST' });
                isAutoScanRunning = false;
                updateScanStatus();
                showToast('Auto-Scan gestoppt', 'info');
            } catch (error) {
                // Try data service fallback
                try {
                    await fetch(`${DATA_API}/patterns/history/stop-auto-scan`, { method: 'POST' });
                    isAutoScanRunning = false;
                    updateScanStatus();
                    showToast('Auto-Scan gestoppt', 'info');
                } catch (e2) {
                    showToast('Fehler beim Stoppen', 'error');
                    console.error('Stop auto scan failed:', e2);
                }
            }
        }

        // Trigger manual scan
        async function triggerManualScan() {
            const btn = event.target;
            btn.disabled = true;
            btn.textContent = 'Scanne...';

            try {
                // Try candlestick service
                const res = await fetch(`${CANDLESTICK_API}/history/scan`, { method: 'POST' });
                const result = await res.json();
                showToast(`Scan abgeschlossen: ${result.new_patterns_found || 0} neue Patterns`, 'success');
                await loadStatistics();
            } catch (error) {
                // Try data service fallback
                try {
                    const res2 = await fetch(`${DATA_API}/patterns/history/scan`, { method: 'POST' });
                    const result2 = await res2.json();
                    showToast(`Scan abgeschlossen: ${result2.new_patterns_found || 0} neue Patterns`, 'success');
                    await loadStatistics();
                } catch (e2) {
                    showToast('Scan fehlgeschlagen', 'error');
                    console.error('Manual scan failed:', e2);
                }
            } finally {
                btn.disabled = false;
                btn.textContent = 'Jetzt scannen';
            }
        }

        // Clear history
        async function clearHistory() {
            if (!confirm('M√∂chten Sie wirklich die gesamte Pattern-History l√∂schen?')) {
                return;
            }

            try {
                // Try candlestick service
                await fetch(`${CANDLESTICK_API}/history/clear`, { method: 'POST' });
                showToast('History gel√∂scht', 'info');
                await loadStatistics();
            } catch (error) {
                // Try data service fallback
                try {
                    await fetch(`${DATA_API}/patterns/history`, { method: 'DELETE' });
                    showToast('History gel√∂scht', 'info');
                    await loadStatistics();
                } catch (e2) {
                    showToast('Fehler beim L√∂schen', 'error');
                    console.error('Clear history failed:', e2);
                }
            }
        }

        // === Tab Switching ===
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(`tab-${tabName}`).classList.add('active');

            // Load data based on tab
            if (tabName === 'history') {
                initHistoryFilters();
                loadPatternHistory();
            } else if (tabName === 'training') {
                loadTrainingServiceInfo();
                loadFeedbackStats();
                loadTrainingStatus();
                loadTrainingJobs();

                // Start auto-refresh for training status
                if (!trainingRefreshInterval) {
                    trainingRefreshInterval = setInterval(loadTrainingStatus, 5000);
                }
            } else if (tabName === 'revalidation') {
                loadRevalidationData();

                // Stop training auto-refresh
                if (trainingRefreshInterval) {
                    clearInterval(trainingRefreshInterval);
                    trainingRefreshInterval = null;
                }
            } else {
                // Stop auto-refresh when leaving training tab
                if (trainingRefreshInterval) {
                    clearInterval(trainingRefreshInterval);
                    trainingRefreshInterval = null;
                }
            }
        }

        // === Pattern History Functions ===

        // Initialize filter dropdowns (preserves current values)
        async function initHistoryFilters() {
            try {
                // Save current filter values
                const currentSymbol = document.getElementById('historyFilterSymbol')?.value || '';
                const currentPattern = document.getElementById('historyFilterPattern')?.value || '';

                // Load symbols
                const symbolsRes = await fetch(`${DATA_API}/managed-symbols`);
                const symbols = await symbolsRes.json();
                const symbolSelect = document.getElementById('historyFilterSymbol');
                const favorites = symbols.filter(s => s.is_favorite);

                symbolSelect.innerHTML = '<option value="">Alle Symbole</option>' +
                    favorites.map(s => `<option value="${s.symbol}">${s.symbol}</option>`).join('');

                // Restore symbol selection
                if (currentSymbol) symbolSelect.value = currentSymbol;

                // Load pattern types
                const patternsRes = await fetch(`${CANDLESTICK_API}/patterns`);
                const patternsData = await patternsRes.json();
                const patternSelect = document.getElementById('historyFilterPattern');

                const allPatterns = [
                    ...(patternsData.categories?.reversal || []),
                    ...(patternsData.categories?.continuation || []),
                    ...(patternsData.categories?.indecision || [])
                ];

                patternSelect.innerHTML = '<option value="">Alle Patterns</option>' +
                    allPatterns.map(p => `<option value="${p.type}">${formatPatternType(p.type)}</option>`).join('');

                // Restore pattern selection
                if (currentPattern) patternSelect.value = currentPattern;

            } catch (error) {
                console.error('Failed to init history filters:', error);
            }
        }

        // Reset all history filters to default
        function resetHistoryFilters() {
            document.getElementById('historyFilterSymbol').value = '';
            document.getElementById('historyFilterPattern').value = '';
            document.getElementById('historyFilterDirection').value = '';
            document.getElementById('historyFilterTimeframe').value = '';
            document.getElementById('historyFilterConfidence').value = '0';
            loadPatternHistory(1);
        }

        // Store ALL filtered patterns for modal navigation (not just current page)
        let allFilteredPatterns = [];

        // Store patterns for current page display
        let loadedPatterns = [];

        // Store feedback data for timeline display - grouped by pattern ID
        // Each entry can have multiple feedbacks (initial + revalidations)
        let patternFeedbackMap = {};

        // Load feedback data for timeline display
        async function loadFeedbackData() {
            try {
                const res = await fetch(`${CANDLESTICK_API}/feedback?limit=1000`);
                const data = await res.json();

                // Create map by pattern_id - group all feedbacks for the same pattern
                patternFeedbackMap = {};
                (data.feedback || []).forEach(fb => {
                    const id = fb.id;
                    if (!patternFeedbackMap[id]) {
                        // First feedback for this pattern
                        patternFeedbackMap[id] = {
                            ...fb,
                            feedbackHistory: []
                        };
                    }

                    // Build feedback history entry
                    const historyEntry = {
                        type: fb.feedback_type,
                        timestamp: fb.feedback_timestamp,
                        originalPattern: fb.original_pattern,
                        correctedPattern: fb.corrected_pattern
                    };

                    // Add revalidation info if present
                    if (fb.revalidated) {
                        historyEntry.revalidated = true;
                        historyEntry.revalidationResult = fb.revalidation_result;
                        historyEntry.revalidationTimestamp = fb.revalidation_timestamp;
                        historyEntry.revalidationNotes = fb.revalidation_notes;
                        historyEntry.revalidationCorrectedPattern = fb.revalidation_corrected_pattern;
                    }

                    // Add historical revalidations if present
                    if (fb.revalidation_history && fb.revalidation_history.length > 0) {
                        historyEntry.previousRevalidations = fb.revalidation_history;
                    }

                    patternFeedbackMap[id].feedbackHistory.push(historyEntry);

                    // Update the main entry with latest data
                    patternFeedbackMap[id].feedback_type = fb.feedback_type;
                    patternFeedbackMap[id].corrected_pattern = fb.corrected_pattern;
                    patternFeedbackMap[id].revalidated = fb.revalidated;
                    patternFeedbackMap[id].revalidation_result = fb.revalidation_result;
                });
            } catch (error) {
                console.error('Failed to load feedback data:', error);
            }
        }

        // Format feedback type for display
        function formatFeedbackType(type) {
            const typeMap = {
                'confirmed': { icon: '‚úì', label: 'Best√§tigt', class: 'confirmed' },
                'corrected': { icon: '‚úé', label: 'Korrigiert', class: 'corrected' },
                'rejected': { icon: '‚úó', label: 'Abgelehnt', class: 'rejected' }
            };
            return typeMap[type] || { icon: '?', label: type, class: '' };
        }

        // Format revalidation result for display
        function formatRevalidationResult(result) {
            const resultMap = {
                'correct': { icon: '‚úì', label: 'Jetzt korrekt', class: 'confirmed' },
                'now_correct': { icon: '‚úì', label: 'Nicht mehr erkannt', class: 'confirmed' },
                'still_wrong': { icon: '‚úó', label: 'Noch falsch', class: 'rejected' }
            };
            return resultMap[result] || { icon: '?', label: result, class: '' };
        }

        // Render detailed feedback history HTML
        function renderFeedbackHistory(feedback) {
            if (!feedback || !feedback.feedbackHistory || feedback.feedbackHistory.length === 0) {
                return '';
            }

            const historyItems = [];

            feedback.feedbackHistory.forEach(entry => {
                // Initial feedback
                const ft = formatFeedbackType(entry.type);
                const feedbackTime = entry.timestamp ? formatTimestamp(entry.timestamp) : '';

                let detail = '';
                if (entry.type === 'corrected' && entry.correctedPattern) {
                    detail = `${formatPatternType(entry.originalPattern)} <span class="feedback-history-arrow">‚Üí</span> ${formatPatternType(entry.correctedPattern)}`;
                } else if (entry.type === 'rejected') {
                    detail = `${formatPatternType(entry.originalPattern)} <span class="feedback-history-arrow">‚Üí</span> Kein Pattern`;
                }

                historyItems.push(`
                    <div class="feedback-history-item ${entry.type}">
                        <div class="feedback-history-row">
                            <span class="feedback-history-type ${ft.class}">${ft.icon} ${ft.label}</span>
                            <span class="feedback-history-time">${feedbackTime}</span>
                        </div>
                        ${detail ? `<div class="feedback-history-detail">${detail}</div>` : ''}
                    </div>
                `);

                // Add revalidation if present
                if (entry.revalidated) {
                    const rv = formatRevalidationResult(entry.revalidationResult);
                    const revalTime = entry.revalidationTimestamp ? formatTimestamp(entry.revalidationTimestamp) : '';

                    let revalDetail = '';
                    if (entry.revalidationCorrectedPattern) {
                        revalDetail = `Neue Korrektur: ${formatPatternType(entry.revalidationCorrectedPattern)}`;
                    }
                    if (entry.revalidationNotes) {
                        revalDetail = entry.revalidationNotes;
                    }

                    historyItems.push(`
                        <div class="feedback-history-item revalidated">
                            <div class="feedback-history-row">
                                <span class="feedback-history-type revalidated">üîÑ Re-Validierung: ${rv.label}</span>
                                <span class="feedback-history-time">${revalTime}</span>
                            </div>
                            ${revalDetail ? `<div class="feedback-history-detail">${revalDetail}</div>` : ''}
                        </div>
                    `);
                }

                // Add historical revalidations
                if (entry.previousRevalidations) {
                    entry.previousRevalidations.forEach(prevReval => {
                        const prevRv = formatRevalidationResult(prevReval.result);
                        const prevTime = prevReval.timestamp ? formatTimestamp(prevReval.timestamp) : '';

                        historyItems.push(`
                            <div class="feedback-history-item revalidated" style="opacity: 0.7;">
                                <div class="feedback-history-row">
                                    <span class="feedback-history-type revalidated">üîÑ Re-Validierung: ${prevRv.label}</span>
                                    <span class="feedback-history-time">${prevTime}</span>
                                </div>
                                ${prevReval.notes ? `<div class="feedback-history-detail">${prevReval.notes}</div>` : ''}
                            </div>
                        `);
                    });
                }
            });

            return `
                <div class="feedback-history">
                    <div class="feedback-history-title">
                        <span>üìã</span> Feedback-Verlauf (${historyItems.length} Eintr√§ge)
                    </div>
                    ${historyItems.join('')}
                </div>
            `;
        }

        // Load pattern history with filters
        async function loadPatternHistory(page = 1) {
            currentHistoryPage = page;
            const timeline = document.getElementById('patternTimeline');
            timeline.innerHTML = '<div class="loading"><span class="spinner"></span> Lade Patterns...</div>';

            // Get filter values
            const symbol = document.getElementById('historyFilterSymbol')?.value || '';
            const pattern = document.getElementById('historyFilterPattern')?.value || '';
            const direction = document.getElementById('historyFilterDirection')?.value || '';
            const timeframe = document.getElementById('historyFilterTimeframe')?.value || '';
            const minConfidence = parseFloat(document.getElementById('historyFilterConfidence')?.value || '0');

            try {
                // Load feedback data first (for status display)
                await loadFeedbackData();

                // Build query params - load all patterns for navigation
                const params = new URLSearchParams();
                params.set('limit', '1000');  // Load more for complete navigation
                if (symbol) params.set('symbol', symbol);
                if (timeframe) params.set('timeframe', timeframe);

                const res = await fetch(`${CANDLESTICK_API}/history?${params}`);
                let data = await res.json();
                let patterns = data.patterns || [];

                // Client-side filtering
                if (pattern) {
                    patterns = patterns.filter(p => p.pattern_type === pattern);
                }
                if (direction) {
                    patterns = patterns.filter(p => p.direction === direction);
                }
                if (minConfidence > 0) {
                    patterns = patterns.filter(p => (p.confidence || 0) >= minConfidence);
                }

                // Sort by timestamp descending (newest first)
                patterns.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

                // Store ALL filtered patterns for modal navigation
                allFilteredPatterns = patterns.map((p, idx) => ({ ...p, globalIndex: idx }));

                // Pagination for display
                const totalPatterns = patterns.length;
                const totalPages = Math.ceil(totalPatterns / HISTORY_PAGE_SIZE);
                const startIdx = (page - 1) * HISTORY_PAGE_SIZE;
                const pagePatterns = patterns.slice(startIdx, startIdx + HISTORY_PAGE_SIZE);

                // Store page patterns with global index for modal access
                loadedPatterns = pagePatterns.map((p, idx) => ({ ...p, globalIndex: startIdx + idx }));

                // Update pagination
                updateHistoryPagination(page, totalPages, totalPatterns);

                if (pagePatterns.length === 0) {
                    timeline.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">üìä</div>
                            <p>Keine Patterns gefunden</p>
                            <p style="font-size: 0.85rem; margin-top: 0.5rem;">Passe die Filter an oder warte auf neue Erkennungen</p>
                        </div>
                    `;
                    return;
                }

                // Group patterns by date
                const groupedPatterns = groupPatternsByDate(pagePatterns);

                // Render timeline
                timeline.innerHTML = renderTimeline(groupedPatterns);

            } catch (error) {
                console.error('Failed to load pattern history:', error);
                timeline.innerHTML = '<div class="empty-state"><p style="color: #e57373;">Fehler beim Laden der History</p></div>';
            }
        }

        // Group patterns by date
        function groupPatternsByDate(patterns) {
            const groups = {};
            patterns.forEach((p, idx) => {
                const date = new Date(p.timestamp);
                const dateKey = date.toLocaleDateString('de-CH', { weekday: 'long', day: '2-digit', month: 'long', year: 'numeric' });
                if (!groups[dateKey]) {
                    groups[dateKey] = [];
                }
                groups[dateKey].push({ ...p, index: idx });
            });
            return groups;
        }

        // Render the full timeline
        function renderTimeline(groupedPatterns) {
            let html = '';
            for (const [dateKey, patterns] of Object.entries(groupedPatterns)) {
                html += `<div class="timeline-date-group">`;
                html += `<div class="timeline-date-header">${dateKey}</div>`;
                patterns.forEach(p => {
                    html += renderTimelineItem(p);
                });
                html += `</div>`;
            }
            return html;
        }

        // Render a single timeline item with detailed feedback info
        function renderTimelineItem(pattern) {
            const time = new Date(pattern.timestamp).toLocaleTimeString('de-CH', { hour: '2-digit', minute: '2-digit' });
            const confidencePercent = ((pattern.confidence || 0) * 100).toFixed(0);
            const directionClass = pattern.direction || 'neutral';

            // Check for feedback status
            const feedback = patternFeedbackMap[pattern.id];
            let feedbackBadge = '';
            let feedbackSummary = '';

            if (feedback) {
                const feedbackType = feedback.feedback_type;
                const ft = formatFeedbackType(feedbackType);

                // Count total feedback entries (initial + revalidations)
                let totalEntries = 1;
                if (feedback.feedbackHistory) {
                    feedback.feedbackHistory.forEach(h => {
                        if (h.revalidated) totalEntries++;
                        if (h.previousRevalidations) totalEntries += h.previousRevalidations.length;
                    });
                }

                // Show revalidation status if applicable
                let revalIcon = '';
                if (feedback.revalidated) {
                    const rv = formatRevalidationResult(feedback.revalidation_result);
                    revalIcon = `<span title="Re-Validierung: ${rv.label}" style="margin-left: 3px;">üîÑ</span>`;
                }

                // Build detailed label
                let label = ft.label;
                if (feedbackType === 'corrected' && feedback.corrected_pattern) {
                    label = `‚Üí ${formatPatternType(feedback.corrected_pattern)}`;
                }

                // Badge with entry count if multiple
                const countBadge = totalEntries > 1 ? `<span class="feedback-count-badge">${totalEntries}</span>` : '';

                feedbackBadge = `
                    <span class="feedback-badge-detailed ${feedbackType}"
                          title="Klicken f√ºr Details"
                          onclick="event.stopPropagation(); toggleFeedbackDetails('${pattern.id}')">
                        <span>${ft.icon}</span>
                        <span>${label}</span>
                        ${revalIcon}
                        ${countBadge}
                    </span>
                `;

                // Build detailed feedback summary (hidden by default)
                const feedbackTime = feedback.feedback_timestamp ? formatTimestamp(feedback.feedback_timestamp) : '';
                feedbackSummary = `
                    <div id="feedback-details-${pattern.id}" class="feedback-history" style="display: none; margin-top: 0.5rem;">
                        <div class="feedback-history-title">
                            <span>üìã</span> Feedback-Verlauf
                        </div>
                        <div class="feedback-history-item ${feedbackType}">
                            <div class="feedback-history-row">
                                <span class="feedback-history-type ${ft.class}">${ft.icon} ${ft.label}</span>
                                <span class="feedback-history-time">${feedbackTime}</span>
                            </div>
                            ${feedbackType === 'corrected' && feedback.corrected_pattern ?
                                `<div class="feedback-history-detail">${formatPatternType(feedback.original_pattern)} <span class="feedback-history-arrow">‚Üí</span> ${formatPatternType(feedback.corrected_pattern)}</div>` : ''}
                            ${feedbackType === 'rejected' ?
                                `<div class="feedback-history-detail">${formatPatternType(feedback.original_pattern)} <span class="feedback-history-arrow">‚Üí</span> Kein Pattern</div>` : ''}
                        </div>
                        ${feedback.revalidated ? `
                            <div class="feedback-history-item revalidated">
                                <div class="feedback-history-row">
                                    <span class="feedback-history-type revalidated">üîÑ Re-Validierung: ${formatRevalidationResult(feedback.revalidation_result).label}</span>
                                    <span class="feedback-history-time">${feedback.revalidation_timestamp ? formatTimestamp(feedback.revalidation_timestamp) : ''}</span>
                                </div>
                                ${feedback.revalidation_notes ? `<div class="feedback-history-detail">${feedback.revalidation_notes}</div>` : ''}
                            </div>
                        ` : ''}
                        ${feedback.revalidation_history ? feedback.revalidation_history.map(h => `
                            <div class="feedback-history-item revalidated" style="opacity: 0.7;">
                                <div class="feedback-history-row">
                                    <span class="feedback-history-type revalidated">üîÑ ${formatRevalidationResult(h.result).label}</span>
                                    <span class="feedback-history-time">${h.timestamp ? formatTimestamp(h.timestamp) : ''}</span>
                                </div>
                                ${h.notes ? `<div class="feedback-history-detail">${h.notes}</div>` : ''}
                            </div>
                        `).join('') : ''}
                    </div>
                `;
            }

            return `
                <div class="timeline-item ${directionClass}">
                    <span class="timeline-time">${time}</span>
                    <div class="timeline-content" onclick="openPatternModal(${pattern.index})">
                        <span class="timeline-pattern-name">${formatPatternType(pattern.pattern_type)}</span>
                        <span class="timeline-symbol">${pattern.symbol}</span>
                        <span class="timeline-direction ${directionClass}">${pattern.direction}</span>
                        ${feedbackBadge}
                        <span class="timeline-confidence">${confidencePercent}%</span>
                        <span class="timeline-arrow">‚Ä∫</span>
                    </div>
                    ${feedbackSummary}
                </div>
            `;
        }

        // Toggle feedback details visibility
        function toggleFeedbackDetails(patternId) {
            const detailsEl = document.getElementById(`feedback-details-${patternId}`);
            if (detailsEl) {
                detailsEl.style.display = detailsEl.style.display === 'none' ? 'block' : 'none';
            }
        }

        // Current modal pattern for corrections
        let currentModalPattern = null;

        // Reference pattern examples (synthetic ideal patterns)
        // Format: OHLC data matching the visual examples from Pattern Detection
        const PATTERN_REFERENCES = {
            // === Reversal Bullish ===
            'hammer': [
                { open: 102, high: 103, low: 98, close: 99 },    // Vorherige rote Kerze (Abw√§rtstrend)
                { open: 99, high: 100, low: 93, close: 99.5 }    // Hammer: kleiner Body oben, langer unterer Docht
            ],
            'inverted_hammer': [
                { open: 102, high: 103, low: 98, close: 99 },    // Vorherige rote Kerze
                { open: 98, high: 105, low: 97, close: 99 }      // Invertierter Hammer: langer oberer Docht
            ],
            'bullish_engulfing': [
                { open: 104, high: 105, low: 100, close: 101 },  // Kleine rote Kerze
                { open: 100, high: 106, low: 99, close: 105 }    // Gro√üe gr√ºne Kerze umschlie√üt
            ],
            'morning_star': [
                { open: 106, high: 107, low: 100, close: 101 },  // Lange rote Kerze
                { open: 101, high: 102, low: 100, close: 101 },  // Kleiner Body/Doji
                { open: 101, high: 108, low: 100, close: 107 }   // Lange gr√ºne Kerze
            ],
            'piercing_line': [
                { open: 106, high: 107, low: 100, close: 101 },  // Rote Kerze
                { open: 99, high: 105, low: 98, close: 104 }     // Gr√ºne Kerze schlie√üt √ºber 50%
            ],
            'dragonfly_doji': [
                { open: 102, high: 103, low: 98, close: 99 },    // Vorherige Kerze
                { open: 100, high: 100.5, low: 93, close: 100 }  // Dragonfly: Body oben, langer unterer Docht
            ],

            // === Reversal Bearish ===
            'hanging_man': [
                { open: 98, high: 102, low: 97, close: 101 },    // Vorherige gr√ºne Kerze (Aufw√§rtstrend)
                { open: 102, high: 103, low: 95, close: 102 }    // Hanging Man: kleiner Body oben, langer unterer Docht
            ],
            'shooting_star': [
                { open: 98, high: 102, low: 97, close: 101 },    // Vorherige gr√ºne Kerze
                { open: 102, high: 109, low: 101, close: 103 }   // Shooting Star: langer oberer Docht
            ],
            'bearish_engulfing': [
                { open: 100, high: 104, low: 99, close: 103 },   // Kleine gr√ºne Kerze
                { open: 104, high: 105, low: 98, close: 99 }     // Gro√üe rote Kerze umschlie√üt
            ],
            'evening_star': [
                { open: 100, high: 107, low: 99, close: 106 },   // Lange gr√ºne Kerze
                { open: 106, high: 107, low: 105, close: 106 },  // Kleiner Body/Doji
                { open: 106, high: 107, low: 100, close: 101 }   // Lange rote Kerze
            ],
            'dark_cloud_cover': [
                { open: 100, high: 106, low: 99, close: 105 },   // Gr√ºne Kerze
                { open: 107, high: 108, low: 101, close: 102 }   // Rote Kerze √∂ffnet √ºber, schlie√üt unter 50%
            ],
            'gravestone_doji': [
                { open: 98, high: 102, low: 97, close: 101 },    // Vorherige Kerze
                { open: 102, high: 109, low: 102, close: 102 }   // Gravestone: Body unten, langer oberer Docht
            ],

            // === Continuation ===
            'three_white_soldiers': [
                { open: 100, high: 104, low: 99, close: 103 },   // 1. gr√ºne Kerze
                { open: 103, high: 107, low: 102, close: 106 },  // 2. gr√ºne Kerze
                { open: 106, high: 110, low: 105, close: 109 }   // 3. gr√ºne Kerze
            ],
            'three_black_crows': [
                { open: 109, high: 110, low: 105, close: 106 },  // 1. rote Kerze
                { open: 106, high: 107, low: 102, close: 103 },  // 2. rote Kerze
                { open: 103, high: 104, low: 99, close: 100 }    // 3. rote Kerze
            ],
            'rising_three_methods': [
                { open: 100, high: 106, low: 99, close: 105 },   // Gro√üe gr√ºne
                { open: 104, high: 105, low: 102, close: 103 },  // Kleine rote
                { open: 103, high: 104, low: 101, close: 102 },  // Kleine rote
                { open: 102, high: 108, low: 101, close: 107 }   // Gro√üe gr√ºne
            ],
            'falling_three_methods': [
                { open: 107, high: 108, low: 101, close: 102 },  // Gro√üe rote
                { open: 103, high: 105, low: 102, close: 104 },  // Kleine gr√ºne
                { open: 104, high: 106, low: 103, close: 105 },  // Kleine gr√ºne
                { open: 105, high: 106, low: 99, close: 100 }    // Gro√üe rote
            ],

            // === Indecision ===
            'doji': [
                { open: 101, high: 103, low: 99, close: 100 },   // Vorherige Kerze
                { open: 100, high: 104, low: 96, close: 100 }    // Doji: Open ‚âà Close
            ],
            'spinning_top': [
                { open: 101, high: 103, low: 99, close: 100 },   // Vorherige Kerze
                { open: 100, high: 105, low: 95, close: 102 }    // Spinning Top: kleiner Body, lange Dochte
            ],
            'bullish_harami': [
                { open: 106, high: 107, low: 99, close: 100 },   // Gro√üe rote Kerze
                { open: 101, high: 103, low: 100, close: 102 }   // Kleine gr√ºne Kerze innerhalb
            ],
            'bearish_harami': [
                { open: 100, high: 107, low: 99, close: 106 },   // Gro√üe gr√ºne Kerze
                { open: 105, high: 106, low: 103, close: 104 }   // Kleine rote Kerze innerhalb
            ],
            'harami_cross': [
                { open: 106, high: 107, low: 99, close: 100 },   // Gro√üe Kerze
                { open: 103, high: 105, low: 101, close: 103 }   // Doji innerhalb
            ],
            'inside_bar': [
                { open: 106, high: 108, low: 98, close: 100 },   // Gro√üe Mutterkerze
                { open: 102, high: 105, low: 100, close: 103 }   // Kleinere Kerze komplett innerhalb
            ]
        };

        // Open pattern detail modal
        // Current modal index for navigation (global index across all patterns)
        let currentModalIndex = 0;

        async function openPatternModal(index) {
            // Use globalIndex if provided (from timeline click), otherwise use index directly
            const pattern = loadedPatterns[index];
            if (!pattern) return;

            // Use the global index for navigation across all patterns
            const globalIdx = pattern.globalIndex !== undefined ? pattern.globalIndex : index;
            currentModalIndex = globalIdx;

            currentModalPattern = allFilteredPatterns[globalIdx] || pattern;

            // Populate modal fields
            document.getElementById('modalPatternName').textContent = formatPatternType(currentModalPattern.pattern_type);
            const directionEl = document.getElementById('modalDirection');
            directionEl.textContent = currentModalPattern.direction;
            directionEl.className = `timeline-direction ${currentModalPattern.direction}`;

            document.getElementById('modalSymbol').textContent = currentModalPattern.symbol;
            document.getElementById('modalTimeframe').textContent = currentModalPattern.timeframe;
            document.getElementById('modalTimestamp').textContent = formatTimestamp(currentModalPattern.timestamp);
            document.getElementById('modalConfidence').textContent = ((currentModalPattern.confidence || 0) * 100).toFixed(0) + '%';
            document.getElementById('modalDescription').textContent = currentModalPattern.description || currentModalPattern.trading_implication || 'Keine Beschreibung verf√ºgbar';

            // Update navigation counter and buttons
            updateModalNavigation();

            // Populate correction dropdown
            await populateCorrectionDropdown();

            // Reset feedback
            document.getElementById('correctionFeedback').style.display = 'none';

            // Show modal
            document.getElementById('patternModal').classList.add('show');
            document.body.style.overflow = 'hidden';

            // Load charts
            await Promise.all([
                loadModalChart(currentModalPattern),
                loadReferenceChart(currentModalPattern.pattern_type, currentModalPattern.direction)
            ]);
        }

        // Open modal directly by global index (for navigation)
        async function openPatternModalByGlobalIndex(globalIndex) {
            const pattern = allFilteredPatterns[globalIndex];
            if (!pattern) return;

            currentModalIndex = globalIndex;
            currentModalPattern = pattern;

            // Populate modal fields
            document.getElementById('modalPatternName').textContent = formatPatternType(pattern.pattern_type);
            const directionEl = document.getElementById('modalDirection');
            directionEl.textContent = pattern.direction;
            directionEl.className = `timeline-direction ${pattern.direction}`;

            document.getElementById('modalSymbol').textContent = pattern.symbol;
            document.getElementById('modalTimeframe').textContent = pattern.timeframe;
            document.getElementById('modalTimestamp').textContent = formatTimestamp(pattern.timestamp);
            document.getElementById('modalConfidence').textContent = ((pattern.confidence || 0) * 100).toFixed(0) + '%';
            document.getElementById('modalDescription').textContent = pattern.description || pattern.trading_implication || 'Keine Beschreibung verf√ºgbar';

            // Update navigation counter and buttons
            updateModalNavigation();

            // Populate correction dropdown
            await populateCorrectionDropdown();

            // Reset feedback
            document.getElementById('correctionFeedback').style.display = 'none';

            // Load charts
            await Promise.all([
                loadModalChart(pattern),
                loadReferenceChart(pattern.pattern_type, pattern.direction)
            ]);
        }

        // Update navigation buttons and counter
        function updateModalNavigation() {
            const total = allFilteredPatterns.length;
            const current = currentModalIndex + 1;

            // Update counter
            document.getElementById('modalNavCounter').textContent = `${current} / ${total}`;

            // Update button states
            document.getElementById('modalPrevBtn').disabled = currentModalIndex <= 0;
            document.getElementById('modalNextBtn').disabled = currentModalIndex >= total - 1;
        }

        // Navigate to previous/next pattern (using global index)
        function navigatePattern(direction) {
            const newIndex = currentModalIndex + direction;

            if (newIndex >= 0 && newIndex < allFilteredPatterns.length) {
                openPatternModalByGlobalIndex(newIndex);
            }
        }

        // Keyboard navigation for modal
        document.addEventListener('keydown', function(e) {
            const modal = document.getElementById('patternModal');
            if (!modal.classList.contains('show')) return;

            if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
                e.preventDefault();
                navigatePattern(-1);
            } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
                e.preventDefault();
                navigatePattern(1);
            } else if (e.key === 'Escape') {
                closePatternModal();
            }
        });

        // Populate correction pattern dropdown
        async function populateCorrectionDropdown() {
            const select = document.getElementById('correctionPatternSelect');
            try {
                const res = await fetch(`${CANDLESTICK_API}/patterns`);
                const data = await res.json();
                const patterns = data.patterns || [];

                select.innerHTML = '<option value="">-- Korrektes Pattern w√§hlen --</option>' +
                    '<option value="no_pattern">Kein Pattern</option>' +
                    patterns.map(p => `<option value="${p.type}">${formatPatternType(p.type)} (${p.direction})</option>`).join('');
            } catch (error) {
                console.error('Failed to load patterns for correction:', error);
            }
        }

        // Load reference chart showing ideal pattern
        function loadReferenceChart(patternType, direction) {
            const canvas = document.getElementById('modalReferenceChart');
            if (!canvas) return;

            // Get reference data or generate generic example
            let refCandles = PATTERN_REFERENCES[patternType];

            if (!refCandles) {
                // Generate generic reference based on direction
                if (direction === 'bullish') {
                    refCandles = [
                        { open: 100, high: 101, low: 98, close: 99 },
                        { open: 99, high: 100, low: 97, close: 98 },
                        { open: 98, high: 103, low: 97, close: 102 }
                    ];
                } else if (direction === 'bearish') {
                    refCandles = [
                        { open: 100, high: 102, low: 99, close: 101 },
                        { open: 101, high: 103, low: 100, close: 102 },
                        { open: 102, high: 103, low: 98, close: 99 }
                    ];
                } else {
                    refCandles = [
                        { open: 100, high: 102, low: 98, close: 101 },
                        { open: 101, high: 103, low: 99, close: 100 },
                        { open: 100, high: 102, low: 98, close: 101 }
                    ];
                }
            }

            // Format for chart rendering
            const formattedCandles = refCandles.map((c, i) => ({
                datetime: `Kerze ${i + 1}`,
                open: c.open.toString(),
                high: c.high.toString(),
                low: c.low.toString(),
                close: c.close.toString()
            }));

            // For reference chart, highlight starts at first candle of the pattern
            // The PATTERN_REFERENCES data contains exactly the pattern candles
            const patternCandleCount = getPatternCandleCount(patternType);
            const highlightStart = formattedCandles.length - patternCandleCount;

            renderCandlestickChart(canvas, formattedCandles, highlightStart, direction, patternType);
        }

        // Close pattern detail modal
        function closePatternModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('patternModal').classList.remove('show');
            document.body.style.overflow = '';
            currentModalPattern = null;
        }

        // Confirm pattern is correct
        async function confirmPattern() {
            if (!currentModalPattern) return;
            await submitPatternFeedback(currentModalPattern, 'confirmed', currentModalPattern.pattern_type);
        }

        // Submit correction with different pattern
        async function submitCorrection() {
            if (!currentModalPattern) return;
            const correctedPattern = document.getElementById('correctionPatternSelect').value;
            if (!correctedPattern) {
                showCorrectionFeedback('Bitte w√§hlen Sie das korrekte Pattern aus.', 'warning');
                return;
            }
            await submitPatternFeedback(currentModalPattern, 'corrected', correctedPattern);
        }

        // Mark as no pattern (false positive)
        async function markAsNoPattern() {
            if (!currentModalPattern) return;
            await submitPatternFeedback(currentModalPattern, 'rejected', 'no_pattern');
        }

        // Submit pattern feedback to backend
        async function submitPatternFeedback(pattern, feedbackType, correctedPattern) {
            try {
                const payload = {
                    pattern_id: pattern.id || `${pattern.symbol}_${pattern.timestamp}_${pattern.pattern_type}`,
                    original_pattern: pattern.pattern_type,
                    feedback_type: feedbackType,
                    corrected_pattern: correctedPattern,
                    symbol: pattern.symbol,
                    timeframe: pattern.timeframe,
                    timestamp: pattern.timestamp,
                    ohlc_data: pattern.ohlc_data || null
                };

                const res = await fetch(`${CANDLESTICK_API}/feedback`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (res.ok) {
                    const msg = feedbackType === 'confirmed' ? 'Pattern als korrekt best√§tigt!' :
                                feedbackType === 'rejected' ? 'Als Fehlererkennung markiert.' :
                                `Korrektur zu "${formatPatternType(correctedPattern)}" gespeichert.`;
                    showCorrectionFeedback(msg, 'success');

                    // Update feedback map locally for immediate UI update
                    const patternId = pattern.id || `${pattern.symbol}_${pattern.timestamp}_${pattern.pattern_type}`;
                    patternFeedbackMap[patternId] = {
                        id: patternId,
                        feedback_type: feedbackType,
                        corrected_pattern: correctedPattern
                    };

                    // Refresh timeline to show updated status
                    loadPatternHistory(currentHistoryPage);
                } else {
                    throw new Error('Server error');
                }
            } catch (error) {
                console.error('Failed to submit feedback:', error);
                showCorrectionFeedback('Feedback konnte nicht gespeichert werden.', 'error');
            }
        }

        // Show feedback message
        function showCorrectionFeedback(message, type) {
            const el = document.getElementById('correctionFeedback');
            el.textContent = message;
            el.style.display = 'block';
            el.style.color = type === 'success' ? '#81c784' : type === 'error' ? '#e57373' : '#ffb74d';
        }

        // Load chart for modal
        async function loadModalChart(pattern) {
            const canvas = document.getElementById('modalChart');
            if (!canvas) return;

            try {
                const interval = timeframeToInterval(pattern.timeframe);
                const cacheKey = `${pattern.symbol}_${interval}`;

                let ohlcData;
                if (ohlcCache[cacheKey]) {
                    ohlcData = ohlcCache[cacheKey];
                } else {
                    const res = await fetch(`${DATA_API}/twelvedata/time_series/${pattern.symbol}?interval=${interval}&outputsize=50`);
                    const data = await res.json();
                    ohlcData = data.values || [];
                    ohlcCache[cacheKey] = ohlcData;
                }

                // TwelveData returns data in REVERSE order: index 0 = newest, last index = oldest
                // Pattern timestamp points to the LAST candle of the pattern
                // For 2-candle patterns: timestamp = second candle, first candle is OLDER (higher index in TwelveData)

                const patternTime = new Date(pattern.timestamp);
                const patternCandleCount = getPatternCandleCount(pattern.pattern_type);

                // First, reverse the data to get chronological order (oldest first)
                const chronoData = [...ohlcData].reverse();

                // Find pattern's last candle in chronological array
                let lastCandleIdx = chronoData.findIndex(candle => {
                    const candleTime = new Date(candle.datetime);
                    return Math.abs(candleTime - patternTime) < 3600000 * 4;  // Within 4h for better precision
                });

                if (lastCandleIdx === -1) {
                    // Fallback: try 24h window
                    lastCandleIdx = chronoData.findIndex(candle => {
                        const candleTime = new Date(candle.datetime);
                        return Math.abs(candleTime - patternTime) < 3600000 * 24;
                    });
                }

                if (lastCandleIdx === -1) lastCandleIdx = chronoData.length - 1;

                // First candle of pattern is (patternCandleCount - 1) positions BEFORE the last candle
                const firstCandleIdx = lastCandleIdx - (patternCandleCount - 1);

                // Get slice: balanced context - enough to see trend but still readable timestamps
                const contextBefore = 6;
                const contextAfter = 3;
                const startIdx = Math.max(0, firstCandleIdx - contextBefore);
                const endIdx = Math.min(chronoData.length, lastCandleIdx + contextAfter + 1);
                const chartCandles = chronoData.slice(startIdx, endIdx);

                // Calculate highlight index relative to the slice
                // firstCandleIdx in original array -> position in slice = firstCandleIdx - startIdx
                const highlightStartIdx = firstCandleIdx - startIdx;

                // Format for rendering
                const formattedCandles = chartCandles.map(c => ({
                    datetime: c.datetime,
                    open: c.open,
                    high: c.high,
                    low: c.low,
                    close: c.close
                }));

                renderCandlestickChart(canvas, formattedCandles, highlightStartIdx, pattern.direction, pattern.pattern_type);

            } catch (error) {
                console.error(`Failed to load modal chart for ${pattern.symbol}:`, error);
            }
        }

        // Update pagination controls
        function updateHistoryPagination(page, totalPages, totalPatterns) {
            const pagination = document.getElementById('historyPagination');
            const prevBtn = document.getElementById('historyPrevBtn');
            const nextBtn = document.getElementById('historyNextBtn');
            const pageInfo = document.getElementById('historyPageInfo');

            if (totalPages <= 1) {
                pagination.style.display = 'none';
                return;
            }

            pagination.style.display = 'flex';
            prevBtn.disabled = page <= 1;
            nextBtn.disabled = page >= totalPages;
            pageInfo.textContent = `Seite ${page} von ${totalPages} (${totalPatterns} Patterns)`;
        }

        // Format price with appropriate decimals
        function formatPrice(price) {
            if (!price) return '-';
            if (price < 1) return price.toFixed(5);
            if (price < 100) return price.toFixed(4);
            if (price < 10000) return price.toFixed(2);
            return price.toFixed(0);
        }

        // Convert timeframe to TwelveData interval format
        function timeframeToInterval(tf) {
            const map = {
                'M1': '1min', 'M5': '5min', 'M15': '15min', 'M30': '30min',
                'H1': '1h', 'H2': '2h', 'H4': '4h',
                'D1': '1day', 'W1': '1week', 'MN': '1month'
            };
            return map[tf] || '1h';
        }

        // Format candle timestamp for display
        function formatCandleTime(datetime, timeframe) {
            if (!datetime) return '';
            const date = new Date(datetime);
            if (isNaN(date.getTime())) {
                // Try parsing as "YYYY-MM-DD HH:mm:ss" format
                const parts = datetime.split(' ');
                if (parts.length === 2) {
                    const [datePart, timePart] = parts;
                    const [year, month, day] = datePart.split('-');
                    const [hour, minute] = timePart.split(':');

                    // For daily timeframes, show date only
                    if (timeframe === 'D1' || timeframe === 'W1' || timeframe === 'MN') {
                        return `${day}.${month}`;
                    }
                    return `${hour}:${minute}`;
                }
                return datetime.substring(11, 16) || '';
            }

            // For daily timeframes, show date
            if (timeframe === 'D1' || timeframe === 'W1' || timeframe === 'MN') {
                return date.toLocaleDateString('de-CH', { day: '2-digit', month: '2-digit' });
            }
            // For intraday, show time
            return date.toLocaleTimeString('de-CH', { hour: '2-digit', minute: '2-digit' });
        }

        // Render candlestick chart on canvas
        function renderCandlestickChart(canvas, candles, highlightIndex, direction, patternType) {
            const ctx = canvas.getContext('2d');
            const width = canvas.offsetWidth;
            const height = canvas.offsetHeight;

            // Set canvas resolution for crisp rendering
            canvas.width = width * 2;
            canvas.height = height * 2;
            ctx.scale(2, 2);

            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, width, height);

            if (!candles || candles.length === 0) {
                ctx.fillStyle = '#666';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Keine Daten', width / 2, height / 2);
                return;
            }

            // Calculate price range
            const prices = candles.flatMap(c => [parseFloat(c.high), parseFloat(c.low)]);
            const minPrice = Math.min(...prices);
            const maxPrice = Math.max(...prices);
            const priceRange = maxPrice - minPrice || 1;
            const padding = priceRange * 0.1;

            // Calculate dimensions with space for timestamps and pattern label
            const chartPadding = { top: 25, right: 10, bottom: 22, left: 10 };
            const chartWidth = width - chartPadding.left - chartPadding.right;
            const chartHeight = height - chartPadding.top - chartPadding.bottom;
            const candleWidth = Math.min(18, (chartWidth / candles.length) * 0.65);
            const candleSpacing = chartWidth / candles.length;

            // Price to Y coordinate
            const priceToY = (price) => {
                return chartPadding.top + chartHeight - ((price - minPrice + padding) / (priceRange + 2 * padding)) * chartHeight;
            };

            // Draw grid lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = chartPadding.top + (chartHeight / 4) * i;
                ctx.beginPath();
                ctx.moveTo(chartPadding.left, y);
                ctx.lineTo(width - chartPadding.right, y);
                ctx.stroke();
            }

            // Determine timeframe from datetime format (rough detection)
            const firstCandle = candles[0];
            let timeframe = 'H1';
            if (firstCandle?.datetime) {
                const dt = firstCandle.datetime;
                // Check if it looks like daily data (no significant time variation)
                if (dt.includes('00:00:00') || !dt.includes(':')) {
                    timeframe = 'D1';
                }
            }

            // Draw candles and timestamps
            candles.forEach((candle, i) => {
                const x = chartPadding.left + (i + 0.5) * candleSpacing;
                const open = parseFloat(candle.open);
                const close = parseFloat(candle.close);
                const high = parseFloat(candle.high);
                const low = parseFloat(candle.low);

                const isBullish = close >= open;
                const bodyTop = priceToY(Math.max(open, close));
                const bodyBottom = priceToY(Math.min(open, close));
                const bodyHeight = Math.max(1, bodyBottom - bodyTop);

                // Check if this candle is part of the pattern (highlight 1-3 candles depending on pattern)
                const isHighlighted = i >= highlightIndex && i <= highlightIndex + getPatternCandleCount(patternType) - 1;

                if (isHighlighted) {
                    // Draw highlight background
                    ctx.fillStyle = direction === 'bullish'
                        ? 'rgba(76, 175, 80, 0.2)'
                        : direction === 'bearish'
                            ? 'rgba(244, 67, 54, 0.2)'
                            : 'rgba(255, 152, 0, 0.2)';
                    ctx.fillRect(x - candleSpacing / 2, chartPadding.top, candleSpacing, chartHeight);
                }

                // Colors
                const bullColor = isHighlighted ? '#4caf50' : '#81c784';
                const bearColor = isHighlighted ? '#f44336' : '#e57373';
                const wickColor = isBullish ? bullColor : bearColor;
                const bodyColor = isBullish ? bullColor : bearColor;

                // Draw wick
                ctx.strokeStyle = wickColor;
                ctx.lineWidth = isHighlighted ? 2 : 1;
                ctx.beginPath();
                ctx.moveTo(x, priceToY(high));
                ctx.lineTo(x, priceToY(low));
                ctx.stroke();

                // Draw body
                ctx.fillStyle = isBullish ? 'rgba(0,0,0,0.3)' : bodyColor;
                ctx.strokeStyle = bodyColor;
                ctx.lineWidth = isHighlighted ? 2 : 1;

                if (isBullish) {
                    ctx.fillRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
                    ctx.strokeRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
                } else {
                    ctx.fillRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
                }

                // Draw timestamp below candle
                const timeLabel = formatCandleTime(candle.datetime, timeframe);
                ctx.fillStyle = isHighlighted ? '#fff' : '#666';
                ctx.font = isHighlighted ? 'bold 9px sans-serif' : '8px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(timeLabel, x, height - 5);
            });

            // Draw pattern label at the top
            if (highlightIndex >= 0 && highlightIndex < candles.length && patternType) {
                const patternCandleCount = getPatternCandleCount(patternType);
                const labelX = chartPadding.left + (highlightIndex + patternCandleCount / 2) * candleSpacing;
                const markerColor = direction === 'bullish' ? '#4caf50' : direction === 'bearish' ? '#f44336' : '#ff9800';

                // Draw pattern name label
                const label = formatPatternType(patternType);
                ctx.font = 'bold 10px sans-serif';
                const textWidth = ctx.measureText(label).width;

                // Background for label
                ctx.fillStyle = markerColor;
                const labelPadding = 4;
                const labelHeight = 14;
                const labelY = 3;

                // Rounded rectangle for label
                const rectX = labelX - textWidth / 2 - labelPadding;
                const rectWidth = textWidth + labelPadding * 2;
                ctx.beginPath();
                ctx.roundRect(rectX, labelY, rectWidth, labelHeight, 3);
                ctx.fill();

                // Label text
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(label, labelX, labelY + labelHeight / 2);

                // Draw bracket/lines connecting to candles
                ctx.strokeStyle = markerColor;
                ctx.lineWidth = 2;
                ctx.setLineDash([]);

                // Left bracket line
                const bracketY = labelY + labelHeight + 2;
                const leftX = chartPadding.left + (highlightIndex + 0.5) * candleSpacing;
                const rightX = chartPadding.left + (highlightIndex + patternCandleCount - 0.5) * candleSpacing;

                ctx.beginPath();
                ctx.moveTo(labelX, bracketY);
                ctx.lineTo(labelX, bracketY + 3);
                ctx.stroke();
            }
        }

        // Get number of candles in a pattern type
        function getPatternCandleCount(patternType) {
            const multiCandlePatterns = {
                'bullish_engulfing': 2,
                'bearish_engulfing': 2,
                'morning_star': 3,
                'evening_star': 3,
                'three_white_soldiers': 3,
                'three_black_crows': 3,
                'piercing_line': 2,
                'dark_cloud_cover': 2,
                'tweezer_top': 2,
                'tweezer_bottom': 2,
                'rising_three_methods': 5,
                'falling_three_methods': 5,
                'harami': 2,
                'bullish_harami': 2,
                'bearish_harami': 2,
                'harami_cross': 2,
                'inside_bar': 2
            };
            return multiCandlePatterns[patternType] || 1;
        }

        // === Training Service Functions ===

        // Load feedback statistics for training
        async function loadFeedbackStats() {
            try {
                const res = await fetch(`${CANDLESTICK_API}/feedback/statistics`);
                const data = await res.json();

                document.getElementById('feedbackTotal').textContent = data.total || 0;
                document.getElementById('feedbackConfirmed').textContent = data.by_type?.confirmed || 0;
                document.getElementById('feedbackCorrected').textContent = data.by_type?.corrected || 0;
                document.getElementById('feedbackRejected').textContent = data.by_type?.rejected || 0;

                if (data.total > 0) {
                    const correctionRate = data.correction_rate || 0;
                    document.getElementById('feedbackInfo').innerHTML =
                        `<span style="color: #64c8ff;">${data.total}</span> Feedback-Eintr√§ge gesammelt. ` +
                        `Korrekturrate: <span style="color: ${correctionRate > 30 ? '#e57373' : '#81c784'};">${correctionRate}%</span>. ` +
                        `Das Feedback wird beim n√§chsten Training automatisch ber√ºcksichtigt.`;
                } else {
                    document.getElementById('feedbackInfo').textContent =
                        'Noch kein Feedback gesammelt. √úberpr√ºfe Patterns in der "Pattern History" und markiere sie als korrekt/falsch.';
                }

            } catch (error) {
                console.error('Failed to load feedback stats:', error);
                document.getElementById('feedbackTotal').textContent = '-';
                document.getElementById('feedbackConfirmed').textContent = '-';
                document.getElementById('feedbackCorrected').textContent = '-';
                document.getElementById('feedbackRejected').textContent = '-';
            }
        }

        // Load training service info
        async function loadTrainingServiceInfo() {
            try {
                const res = await fetch(`${CANDLESTICK_TRAIN_API}/info`);
                const data = await res.json();

                document.getElementById('trainServiceStatus').textContent = 'Online';
                document.getElementById('trainServiceStatus').style.background = 'rgba(76, 175, 80, 0.2)';
                document.getElementById('trainServiceStatus').style.color = '#81c784';

                document.getElementById('trainVersion').textContent = data.version || '-';
                document.getElementById('trainPyTorch').textContent = data.pytorch_available ? 'OK' : 'N/A';
                document.getElementById('trainPatternTypes').textContent = data.capabilities?.pattern_types || '-';
                document.getElementById('trainStarted').textContent = formatTimestamp(data.started_at);

                // Render timeframes
                const tfList = document.getElementById('trainTimeframes');
                if (data.capabilities?.supported_timeframes) {
                    tfList.innerHTML = data.capabilities.supported_timeframes.map(tf =>
                        `<span class="timeframe-badge">${tf}</span>`
                    ).join('');
                }

            } catch (error) {
                console.error('Failed to load training service info:', error);
                document.getElementById('trainServiceStatus').textContent = 'Offline';
                document.getElementById('trainServiceStatus').style.background = 'rgba(244, 67, 54, 0.2)';
                document.getElementById('trainServiceStatus').style.color = '#e57373';
            }
        }

        // Load training status
        async function loadTrainingStatus() {
            try {
                const res = await fetch(`${CANDLESTICK_TRAIN_API}/train/status`);
                const data = await res.json();

                const card = document.getElementById('currentTrainingCard');
                const btn = document.getElementById('btnStartTraining');

                if (data.training && data.last_job) {
                    // Show current training
                    card.style.display = 'block';
                    btn.disabled = true;
                    btn.textContent = 'Training l√§uft...';

                    const job = data.last_job;
                    document.getElementById('currentJobId').textContent = job.job_id;
                    document.getElementById('currentJobProgress').textContent = `${job.progress?.toFixed(1) || 0}%`;
                    document.getElementById('currentProgressBar').style.width = `${job.progress || 0}%`;
                    document.getElementById('currentEpoch').textContent = job.current_epoch || 0;
                    document.getElementById('totalEpochs').textContent = job.epochs || 0;
                    document.getElementById('currentLoss').textContent = job.current_loss?.toFixed(4) || '-';
                    document.getElementById('bestLoss').textContent = job.best_loss?.toFixed(4) || '-';

                    document.getElementById('currentJobStatus').textContent = 'Running';
                    document.getElementById('currentJobStatus').className = 'job-status running';

                } else if (data.last_job) {
                    // Show last job result briefly
                    card.style.display = 'block';
                    btn.disabled = false;
                    btn.textContent = 'Training starten';

                    const job = data.last_job;
                    document.getElementById('currentJobId').textContent = job.job_id;
                    document.getElementById('currentJobProgress').textContent = `${job.progress?.toFixed(1) || 0}%`;
                    document.getElementById('currentProgressBar').style.width = `${job.progress || 0}%`;
                    document.getElementById('currentEpoch').textContent = job.current_epoch || 0;
                    document.getElementById('totalEpochs').textContent = job.epochs || 0;
                    document.getElementById('currentLoss').textContent = job.current_loss?.toFixed(4) || '-';
                    document.getElementById('bestLoss').textContent = job.best_loss?.toFixed(4) || '-';

                    document.getElementById('currentJobStatus').textContent = job.status;
                    document.getElementById('currentJobStatus').className = `job-status ${job.status}`;

                } else {
                    card.style.display = 'none';
                    btn.disabled = false;
                    btn.textContent = 'Training starten';
                }

            } catch (error) {
                console.error('Failed to load training status:', error);
            }
        }

        // Load training jobs history
        async function loadTrainingJobs() {
            try {
                const res = await fetch(`${CANDLESTICK_TRAIN_API}/train/jobs`);
                const data = await res.json();

                const jobs = data.jobs || [];
                document.getElementById('trainJobsTotal').textContent = jobs.length;
                document.getElementById('jobHistoryCount').textContent = `${jobs.length} Jobs`;

                const jobList = document.getElementById('jobList');

                if (jobs.length === 0) {
                    jobList.innerHTML = '<p style="color: #666; text-align: center; padding: 1rem;">Keine Training-Jobs vorhanden</p>';
                    return;
                }

                jobList.innerHTML = jobs.map(job => `
                    <div class="job-item ${job.status}">
                        <div class="job-info">
                            <div class="job-title">${job.job_id}</div>
                            <div class="job-meta">
                                <span>Symbole: ${job.symbols?.join(', ') || '-'}</span>
                                <span>TF: ${job.timeframes?.join(', ') || '-'}</span>
                                <span>Epochen: ${job.epochs || '-'}</span>
                                ${job.best_loss ? `<span>Best Loss: ${job.best_loss.toFixed(4)}</span>` : ''}
                                ${job.error_message ? `<span style="color: #e57373;">Fehler: ${job.error_message}</span>` : ''}
                            </div>
                            <div class="job-meta" style="margin-top: 0.25rem;">
                                <span>Erstellt: ${formatTimestamp(job.created_at)}</span>
                                ${job.completed_at ? `<span>Beendet: ${formatTimestamp(job.completed_at)}</span>` : ''}
                            </div>
                        </div>
                        <span class="job-status ${job.status}">${job.status}</span>
                    </div>
                `).join('');

            } catch (error) {
                console.error('Failed to load training jobs:', error);
                document.getElementById('jobList').innerHTML = '<p style="color: #e57373; text-align: center; padding: 1rem;">Fehler beim Laden der Jobs</p>';
            }
        }

        // Fixed training configuration for optimal generalization
        const TRAINING_SYMBOLS = ['BTCUSD', 'EURUSD', 'GBPUSD', 'XAUUSD', 'GER40', 'XTIUSD'];
        const TRAINING_TIMEFRAMES = ['H1', 'H4', 'D1'];

        // Start training
        async function startTraining() {
            const btn = document.getElementById('btnStartTraining');
            btn.disabled = true;
            btn.textContent = 'Starte...';

            const epochs = parseInt(document.getElementById('trainEpochs').value) || 50;
            const batchSize = parseInt(document.getElementById('trainBatchSize').value) || 32;
            const learningRate = parseFloat(document.getElementById('trainLearningRate').value) || 0.001;

            try {
                const res = await fetch(`${CANDLESTICK_TRAIN_API}/train`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        symbols: TRAINING_SYMBOLS,
                        timeframes: TRAINING_TIMEFRAMES,
                        epochs: epochs,
                        batch_size: batchSize,
                        learning_rate: learningRate
                    })
                });

                const result = await res.json();

                if (result.status === 'started') {
                    showToast(`Training gestartet: ${result.job?.job_id}`, 'success');
                    await loadTrainingStatus();
                    await loadTrainingJobs();
                } else {
                    showToast('Training konnte nicht gestartet werden', 'error');
                    btn.disabled = false;
                    btn.textContent = 'Training starten';
                }

            } catch (error) {
                console.error('Failed to start training:', error);
                showToast('Fehler beim Starten des Trainings', 'error');
                btn.disabled = false;
                btn.textContent = 'Training starten';
            }
        }

        // Cancel current training
        async function cancelCurrentTraining() {
            if (!confirm('Training wirklich abbrechen?')) {
                return;
            }

            try {
                const statusRes = await fetch(`${CANDLESTICK_TRAIN_API}/train/status`);
                const statusData = await statusRes.json();

                if (statusData.last_job?.job_id) {
                    await fetch(`${CANDLESTICK_TRAIN_API}/train/${statusData.last_job.job_id}/cancel`, {
                        method: 'POST'
                    });
                    showToast('Training abgebrochen', 'info');
                    await loadTrainingStatus();
                    await loadTrainingJobs();
                }

            } catch (error) {
                console.error('Failed to cancel training:', error);
                showToast('Fehler beim Abbrechen', 'error');
            }
        }

        // === Re-Validierung Functions ===

        // Load all revalidation data
        async function loadRevalidationData() {
            await Promise.all([
                loadRevalidationStats(),
                loadPendingRevalidations()
            ]);
        }

        // Load revalidation statistics
        async function loadRevalidationStats() {
            try {
                const res = await fetch(`${CANDLESTICK_API}/feedback/revalidation-statistics`);
                const data = await res.json();

                document.getElementById('revalTotal').textContent = data.total_corrections || 0;
                document.getElementById('revalPending').textContent = data.pending_revalidation || 0;
                document.getElementById('revalDone').textContent = data.revalidated || 0;
                document.getElementById('revalImprovement').textContent =
                    data.revalidated > 0 ? `${data.improvement_rate}%` : '-';

                // Update tab badge
                const badge = document.getElementById('revalidationBadge');
                if (data.pending_revalidation > 0) {
                    badge.textContent = data.pending_revalidation;
                    badge.style.display = 'inline';
                } else {
                    badge.style.display = 'none';
                }

                // Show results card if there are completed validations
                const resultsCard = document.getElementById('revalResultsCard');
                if (data.revalidated > 0) {
                    resultsCard.style.display = 'block';
                    document.getElementById('revalCorrect').textContent = data.results?.correct || 0;
                    document.getElementById('revalNowCorrect').textContent = data.results?.now_correct || 0;
                    document.getElementById('revalStillWrong').textContent = data.results?.still_wrong || 0;
                } else {
                    resultsCard.style.display = 'none';
                }

            } catch (error) {
                console.error('Failed to load revalidation stats:', error);
            }
        }

        // Load pending revalidation items
        async function loadPendingRevalidations() {
            const container = document.getElementById('revalidationList');
            const noItemsMsg = document.getElementById('noRevalidations');
            const countBadge = document.getElementById('pendingCount');

            try {
                const res = await fetch(`${CANDLESTICK_API}/feedback/pending-revalidation`);
                const data = await res.json();

                countBadge.textContent = data.count || 0;

                if (!data.pending || data.pending.length === 0) {
                    allRevalidationItems = [];
                    filteredRevalidationItems = [];
                    container.innerHTML = '';
                    noItemsMsg.style.display = 'block';
                    return;
                }

                // Store all items globally
                allRevalidationItems = data.pending;

                // Populate filter dropdowns
                populateRevalidationFilters(data.pending);

                // Apply filters and render list
                filterRevalidationList();

                noItemsMsg.style.display = 'none';

            } catch (error) {
                console.error('Failed to load pending revalidations:', error);
                container.innerHTML = '<div style="color: #e57373; padding: 1rem;">Fehler beim Laden</div>';
            }
        }

        // Populate filter dropdowns with unique values from data
        function populateRevalidationFilters(items) {
            const symbolSelect = document.getElementById('revalFilterSymbol');
            const patternSelect = document.getElementById('revalFilterPattern');

            // Get unique symbols
            const symbols = [...new Set(items.map(item => item.symbol))].sort();
            symbolSelect.innerHTML = '<option value="">Alle Symbole</option>' +
                symbols.map(s => `<option value="${s}">${s}</option>`).join('');

            // Get unique patterns (both original and corrected)
            const patterns = [...new Set([
                ...items.map(item => item.original_pattern),
                ...items.filter(item => item.corrected_pattern).map(item => item.corrected_pattern)
            ])].filter(p => p).sort();

            patternSelect.innerHTML = '<option value="">Alle Patterns</option>' +
                patterns.map(p => `<option value="${p}">${formatPatternType(p)}</option>`).join('');
        }

        // Filter revalidation list based on selected filters
        function filterRevalidationList() {
            const symbolFilter = document.getElementById('revalFilterSymbol').value;
            const timeframeFilter = document.getElementById('revalFilterTimeframe').value;
            const typeFilter = document.getElementById('revalFilterType').value;
            const patternFilter = document.getElementById('revalFilterPattern').value;

            filteredRevalidationItems = allRevalidationItems.filter(item => {
                if (symbolFilter && item.symbol !== symbolFilter) return false;
                if (timeframeFilter && item.timeframe !== timeframeFilter) return false;
                if (typeFilter) {
                    if (typeFilter === 'rejected' && item.feedback_type !== 'rejected') return false;
                    if (typeFilter === 'corrected' && item.feedback_type !== 'corrected') return false;
                }
                if (patternFilter) {
                    if (item.original_pattern !== patternFilter && item.corrected_pattern !== patternFilter) return false;
                }
                return true;
            });

            renderRevalidationList();
        }

        // Reset all revalidation filters
        function resetRevalidationFilters() {
            document.getElementById('revalFilterSymbol').value = '';
            document.getElementById('revalFilterTimeframe').value = '';
            document.getElementById('revalFilterType').value = '';
            document.getElementById('revalFilterPattern').value = '';
            filterRevalidationList();
        }

        // Render the revalidation list in compact format
        function renderRevalidationList() {
            const container = document.getElementById('revalidationList');
            const noItemsMsg = document.getElementById('noRevalidations');
            const countBadge = document.getElementById('pendingCount');

            if (filteredRevalidationItems.length === 0) {
                if (allRevalidationItems.length === 0) {
                    container.innerHTML = '';
                    noItemsMsg.style.display = 'block';
                } else {
                    container.innerHTML = '<div style="text-align: center; padding: 2rem; color: #888;">Keine Eintr√§ge f√ºr diese Filter</div>';
                    noItemsMsg.style.display = 'none';
                }
                return;
            }

            noItemsMsg.style.display = 'none';
            countBadge.textContent = `${filteredRevalidationItems.length} / ${allRevalidationItems.length}`;

            container.innerHTML = filteredRevalidationItems.map((item, index) => {
                const isRejected = item.feedback_type === 'rejected';
                const typeClass = isRejected ? 'rejected' : 'corrected';
                const typeLabel = isRejected ? 'Abgelehnt' : 'Korrigiert';

                const patternDisplay = isRejected
                    ? `${formatPatternType(item.original_pattern)} ‚Üí ‚úó`
                    : `${formatPatternType(item.original_pattern)} ‚Üí ${formatPatternType(item.corrected_pattern)}`;

                const timestamp = new Date(item.pattern_timestamp);
                const dateStr = timestamp.toLocaleDateString('de-CH', { day: '2-digit', month: '2-digit', year: '2-digit' });
                const timeStr = timestamp.toLocaleTimeString('de-CH', { hour: '2-digit', minute: '2-digit' });

                return `
                    <div class="reval-list-item" onclick="openRevalDetail(${index})">
                        <div class="reval-list-symbol">${item.symbol}</div>
                        <div class="reval-list-pattern">${patternDisplay}</div>
                        <div class="reval-list-timeframe">
                            <span class="timeframe-badge">${item.timeframe}</span>
                        </div>
                        <div class="reval-list-date">${dateStr} ${timeStr}</div>
                        <div class="reval-list-type">
                            <span class="reval-type-badge ${typeClass}">${typeLabel}</span>
                        </div>
                        <div class="reval-list-action">
                            <button class="btn btn-sm" onclick="event.stopPropagation(); openRevalDetail(${index})">Details</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Open revalidation detail modal
        function openRevalDetail(index) {
            currentRevalDetailIndex = index;
            const item = filteredRevalidationItems[index];
            if (!item) return;

            const overlay = document.getElementById('revalDetailOverlay');
            overlay.classList.add('active');

            updateRevalDetailContent(item, index);
        }

        // Close revalidation detail modal
        function closeRevalDetail(event) {
            if (event && event.target !== event.currentTarget) return;
            const overlay = document.getElementById('revalDetailOverlay');
            overlay.classList.remove('active');
        }

        // Navigate to previous/next item in detail view
        function navigateRevalDetail(direction) {
            const newIndex = currentRevalDetailIndex + direction;
            if (newIndex < 0 || newIndex >= filteredRevalidationItems.length) return;

            currentRevalDetailIndex = newIndex;
            const item = filteredRevalidationItems[newIndex];
            updateRevalDetailContent(item, newIndex);
        }

        // Update the detail modal content
        async function updateRevalDetailContent(item, index) {
            const isRejected = item.feedback_type === 'rejected';

            // Update header
            document.getElementById('revalDetailSymbol').textContent = item.symbol;
            const typeBadge = document.getElementById('revalDetailType');
            typeBadge.textContent = isRejected ? 'Abgelehnt' : 'Korrigiert';
            typeBadge.className = `reval-detail-badge ${isRejected ? 'rejected' : 'corrected'}`;

            // Update position
            document.getElementById('revalDetailPosition').textContent = `${index + 1} / ${filteredRevalidationItems.length}`;

            // Update navigation buttons
            document.getElementById('revalPrevBtn').disabled = index === 0;
            document.getElementById('revalNextBtn').disabled = index === filteredRevalidationItems.length - 1;

            // Update info
            document.getElementById('revalDetailOriginal').textContent = formatPatternType(item.original_pattern);
            document.getElementById('revalDetailCorrected').textContent = isRejected ? 'Kein Pattern' : formatPatternType(item.corrected_pattern);
            document.getElementById('revalDetailTimeframe').textContent = item.timeframe;

            const timestamp = new Date(item.pattern_timestamp);
            document.getElementById('revalDetailTimestamp').textContent = timestamp.toLocaleString('de-CH');

            // Render feedback history
            const historyContainer = document.getElementById('revalDetailFeedbackHistory');
            historyContainer.innerHTML = renderRevalDetailFeedbackHistory(item);

            // Load chart
            await loadRevalDetailChart(item);

            // Check current detection
            checkCurrentDetection(item);
        }

        // Render feedback history for detail modal
        function renderRevalDetailFeedbackHistory(item) {
            const feedbackDate = new Date(item.feedback_timestamp || item.created_at);
            const feedbackType = item.feedback_type === 'rejected' ? 'Abgelehnt' : 'Korrigiert';

            let html = `
                <div class="reval-history-entry">
                    <div class="reval-history-date">${feedbackDate.toLocaleString('de-CH')}</div>
                    <div class="reval-history-action">
                        <span class="reval-history-badge initial">${feedbackType}</span>
                        <span class="reval-history-text">
                            ${item.feedback_type === 'rejected'
                                ? `"${formatPatternType(item.original_pattern)}" als False Positive markiert`
                                : `"${formatPatternType(item.original_pattern)}" zu "${formatPatternType(item.corrected_pattern)}" korrigiert`
                            }
                        </span>
                    </div>
                </div>
            `;

            // Add revalidation history if available
            if (item.revalidation_history && item.revalidation_history.length > 0) {
                item.revalidation_history.forEach(reval => {
                    const revalDate = new Date(reval.timestamp);
                    const resultClass = reval.result === 'still_wrong' ? 'failed' : 'success';
                    const resultText = reval.result === 'still_wrong' ? 'Weiterhin falsch'
                        : reval.result === 'correct' ? 'Jetzt korrekt'
                        : 'Nicht mehr erkannt';

                    html += `
                        <div class="reval-history-entry">
                            <div class="reval-history-date">${revalDate.toLocaleString('de-CH')}</div>
                            <div class="reval-history-action">
                                <span class="reval-history-badge ${resultClass}">${resultText}</span>
                                ${reval.notes ? `<span class="reval-history-text">${reval.notes}</span>` : ''}
                            </div>
                        </div>
                    `;
                });
            }

            return html;
        }

        // Load chart for detail modal
        async function loadRevalDetailChart(item) {
            const container = document.getElementById('revalDetailChartContainer');
            container.innerHTML = '<div class="loading"><span class="spinner"></span> Lade Chart...</div>';

            try {
                const ohlcData = await fetchOhlcForRevalidation(item.symbol, item.timeframe, item.pattern_timestamp);

                if (!ohlcData || ohlcData.length === 0) {
                    container.innerHTML = '<div style="color: #888; text-align: center; padding: 2rem;">Keine Chart-Daten verf√ºgbar</div>';
                    return;
                }

                // Create canvas for chart
                container.innerHTML = '<canvas id="revalDetailCanvas" style="width: 100%; height: 280px;"></canvas>';
                const canvas = document.getElementById('revalDetailCanvas');

                const direction = getPatternDirection(item.original_pattern);
                const patternCandleCount = getPatternCandleCount(item.original_pattern);

                const formattedCandles = ohlcData.map(c => ({
                    datetime: c.datetime || c.timestamp,
                    open: parseFloat(c.open),
                    high: parseFloat(c.high),
                    low: parseFloat(c.low),
                    close: parseFloat(c.close)
                }));

                let highlightIdx = 0;
                if (ohlcData._patternIdx !== undefined) {
                    highlightIdx = Math.max(0, ohlcData._patternIdx - (patternCandleCount - 1));
                }

                renderCandlestickChart(canvas, formattedCandles, highlightIdx, direction, item.original_pattern);

            } catch (error) {
                console.error('Failed to load detail chart:', error);
                container.innerHTML = '<div style="color: #e57373; text-align: center; padding: 2rem;">Fehler beim Laden des Charts</div>';
            }
        }

        // Check current detection for the pattern
        async function checkCurrentDetection(item) {
            const container = document.getElementById('revalDetailCurrentDetection');
            container.innerHTML = '<div class="loading"><span class="spinner"></span> Pr√ºfe aktuelle Erkennung...</div>';

            try {
                const res = await fetch(`${CANDLESTICK_API}/patterns/scan`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        symbol: item.symbol,
                        timeframes: [item.timeframe],
                        lookback_candles: 50,
                        min_confidence: 0.3
                    })
                });

                const data = await res.json();

                // Check if original pattern is still detected at the same timestamp
                const patternTime = new Date(item.pattern_timestamp).getTime();
                let foundPatterns = [];

                const timeframeKey = item.timeframe.toLowerCase();
                const tfPatterns = data.result?.[timeframeKey]?.patterns || [];

                tfPatterns.forEach(p => {
                    const pTime = new Date(p.timestamp).getTime();
                    // Match if within 1 hour (for H1) or proportional for other timeframes
                    if (Math.abs(pTime - patternTime) < 3600000 * 4) {
                        foundPatterns.push(p);
                    }
                });

                if (foundPatterns.length === 0) {
                    container.innerHTML = `
                        <div class="detection-result detection-none">
                            <span class="detection-icon">‚óã</span>
                            <span>Kein Pattern mehr an dieser Stelle erkannt</span>
                        </div>
                    `;
                } else {
                    const isOriginalStillDetected = foundPatterns.some(p => p.pattern_type === item.original_pattern);
                    const isCorrectedNowDetected = item.corrected_pattern && foundPatterns.some(p => p.pattern_type === item.corrected_pattern);

                    let html = '<div class="detection-results">';
                    foundPatterns.forEach(p => {
                        const isOriginal = p.pattern_type === item.original_pattern;
                        const isCorrected = p.pattern_type === item.corrected_pattern;
                        const resultClass = isCorrected ? 'detection-success' : (isOriginal ? 'detection-wrong' : 'detection-other');

                        html += `
                            <div class="detection-result ${resultClass}">
                                <span class="detection-icon">${isCorrected ? '‚úì' : (isOriginal ? '‚úó' : '‚Ä¢')}</span>
                                <span>${formatPatternType(p.pattern_type)} (${Math.round(p.confidence * 100)}%)</span>
                            </div>
                        `;
                    });
                    html += '</div>';
                    container.innerHTML = html;
                }

            } catch (error) {
                console.error('Failed to check current detection:', error);
                container.innerHTML = '<div style="color: #e57373;">Fehler beim Pr√ºfen der aktuellen Erkennung</div>';
            }
        }

        // Submit revalidation feedback from detail modal
        async function submitRevalFeedback(result) {
            const item = filteredRevalidationItems[currentRevalDetailIndex];
            if (!item) return;

            try {
                const res = await fetch(`${CANDLESTICK_API}/feedback/record-revalidation`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        feedback_id: item.id,
                        result: result,
                        notes: ''
                    })
                });

                if (res.ok) {
                    showToast('√úberpr√ºfung gespeichert', 'success');

                    // Move to next item or close if last
                    if (currentRevalDetailIndex < filteredRevalidationItems.length - 1) {
                        navigateRevalDetail(1);
                    } else {
                        closeRevalDetail();
                    }

                    // Reload data
                    loadRevalidationData();
                } else {
                    const error = await res.json();
                    showToast('Fehler: ' + (error.detail || 'Unbekannter Fehler'), 'error');
                }
            } catch (error) {
                console.error('Failed to submit revalidation:', error);
                showToast('Netzwerkfehler', 'error');
            }
        }

        // Load and render chart for a revalidation item
        async function loadRevalidationChart(item, index) {
            const canvasId = `reval-chart-${index}`;
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            // Show loading state
            canvas.width = canvas.offsetWidth * 2;
            canvas.height = canvas.offsetHeight * 2;
            ctx.scale(2, 2);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, canvas.offsetWidth, canvas.offsetHeight);
            ctx.fillStyle = '#888';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Lade Chart...', canvas.offsetWidth / 2, canvas.offsetHeight / 2);

            try {
                // Always fetch fresh data from API for better context (15 candles before, 14 after)
                // The cached ohlc_data in item often only contains the pattern candles without context
                let ohlcData = await fetchOhlcForRevalidation(item.symbol, item.timeframe, item.pattern_timestamp);

                // Fallback to cached data only if API fails
                if (!ohlcData || ohlcData.length === 0) {
                    ohlcData = item.ohlc_data;
                }

                if (!ohlcData || ohlcData.length === 0) {
                    // No data available
                    canvas.width = canvas.offsetWidth * 2;
                    canvas.height = canvas.offsetHeight * 2;
                    ctx.scale(2, 2);
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(0, 0, canvas.offsetWidth, canvas.offsetHeight);
                    ctx.fillStyle = '#888';
                    ctx.font = '11px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('Keine Daten verf√ºgbar', canvas.offsetWidth / 2, canvas.offsetHeight / 2);
                    return;
                }

                // Find pattern position and render chart
                const direction = getPatternDirection(item.original_pattern);
                const patternCandleCount = getPatternCandleCount(item.original_pattern);

                // Format candles for rendering
                const formattedCandles = ohlcData.map(c => ({
                    datetime: c.datetime || c.timestamp,
                    open: parseFloat(c.open),
                    high: parseFloat(c.high),
                    low: parseFloat(c.low),
                    close: parseFloat(c.close)
                }));

                // Use pre-calculated pattern index if available (from centered fetch)
                let highlightIdx = 0;

                if (ohlcData._patternIdx !== undefined) {
                    // Pattern index was pre-calculated during fetch
                    // The pattern timestamp points to the LAST candle of the pattern
                    // Highlight starts (candleCount - 1) positions before
                    highlightIdx = Math.max(0, ohlcData._patternIdx - (patternCandleCount - 1));
                } else {
                    // Fallback: Find the pattern timestamp in the data
                    const patternTime = new Date(item.pattern_timestamp);

                    for (let i = 0; i < formattedCandles.length; i++) {
                        const candleTime = new Date(formattedCandles[i].datetime);
                        if (Math.abs(candleTime - patternTime) < 3600000 * 4) { // Within 4 hours
                            // This is the last candle of the pattern
                            // Highlight starts (candleCount - 1) positions before
                            highlightIdx = Math.max(0, i - (patternCandleCount - 1));
                            break;
                        }
                    }
                }

                // Render the chart
                renderCandlestickChart(canvas, formattedCandles, highlightIdx, direction, item.original_pattern);

            } catch (error) {
                console.error(`Failed to load chart for ${item.id}:`, error);
                canvas.width = canvas.offsetWidth * 2;
                canvas.height = canvas.offsetHeight * 2;
                ctx.scale(2, 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(0, 0, canvas.offsetWidth, canvas.offsetHeight);
                ctx.fillStyle = '#e57373';
                ctx.font = '11px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Fehler beim Laden', canvas.offsetWidth / 2, canvas.offsetHeight / 2);
            }
        }

        // Fetch OHLC data for revalidation chart - centered around pattern timestamp
        async function fetchOhlcForRevalidation(symbol, timeframe, patternTimestamp) {
            try {
                // Convert timeframe to TwelveData format
                const intervalMap = {
                    'M5': '5min', 'M15': '15min', 'M30': '30min',
                    'H1': '1h', 'H4': '4h', 'D1': '1day'
                };
                const interval = intervalMap[timeframe] || '1h';

                // Calculate how old the pattern is to fetch enough data
                const patternDate = new Date(patternTimestamp);
                const now = new Date();
                const ageInMs = now - patternDate;

                // Calculate how many candles we need based on timeframe
                const msPerCandle = {
                    'M5': 5 * 60 * 1000,
                    'M15': 15 * 60 * 1000,
                    'M30': 30 * 60 * 1000,
                    'H1': 60 * 60 * 1000,
                    'H4': 4 * 60 * 60 * 1000,
                    'D1': 24 * 60 * 60 * 1000
                };
                const candleMs = msPerCandle[timeframe] || 60 * 60 * 1000;

                // Calculate how many candles back the pattern is, plus buffer for display
                const candlesBack = Math.ceil(ageInMs / candleMs);
                // We want ~15 candles before and ~15 after the pattern = 30 total displayed
                // But we need to fetch enough to include the pattern + buffer after it
                const outputsize = Math.min(500, Math.max(50, candlesBack + 20));

                // Fetch data
                const res = await fetch(`${DATA_API}/twelvedata/time_series/${symbol}?interval=${interval}&outputsize=${outputsize}`);
                if (!res.ok) return null;

                const data = await res.json();
                if (!data.values || data.values.length === 0) return null;

                // TwelveData returns newest first, reverse to chronological order
                const allCandles = data.values.slice().reverse();

                // Find the pattern candle in the data
                let patternIdx = -1;
                for (let i = 0; i < allCandles.length; i++) {
                    const candleTime = new Date(allCandles[i].datetime);
                    // Match within half the candle timeframe
                    if (Math.abs(candleTime - patternDate) < candleMs / 2) {
                        patternIdx = i;
                        break;
                    }
                }

                // If pattern not found, try a wider match
                if (patternIdx === -1) {
                    for (let i = 0; i < allCandles.length; i++) {
                        const candleTime = new Date(allCandles[i].datetime);
                        if (Math.abs(candleTime - patternDate) < candleMs * 2) {
                            patternIdx = i;
                            break;
                        }
                    }
                }

                // If still not found, return all data (fallback)
                if (patternIdx === -1) {
                    console.warn(`Pattern timestamp ${patternTimestamp} not found in data, showing latest candles`);
                    return allCandles.slice(-30);
                }

                // Extract window centered around pattern (15 before, pattern, 14 after = 30 total)
                const candlesBefore = 15;
                const candlesAfter = 14;
                const startIdx = Math.max(0, patternIdx - candlesBefore);
                const endIdx = Math.min(allCandles.length, patternIdx + candlesAfter + 1);

                const windowCandles = allCandles.slice(startIdx, endIdx);

                // Recalculate pattern position within the window for highlighting
                windowCandles._patternIdx = patternIdx - startIdx;

                return windowCandles;

            } catch (error) {
                console.error('Failed to fetch OHLC for revalidation:', error);
                return null;
            }
        }

        // Render a single revalidation item
        function renderRevalidationItem(item, index) {
            const isRejected = item.feedback_type === 'rejected';
            const correctionDisplay = isRejected
                ? `<span class="original">${formatPatternType(item.original_pattern)}</span>
                   <span class="arrow">‚Üí</span>
                   <span class="corrected">Kein Pattern</span>`
                : `<span class="original">${formatPatternType(item.original_pattern)}</span>
                   <span class="arrow">‚Üí</span>
                   <span class="corrected">${formatPatternType(item.corrected_pattern)}</span>`;

            // Determine direction from original pattern for highlighting
            const direction = getPatternDirection(item.original_pattern);
            const canvasId = `reval-chart-${index}`;

            // Context-aware button labels based on feedback type
            // For rejected: Pattern should NOT be detected anymore
            // For corrected: Pattern should be detected as the corrected type
            let successLabel, failLabel, successResult, failResult;

            if (isRejected) {
                // User said: "This is NOT a pattern" (false positive)
                // Success = Model no longer detects any pattern here
                // Fail = Model still detects the wrong pattern
                successLabel = `‚úì Wird nicht mehr erkannt`;
                failLabel = `‚úó "${formatPatternType(item.original_pattern)}" wird noch erkannt`;
                successResult = 'now_correct';
                failResult = 'still_wrong';
            } else {
                // User said: "This should be X instead of Y"
                // Success = Model now detects the correct pattern
                // Fail = Model still detects wrong pattern or nothing
                successLabel = `‚úì "${formatPatternType(item.corrected_pattern)}" wird erkannt`;
                failLabel = `‚úó Noch falsch erkannt`;
                successResult = 'correct';
                failResult = 'still_wrong';
            }

            // Help text explaining what to check
            const helpText = isRejected
                ? `<div class="revalidation-help">
                       <strong>Pr√ºfung:</strong> Erkennt das Modell hier noch f√§lschlicherweise ein "${formatPatternType(item.original_pattern)}"?
                   </div>`
                : `<div class="revalidation-help">
                       <strong>Pr√ºfung:</strong> Erkennt das Modell jetzt "${formatPatternType(item.corrected_pattern)}" statt "${formatPatternType(item.original_pattern)}"?
                   </div>`;

            // Build feedback history section for revalidation view
            const feedbackHistoryHtml = renderRevalidationFeedbackHistory(item);

            return `
                <div class="revalidation-item ${isRejected ? 'rejected' : ''}" data-item-id="${item.id}">
                    <div class="revalidation-header">
                        <div>
                            <strong>${item.symbol}</strong>
                            <span class="timeframe-badge" style="margin-left: 0.5rem;">${item.timeframe}</span>
                        </div>
                        <span class="badge badge-${isRejected ? 'bearish' : 'neutral'}">
                            ${isRejected ? 'Abgelehnt' : 'Korrigiert'}
                        </span>
                    </div>
                    <div class="revalidation-correction">
                        ${correctionDisplay}
                    </div>
                    ${helpText}
                    <div class="revalidation-chart-container" style="display: flex; gap: 1rem; flex-wrap: wrap; margin: 0.75rem 0;">
                        <div style="flex: 1; min-width: 280px;">
                            <div style="font-size: 0.75rem; color: #888; margin-bottom: 0.3rem;">Chart zum Zeitpunkt des Patterns:</div>
                            <canvas id="${canvasId}" class="revalidation-canvas" style="width: 100%; height: 140px; border-radius: 6px; background: rgba(0,0,0,0.2);"></canvas>
                        </div>
                    </div>
                    ${feedbackHistoryHtml}
                    <div class="revalidation-actions">
                        <button class="btn btn-success" onclick="markRevalidation('${item.id}', '${successResult}')" title="Modell erkennt jetzt korrekt">
                            ${successLabel}
                        </button>
                        <button class="btn btn-danger" onclick="showRevalidationCorrectionDialog('${item.id}', '${item.original_pattern}', '${item.symbol}', '${item.timeframe}')" title="Pattern korrigieren">
                            ‚úó Falsch erkannt - korrigieren
                        </button>
                        <button class="btn btn-primary" onclick="scanForRevalidation('${item.id}', '${item.symbol}', '${item.timeframe}', '${item.original_pattern}')" title="Aktuellen Scan starten und Vorschl√§ge anzeigen">
                            üîç Neu scannen
                        </button>
                    </div>
                    <div id="reval-correction-${item.id}" class="revalidation-correction-panel" style="display: none;">
                        <div class="correction-header">Welches Pattern ist korrekt?</div>

                        <!-- Scan-Vorschl√§ge werden hier dynamisch eingef√ºgt -->
                        <div id="reval-scan-suggestions-${item.id}" class="scan-suggestions" style="display: none;">
                            <div class="scan-suggestions-header">
                                <span class="scan-icon">üîç</span> Erkannte Patterns (Vorschl√§ge):
                            </div>
                            <div class="scan-suggestions-buttons"></div>
                        </div>

                        <div class="correction-divider" id="reval-divider-${item.id}" style="display: none;">
                            <span>oder manuell ausw√§hlen:</span>
                        </div>

                        <div class="correction-options">
                            <select id="reval-select-${item.id}" class="pattern-select">
                                <option value="">-- Pattern ausw√§hlen --</option>
                                <option value="no_pattern">‚ùå Kein Pattern (False Positive)</option>
                                <optgroup label="Reversal Bullish">
                                    <option value="hammer">Hammer</option>
                                    <option value="inverted_hammer">Inverted Hammer</option>
                                    <option value="bullish_engulfing">Bullish Engulfing</option>
                                    <option value="morning_star">Morning Star</option>
                                    <option value="piercing_line">Piercing Line</option>
                                    <option value="dragonfly_doji">Dragonfly Doji</option>
                                    <option value="three_white_soldiers">Three White Soldiers</option>
                                </optgroup>
                                <optgroup label="Reversal Bearish">
                                    <option value="shooting_star">Shooting Star</option>
                                    <option value="hanging_man">Hanging Man</option>
                                    <option value="bearish_engulfing">Bearish Engulfing</option>
                                    <option value="evening_star">Evening Star</option>
                                    <option value="dark_cloud_cover">Dark Cloud Cover</option>
                                    <option value="gravestone_doji">Gravestone Doji</option>
                                    <option value="three_black_crows">Three Black Crows</option>
                                </optgroup>
                                <optgroup label="Indecision">
                                    <option value="doji">Doji</option>
                                    <option value="spinning_top">Spinning Top</option>
                                    <option value="bullish_harami">Bullish Harami</option>
                                    <option value="bearish_harami">Bearish Harami</option>
                                    <option value="harami_cross">Harami Cross</option>
                                </optgroup>
                            </select>
                            <button class="btn btn-warning" onclick="submitRevalidationCorrection('${item.id}')">
                                Korrektur speichern
                            </button>
                            <button class="btn btn-secondary" onclick="hideRevalidationCorrectionDialog('${item.id}')">
                                Abbrechen
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }

        // Get pattern direction for highlighting
        function getPatternDirection(patternType) {
            const bullishPatterns = ['hammer', 'inverted_hammer', 'bullish_engulfing', 'morning_star',
                'piercing_line', 'dragonfly_doji', 'three_white_soldiers', 'bullish_harami'];
            const bearishPatterns = ['shooting_star', 'hanging_man', 'bearish_engulfing', 'evening_star',
                'dark_cloud_cover', 'gravestone_doji', 'three_black_crows', 'bearish_harami'];

            if (bullishPatterns.includes(patternType)) return 'bullish';
            if (bearishPatterns.includes(patternType)) return 'bearish';
            return 'neutral';
        }

        // Render feedback history for revalidation item
        function renderRevalidationFeedbackHistory(item) {
            const historyItems = [];

            // Initial feedback
            const ft = formatFeedbackType(item.feedback_type);
            const feedbackTime = item.feedback_timestamp ? formatTimestamp(item.feedback_timestamp) : '';
            const patternTime = item.pattern_timestamp ? formatTimestamp(item.pattern_timestamp) : '';

            // Pattern timestamp row
            historyItems.push(`
                <div class="feedback-history-item" style="border-left-color: #666;">
                    <div class="feedback-history-row">
                        <span class="feedback-history-type" style="color: #888;">üìä Pattern erkannt</span>
                        <span class="feedback-history-time">${patternTime}</span>
                    </div>
                    <div class="feedback-history-detail">${formatPatternType(item.original_pattern)}</div>
                </div>
            `);

            // Feedback entry
            let feedbackDetail = '';
            if (item.feedback_type === 'corrected' && item.corrected_pattern) {
                feedbackDetail = `${formatPatternType(item.original_pattern)} <span class="feedback-history-arrow">‚Üí</span> ${formatPatternType(item.corrected_pattern)}`;
            } else if (item.feedback_type === 'rejected') {
                feedbackDetail = `${formatPatternType(item.original_pattern)} <span class="feedback-history-arrow">‚Üí</span> Kein Pattern`;
            }

            historyItems.push(`
                <div class="feedback-history-item ${item.feedback_type}">
                    <div class="feedback-history-row">
                        <span class="feedback-history-type ${ft.class}">${ft.icon} ${ft.label}</span>
                        <span class="feedback-history-time">${feedbackTime}</span>
                    </div>
                    ${feedbackDetail ? `<div class="feedback-history-detail">${feedbackDetail}</div>` : ''}
                </div>
            `);

            // Previous revalidations from history
            if (item.revalidation_history && item.revalidation_history.length > 0) {
                item.revalidation_history.forEach(prevReval => {
                    const rv = formatRevalidationResult(prevReval.result);
                    const revalTime = prevReval.timestamp ? formatTimestamp(prevReval.timestamp) : '';

                    historyItems.push(`
                        <div class="feedback-history-item revalidated" style="opacity: 0.8;">
                            <div class="feedback-history-row">
                                <span class="feedback-history-type revalidated">üîÑ Re-Validierung: ${rv.label}</span>
                                <span class="feedback-history-time">${revalTime}</span>
                            </div>
                            ${prevReval.notes ? `<div class="feedback-history-detail">${prevReval.notes}</div>` : ''}
                        </div>
                    `);
                });
            }

            // Pending indicator
            historyItems.push(`
                <div class="feedback-history-item" style="border-left-color: #64c8ff; background: rgba(100, 200, 255, 0.1);">
                    <div class="feedback-history-row">
                        <span class="feedback-history-type" style="color: #64c8ff;">‚è≥ Ausstehende Re-Validierung</span>
                        <span class="feedback-history-time">jetzt</span>
                    </div>
                </div>
            `);

            return `
                <div class="feedback-history" style="margin: 0.75rem 0;">
                    <div class="feedback-history-title">
                        <span>üìã</span> Feedback-Verlauf (${historyItems.length} Eintr√§ge)
                    </div>
                    ${historyItems.join('')}
                </div>
            `;
        }

        // Mark an item as revalidated
        // fromScanSuggestion: if true, show enhanced message about training
        async function markRevalidation(feedbackId, result, correctedPattern = null, fromScanSuggestion = false) {
            try {
                const body = {
                    feedback_id: feedbackId,
                    validation_result: result
                };

                // Add correction info if provided
                if (correctedPattern) {
                    body.notes = `Korrigiert zu: ${correctedPattern}`;
                    body.corrected_pattern = correctedPattern;
                }

                const res = await fetch(`${CANDLESTICK_API}/feedback/revalidate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });

                if (res.ok) {
                    let message;
                    if (fromScanSuggestion && correctedPattern) {
                        // Enhanced message for scan suggestions with correction
                        message = `‚úì Korrektur gespeichert: ${formatPatternType(correctedPattern)} (f√ºr n√§chstes Training)`;
                    } else if (fromScanSuggestion && result === 'now_correct') {
                        message = '‚úì Pattern wird nicht mehr erkannt - Modell hat gelernt!';
                    } else {
                        // Standard messages
                        const resultMessages = {
                            'correct': 'Als jetzt korrekt markiert',
                            'now_correct': 'Als nicht mehr erkannt markiert',
                            'still_wrong': correctedPattern
                                ? `Korrigiert zu: ${formatPatternType(correctedPattern)}`
                                : 'Als weiterhin falsch markiert'
                        };
                        message = resultMessages[result] || 'Gespeichert';
                    }
                    showToast(message, 'success');
                    loadRevalidationData();
                } else {
                    throw new Error('Speichern fehlgeschlagen');
                }
            } catch (error) {
                console.error('Failed to mark revalidation:', error);
                showToast('Fehler beim Speichern', 'error');
            }
        }

        // Show correction dialog for revalidation
        function showRevalidationCorrectionDialog(feedbackId, originalPattern, symbol, timeframe) {
            const panel = document.getElementById(`reval-correction-${feedbackId}`);
            if (panel) {
                panel.style.display = 'block';
                // Pre-select original pattern as disabled option
                const select = document.getElementById(`reval-select-${feedbackId}`);
                if (select) {
                    // Mark the original pattern in the dropdown
                    Array.from(select.options).forEach(opt => {
                        if (opt.value === originalPattern) {
                            opt.text = `${opt.text} (aktuell erkannt)`;
                            opt.disabled = true;
                        }
                    });
                }
            }
        }

        // Hide correction dialog
        function hideRevalidationCorrectionDialog(feedbackId) {
            const panel = document.getElementById(`reval-correction-${feedbackId}`);
            if (panel) {
                panel.style.display = 'none';
            }
        }

        // Submit correction from revalidation
        async function submitRevalidationCorrection(feedbackId) {
            const select = document.getElementById(`reval-select-${feedbackId}`);
            if (!select || !select.value) {
                showToast('Bitte ein Pattern ausw√§hlen', 'warning');
                return;
            }

            const correctedPattern = select.value;

            // Mark as still_wrong with the correction info
            await markRevalidation(feedbackId, 'still_wrong', correctedPattern);

            // Hide the dialog
            hideRevalidationCorrectionDialog(feedbackId);
        }

        // Reset all revalidation status (after new training)
        async function resetRevalidation() {
            if (!confirm('Sollen alle Re-Validierungen zur√ºckgesetzt werden?\n\nDies macht alle zuvor √ºberpr√ºften Korrekturen wieder verf√ºgbar f√ºr eine erneute √úberpr√ºfung.')) {
                return;
            }

            try {
                const res = await fetch(`${CANDLESTICK_API}/feedback/reset-revalidation`, {
                    method: 'POST'
                });

                if (res.ok) {
                    const data = await res.json();
                    showToast(`${data.reset_count} Eintr√§ge zur√ºckgesetzt`, 'success');
                    loadRevalidationData();
                } else {
                    throw new Error('Zur√ºcksetzen fehlgeschlagen');
                }
            } catch (error) {
                console.error('Failed to reset revalidation:', error);
                showToast('Fehler beim Zur√ºcksetzen', 'error');
            }
        }

        // Trigger a scan for a specific symbol/timeframe to check current detection
        // Shows results as selectable suggestions in the correction panel
        async function scanForRevalidation(feedbackId, symbol, timeframe, originalPattern) {
            try {
                showToast(`Scanne ${symbol} ${timeframe}...`, 'info');

                // Use GET endpoint /scan/{symbol} with timeframe parameter
                const res = await fetch(`${CANDLESTICK_API}/scan/${symbol}?timeframe=${timeframe}&lookback=50&min_confidence=0.5`);

                if (res.ok) {
                    const data = await res.json();

                    // Get patterns for the specific timeframe
                    const tfKey = timeframe.toLowerCase();
                    const tfPatterns = data.result?.[tfKey]?.patterns || [];
                    const patternCount = tfPatterns.length;

                    // Show the correction panel with suggestions
                    const panel = document.getElementById(`reval-correction-${feedbackId}`);
                    const suggestionsContainer = document.getElementById(`reval-scan-suggestions-${feedbackId}`);
                    const divider = document.getElementById(`reval-divider-${feedbackId}`);

                    if (panel && suggestionsContainer) {
                        panel.style.display = 'block';

                        if (patternCount > 0) {
                            // Create clickable buttons for each detected pattern
                            const buttonsHtml = tfPatterns.map(p => {
                                const patternType = p.pattern_type;
                                const patternName = formatPatternType(patternType);
                                const confidence = (p.confidence * 100).toFixed(0);
                                const isOriginal = patternType === originalPattern;

                                // Different styling for the originally detected pattern
                                if (isOriginal) {
                                    return `<button class="scan-suggestion-btn original" disabled title="Urspr√ºnglich erkanntes Pattern">
                                        ${patternName} (${confidence}%) - aktuell erkannt
                                    </button>`;
                                }

                                return `<button class="scan-suggestion-btn" onclick="selectScanSuggestion('${feedbackId}', '${patternType}')" title="Dieses Pattern als korrekt markieren">
                                    ‚úì ${patternName} (${confidence}%)
                                </button>`;
                            }).join('');

                            // Add "Kein Pattern" option
                            const noPatternBtn = `<button class="scan-suggestion-btn no-pattern" onclick="selectScanSuggestion('${feedbackId}', 'no_pattern')" title="Kein Pattern ist korrekt">
                                ‚ùå Kein Pattern erkannt
                            </button>`;

                            suggestionsContainer.querySelector('.scan-suggestions-buttons').innerHTML = buttonsHtml + noPatternBtn;
                            suggestionsContainer.style.display = 'block';
                            divider.style.display = 'flex';

                            showToast(`${patternCount} Pattern(s) erkannt - Vorschl√§ge angezeigt`, 'success');
                        } else {
                            // No patterns detected - show only "Kein Pattern" suggestion
                            suggestionsContainer.querySelector('.scan-suggestions-buttons').innerHTML = `
                                <div class="no-patterns-found">
                                    <span>Keine Patterns erkannt bei diesem Scan.</span>
                                </div>
                                <button class="scan-suggestion-btn no-pattern" onclick="selectScanSuggestion('${feedbackId}', 'no_pattern')" title="Best√§tigen: Kein Pattern">
                                    ‚úì Kein Pattern best√§tigen
                                </button>`;
                            suggestionsContainer.style.display = 'block';
                            divider.style.display = 'flex';

                            showToast(`Keine Patterns erkannt - Pattern m√∂glicherweise korrigiert`, 'info');
                        }
                    }
                } else {
                    const errorData = await res.json().catch(() => ({}));
                    throw new Error(errorData.detail || 'Scan fehlgeschlagen');
                }
            } catch (error) {
                console.error('Failed to scan for revalidation:', error);
                showToast(`Scan fehlgeschlagen: ${error.message}`, 'error');
            }
        }

        // Select a pattern from scan suggestions
        async function selectScanSuggestion(feedbackId, patternType) {
            if (patternType === 'no_pattern') {
                // Mark as correct (pattern no longer detected)
                await markRevalidation(feedbackId, 'now_correct', null, true);
            } else {
                // Mark as still wrong with the new pattern as correction
                // This saves the correction for future training
                await markRevalidation(feedbackId, 'still_wrong', patternType, true);
            }
            hideRevalidationCorrectionDialog(feedbackId);
        }

        // Update revalidation badge on page load
        async function updateRevalidationBadge() {
            try {
                const res = await fetch(`${CANDLESTICK_API}/feedback/revalidation-statistics`);
                const data = await res.json();

                const badge = document.getElementById('revalidationBadge');
                if (data.pending_revalidation > 0) {
                    badge.textContent = data.pending_revalidation;
                    badge.style.display = 'inline';
                } else {
                    badge.style.display = 'none';
                }
            } catch (error) {
                console.warn('Could not update revalidation badge:', error);
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            await loadServiceInfo();
            await loadPatterns();
            await loadStatistics();
            await updateRevalidationBadge();

            // Auto-Scan standardm√§√üig starten (ohne Toast-Nachricht)
            if (isAutoScanRunning) {
                try {
                    await fetch(`${CANDLESTICK_API}/scan/start`, { method: 'POST' });
                } catch (e) {
                    try {
                        await fetch(`${DATA_API}/patterns/history/start-auto-scan`, { method: 'POST' });
                    } catch (e2) {
                        console.warn('Auto-Scan konnte nicht gestartet werden:', e2);
                    }
                }
            }

            // Auto-refresh every 30 seconds
            setInterval(async () => {
                await loadStatistics();
            }, 30000);
        });
    </script>
</body>
</html>
