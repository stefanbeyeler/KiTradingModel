<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TCN Pattern Service - Konfiguration</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e8e8e8;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1.5rem;
        }

        header {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1rem 0;
            margin-bottom: 1.5rem;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        header .container {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #64c8ff;
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .back-link:hover {
            color: #fff;
        }

        .header-title {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .service-badge {
            background: rgba(76, 175, 80, 0.2);
            color: #81c784;
            padding: 0.3rem 0.8rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .service-badge.offline {
            background: rgba(244, 67, 54, 0.2);
            color: #e57373;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 0.5rem;
        }

        .tab-btn {
            padding: 0.75rem 1.5rem;
            background: transparent;
            border: none;
            color: #a0a0a0;
            font-size: 1rem;
            cursor: pointer;
            border-radius: 8px 8px 0 0;
            transition: all 0.2s;
        }

        .tab-btn:hover {
            background: rgba(255, 255, 255, 0.05);
            color: #e8e8e8;
        }

        .tab-btn.active {
            background: rgba(100, 200, 255, 0.15);
            color: #64c8ff;
            border-bottom: 2px solid #64c8ff;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Card */
        .card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 1.5rem;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .card-title {
            font-size: 1.2rem;
            color: #64c8ff;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Stats Bar */
        .stats-bar {
            display: flex;
            gap: 2rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 600;
            color: #64c8ff;
        }

        .stat-label {
            font-size: 0.8rem;
            opacity: 0.7;
        }

        /* Buttons */
        .btn {
            padding: 0.6rem 1.2rem;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
        }

        .btn-primary {
            background: rgba(100, 200, 255, 0.2);
            color: #64c8ff;
            border: 1px solid rgba(100, 200, 255, 0.3);
        }

        .btn-primary:hover {
            background: rgba(100, 200, 255, 0.3);
        }

        .btn-success {
            background: rgba(76, 175, 80, 0.2);
            color: #81c784;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .btn-success:hover {
            background: rgba(76, 175, 80, 0.3);
        }

        .btn-danger {
            background: rgba(244, 67, 54, 0.2);
            color: #e57373;
            border: 1px solid rgba(244, 67, 54, 0.3);
        }

        .btn-danger:hover {
            background: rgba(244, 67, 54, 0.3);
        }

        .btn-warning {
            background: rgba(255, 152, 0, 0.2);
            color: #ffb74d;
            border: 1px solid rgba(255, 152, 0, 0.3);
        }

        .btn-warning:hover {
            background: rgba(255, 152, 0, 0.3);
        }

        .btn-loading {
            position: relative;
            pointer-events: none;
            opacity: 0.8;
        }

        .btn-loading::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 12px;
            top: 50%;
            right: 8px;
            margin-top: -6px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .btn-sm {
            padding: 0.4rem 0.8rem;
            font-size: 0.8rem;
        }

        /* Grid Layout */
        .grid-2 {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 1.5rem;
        }

        .grid-2-equal {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
        }

        .grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
        }

        @media (max-width: 900px) {
            .grid-2, .grid-2-equal, .grid-3 {
                grid-template-columns: 1fr;
            }
        }

        /* Training Status */
        .training-status {
            font-size: 0.9rem;
        }

        .training-status .training-active {
            color: #4ade80;
            font-weight: 600;
            animation: blink 1s ease-in-out infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .progress-bar {
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            overflow: hidden;
            margin: 0.75rem 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #64c8ff, #a78bfa);
            border-radius: 6px;
            transition: width 0.3s;
        }

        /* Pattern Badge */
        .pattern-badge {
            display: inline-block;
            padding: 0.3rem 0.6rem;
            margin: 0.2rem;
            border-radius: 6px;
            font-size: 0.75rem;
            background: rgba(156, 39, 176, 0.2);
            color: #ce93d8;
            border: 1px solid rgba(156, 39, 176, 0.3);
        }

        .pattern-badge.bullish {
            background: rgba(76, 175, 80, 0.2);
            color: #81c784;
            border-color: rgba(76, 175, 80, 0.3);
        }

        .pattern-badge.bearish {
            background: rgba(244, 67, 54, 0.2);
            color: #e57373;
            border-color: rgba(244, 67, 54, 0.3);
        }

        .pattern-badge.neutral {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
            border-color: rgba(255, 193, 7, 0.3);
        }

        /* Table */
        .data-table {
            width: 100%;
            border-collapse: collapse;
        }

        .data-table th,
        .data-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .data-table th {
            color: #888;
            font-weight: 500;
            font-size: 0.85rem;
        }

        .data-table tr:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            background: rgba(30, 30, 30, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
            animation: slideIn 0.3s ease;
        }

        .toast.success {
            border-left: 4px solid #4caf50;
        }

        .toast.error {
            border-left: 4px solid #f44336;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Loading Spinner */
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 3rem;
            color: #888;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(100, 200, 255, 0.2);
            border-top-color: #64c8ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* Detection Result */
        .detection-result {
            padding: 1rem;
            border-radius: 8px;
            margin-top: 1rem;
            background: rgba(255, 255, 255, 0.03);
        }

        .confidence-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 0.5rem;
        }

        .confidence-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s;
        }

        .confidence-fill.high { background: #4caf50; }
        .confidence-fill.medium { background: #ffc107; }
        .confidence-fill.low { background: #f44336; }

        /* Form Elements */
        .form-group {
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #aaa;
            font-size: 0.9rem;
        }

        .form-control {
            width: 100%;
            padding: 0.6rem 1rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #e8e8e8;
            font-size: 0.9rem;
        }

        .form-control:focus {
            outline: none;
            border-color: #64c8ff;
        }

        select.form-control {
            cursor: pointer;
        }

        /* Info Box */
        .info-box {
            background: rgba(33, 150, 243, 0.1);
            border: 1px solid rgba(33, 150, 243, 0.3);
            border-radius: 8px;
            padding: 1rem;
            font-size: 0.85rem;
            color: #90caf9;
        }

        /* Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 5000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(100, 200, 255, 0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.25rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-title {
            color: #64c8ff;
            font-size: 1.2rem;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem;
            line-height: 1;
        }

        .modal-close:hover {
            color: #fff;
        }

        .modal-body {
            padding: 1.25rem;
        }

        .modal-section {
            margin-bottom: 1.25rem;
        }

        .modal-section:last-child {
            margin-bottom: 0;
        }

        .modal-section-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #888;
            margin-bottom: 0.5rem;
        }

        /* Chart Modal - Larger */
        .chart-modal .modal {
            max-width: 900px;
            width: 95%;
        }

        .chart-container {
            width: 100%;
            height: 280px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }

        .chart-loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            color: #888;
        }

        .chart-error {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            color: #e57373;
            flex-direction: column;
            gap: 0.5rem;
        }

        .chart-canvas-container {
            width: 100%;
            height: 100%;
            padding: 10px;
        }

        .chart-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            margin-top: 0.5rem;
            font-size: 0.8rem;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .chart-info-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .chart-info-label {
            color: #888;
        }

        .chart-info-value {
            color: #64c8ff;
            font-weight: 500;
        }

        .modal-implication {
            padding: 0.75rem;
            border-radius: 6px;
            font-style: italic;
        }

        .modal-implication.bullish {
            background: rgba(76, 175, 80, 0.15);
            color: #81c784;
            border-left: 3px solid #81c784;
        }

        .modal-implication.bearish {
            background: rgba(244, 67, 54, 0.15);
            color: #e57373;
            border-left: 3px solid #e57373;
        }

        .modal-implication.neutral {
            background: rgba(255, 152, 0, 0.15);
            color: #ffb74d;
            border-left: 3px solid #ffb74d;
        }

        .modal-description {
            color: #ccc;
            line-height: 1.6;
        }

        /* Chart Button */
        .btn-chart {
            background: rgba(156, 39, 176, 0.2);
            color: #ce93d8;
            border: 1px solid rgba(156, 39, 176, 0.3);
            padding: 0.2rem 0.5rem;
            font-size: 0.75rem;
            cursor: pointer;
            border-radius: 4px;
        }

        .btn-chart:hover {
            background: rgba(156, 39, 176, 0.3);
        }

        /* Clickable table row */
        .data-table tr.clickable-row {
            cursor: pointer;
            transition: background 0.2s;
        }

        .data-table tr.clickable-row:hover {
            background: rgba(100, 200, 255, 0.1);
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <a href="index.html" class="back-link">&#8592; Dashboard</a>
            <h1 class="header-title">&#128202; TCN Pattern Service</h1>
            <span class="service-badge" id="status-badge">Laden...</span>
        </div>
    </header>

    <div class="container">
        <!-- Stats Bar -->
        <div class="stats-bar" id="stats-bar">
            <div class="stat-item">
                <div class="stat-value" id="stat-patterns">-</div>
                <div class="stat-label">Pattern-Klassen</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="stat-params">-</div>
                <div class="stat-label">Parameter</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="stat-uptime">-</div>
                <div class="stat-label">Uptime</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="stat-models">-</div>
                <div class="stat-label">Modelle</div>
            </div>
        </div>

        <!-- Tabs -->
        <div class="tabs">
            <button class="tab-btn active" onclick="showTab('overview')">&#128200; Ubersicht</button>
            <button class="tab-btn" onclick="showTab('detection')">&#128269; Pattern-Erkennung</button>
            <button class="tab-btn" onclick="showTab('training')">&#9881; Training</button>
        </div>

        <!-- Overview Tab -->
        <div id="tab-overview" class="tab-content active">
            <div class="grid-2-equal">
                <!-- Model Info -->
                <div class="card">
                    <div class="card-header">
                        <h3 class="card-title">&#129302; Modell-Information</h3>
                        <button class="btn btn-primary btn-sm" onclick="loadInfo()">&#8635; Aktualisieren</button>
                    </div>
                    <div id="model-info">
                        <div class="loading"><div class="spinner"></div></div>
                    </div>
                </div>

                <!-- Pattern Classes -->
                <div class="card">
                    <div class="card-header">
                        <h3 class="card-title">&#127919; Erkennbare Pattern</h3>
                    </div>
                    <div id="pattern-classes">
                        <div class="loading"><div class="spinner"></div></div>
                    </div>
                </div>
            </div>

            <!-- Service Status -->
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">&#128337; Service Status</h3>
                </div>
                <div id="service-status">
                    <div class="loading"><div class="spinner"></div></div>
                </div>
            </div>
        </div>

        <!-- Detection Tab -->
        <div id="tab-detection" class="tab-content">
            <!-- Auto-Scan Status -->
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">&#128336; Auto-Erkennung</h3>
                    <div style="display: flex; gap: 0.5rem;">
                        <button class="btn btn-success btn-sm" id="btn-start-autoscan" onclick="toggleAutoScan(true)">&#9654; Starten</button>
                        <button class="btn btn-danger btn-sm" id="btn-stop-autoscan" onclick="toggleAutoScan(false)" disabled>&#9632; Stoppen</button>
                    </div>
                </div>
                <div id="autoscan-status" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem;">
                    <div style="background: rgba(255,255,255,0.03); padding: 1rem; border-radius: 8px; text-align: center;">
                        <div style="font-size: 1.5rem;" id="autoscan-status-indicator">-</div>
                        <div style="color: #888; font-size: 0.85rem;">Status</div>
                    </div>
                    <div style="background: rgba(255,255,255,0.03); padding: 1rem; border-radius: 8px; text-align: center;">
                        <div style="font-size: 1.5rem; color: #64c8ff;" id="autoscan-total">-</div>
                        <div style="color: #888; font-size: 0.85rem;">Gespeicherte Patterns</div>
                    </div>
                    <div style="background: rgba(255,255,255,0.03); padding: 1rem; border-radius: 8px; text-align: center;">
                        <div style="font-size: 1.5rem; color: #a78bfa;" id="autoscan-symbols">-</div>
                        <div style="color: #888; font-size: 0.85rem;">Symbole</div>
                    </div>
                    <div style="background: rgba(255,255,255,0.03); padding: 1rem; border-radius: 8px; text-align: center;">
                        <div style="font-size: 1rem; color: #fff;" id="autoscan-lastscan">-</div>
                        <div style="color: #888; font-size: 0.85rem;">Letzter Scan</div>
                    </div>
                </div>
                <div class="info-box" style="margin-top: 1rem;">
                    Auto-Erkennung scannt alle 5 Minuten alle aktiven Symbole auf den Timeframes 1h, 4h und 1d.
                    Erkannte Patterns werden 7 Tage gespeichert (max. 2000 Eintraege).
                </div>
            </div>

            <div class="grid-2">
                <!-- Detection Form -->
                <div class="card">
                    <div class="card-header">
                        <h3 class="card-title">&#128269; Manuelle Erkennung</h3>
                    </div>
                    <div class="form-group">
                        <label>Symbol</label>
                        <select class="form-control" id="detect-symbol">
                            <option value="">Lade Symbole...</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Timeframe</label>
                        <select class="form-control" id="detect-timeframe">
                            <option value="1h" selected>1h</option>
                            <option value="4h">4h</option>
                            <option value="1d">1d</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Min. Confidence</label>
                        <input type="number" class="form-control" id="detect-confidence" value="0.5" min="0" max="1" step="0.05">
                    </div>
                    <button class="btn btn-success" id="btn-detect" onclick="detectPattern()">&#128269; Pattern erkennen</button>

                    <div id="detection-result"></div>
                </div>

                <!-- Scan All -->
                <div class="card">
                    <div class="card-header">
                        <h3 class="card-title">&#128640; Manueller Multi-Symbol Scan</h3>
                    </div>
                    <div class="info-box" style="margin-bottom: 1rem;">
                        Scannt alle aktiven Symbole sofort nach Patterns und speichert sie in der Historie.
                    </div>
                    <button class="btn btn-primary" id="btn-scan-all" onclick="scanAllAndSave()">&#128640; Alle Symbole scannen</button>
                    <div id="scan-results" style="margin-top: 1rem;"></div>
                </div>
            </div>

            <!-- Pattern History Table (moved from Verlauf tab) -->
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">&#128203; Erkannte Patterns</h3>
                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center;">
                        <select class="form-control" id="history-symbol-filter" style="width: auto;">
                            <option value="">Alle Symbole</option>
                        </select>
                        <select class="form-control" id="history-pattern-filter" style="width: auto;">
                            <option value="">Alle Patterns</option>
                            <option value="head_and_shoulders">Head &amp; Shoulders</option>
                            <option value="inverse_head_and_shoulders">Inv. Head &amp; Shoulders</option>
                            <option value="double_top">Double Top</option>
                            <option value="double_bottom">Double Bottom</option>
                            <option value="triple_top">Triple Top</option>
                            <option value="triple_bottom">Triple Bottom</option>
                            <option value="ascending_triangle">Ascending Triangle</option>
                            <option value="descending_triangle">Descending Triangle</option>
                            <option value="symmetrical_triangle">Symmetrical Triangle</option>
                            <option value="rising_wedge">Rising Wedge</option>
                            <option value="falling_wedge">Falling Wedge</option>
                            <option value="bull_flag">Bull Flag</option>
                            <option value="bear_flag">Bear Flag</option>
                            <option value="channel_up">Channel Up</option>
                            <option value="channel_down">Channel Down</option>
                            <option value="cup_and_handle">Cup &amp; Handle</option>
                        </select>
                        <select class="form-control" id="history-timeframe-filter" style="width: auto;">
                            <option value="">Alle Timeframes</option>
                            <option value="1h">1h</option>
                            <option value="4h">4h</option>
                            <option value="1d">1d</option>
                        </select>
                        <select class="form-control" id="history-category-filter" style="width: auto;">
                            <option value="">Alle Kategorien</option>
                            <option value="reversal">Reversal</option>
                            <option value="continuation">Continuation</option>
                            <option value="trend">Trend</option>
                        </select>
                        <select class="form-control" id="history-direction-filter" style="width: auto;">
                            <option value="">Alle Richtungen</option>
                            <option value="bullish">Bullish</option>
                            <option value="bearish">Bearish</option>
                            <option value="neutral">Neutral</option>
                        </select>
                        <select class="form-control" id="history-confidence-filter" style="width: auto;">
                            <option value="">Alle Konfidenzen</option>
                            <option value="0.8">≥ 80%</option>
                            <option value="0.7">≥ 70%</option>
                            <option value="0.6">≥ 60%</option>
                            <option value="0.5">≥ 50%</option>
                        </select>
                        <button class="btn btn-secondary btn-sm" id="btn-reset-filters" onclick="resetPatternFilters()" style="display: none;" title="Filter zurücksetzen">
                            &#10005; Filter
                        </button>
                        <button class="btn btn-primary btn-sm" onclick="loadPatternHistory()">&#8635; Aktualisieren</button>
                    </div>
                </div>
                <div id="pattern-history-table" style="overflow-x: auto;">
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Symbol</th>
                                <th>Pattern</th>
                                <th>Richtung</th>
                                <th>Konfidenz</th>
                                <th>Timeframe</th>
                                <th>Erkannt</th>
                                <th>Preis</th>
                                <th style="text-align: center;">Chart</th>
                            </tr>
                        </thead>
                        <tbody id="pattern-history-body">
                            <tr><td colspan="8" style="text-align: center; padding: 2rem; color: #888;">Lade Pattern-Historie...</td></tr>
                        </tbody>
                    </table>
                </div>
                <div style="margin-top: 1rem; display: flex; justify-content: space-between; align-items: center;">
                    <span id="history-count" style="color: #888; font-size: 0.85rem;"></span>
                </div>
            </div>

            <!-- Statistics -->
            <div class="grid-3">
                <div class="card">
                    <div class="card-header">
                        <h3 class="card-title">Nach Pattern-Typ</h3>
                    </div>
                    <div id="stats-by-type" style="font-size: 0.85rem;">Lade...</div>
                </div>
                <div class="card">
                    <div class="card-header">
                        <h3 class="card-title">Nach Kategorie</h3>
                    </div>
                    <div id="stats-by-category" style="font-size: 0.85rem;">Lade...</div>
                </div>
                <div class="card">
                    <div class="card-header">
                        <h3 class="card-title">Nach Timeframe</h3>
                    </div>
                    <div id="stats-by-timeframe" style="font-size: 0.85rem;">Lade...</div>
                </div>
            </div>
        </div>

        <!-- Training Tab -->
        <div id="tab-training" class="tab-content">
            <!-- Auto-Training (moved to top) -->
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">&#128336; Auto-Training</h3>
                    <div style="display: flex; gap: 0.5rem;">
                        <button class="btn btn-success btn-sm" id="btn-enable-auto" onclick="toggleAutoTraining(true)">
                            &#9654; Aktivieren
                        </button>
                        <button class="btn btn-danger btn-sm" id="btn-disable-auto" onclick="toggleAutoTraining(false)" disabled>
                            &#9632; Deaktivieren
                        </button>
                    </div>
                </div>
                <div id="auto-training-status">
                    <div class="loading"><div class="spinner"></div></div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; margin-top: 1rem;">
                    <div class="form-group" style="margin-bottom: 0;">
                        <label>Intervall</label>
                        <select class="form-control" id="auto-interval">
                            <option value="daily">Täglich</option>
                            <option value="weekly" selected>Wöchentlich</option>
                            <option value="monthly">Monatlich</option>
                            <option value="manual">Manuell</option>
                        </select>
                    </div>
                    <div class="form-group" style="margin-bottom: 0;">
                        <label>Startzeit</label>
                        <div style="display: flex; gap: 0.5rem; align-items: center;">
                            <input type="number" class="form-control" id="auto-scheduled-hour" value="2" min="0" max="23" style="width: 60px; text-align: center;">
                            <span style="color: #888;">:</span>
                            <input type="number" class="form-control" id="auto-scheduled-minute" value="0" min="0" max="59" style="width: 60px; text-align: center;">
                            <span style="color: #888; font-size: 0.85rem;">Uhr</span>
                        </div>
                    </div>
                    <div class="form-group" style="margin-bottom: 0;">
                        <label>Timeframes</label>
                        <div style="display: flex; gap: 1rem; padding-top: 0.5rem;">
                            <label style="display: flex; align-items: center; gap: 0.3rem; cursor: pointer;">
                                <input type="checkbox" id="auto-tf-1h" checked> 1h
                            </label>
                            <label style="display: flex; align-items: center; gap: 0.3rem; cursor: pointer;">
                                <input type="checkbox" id="auto-tf-4h" checked> 4h
                            </label>
                            <label style="display: flex; align-items: center; gap: 0.3rem; cursor: pointer;">
                                <input type="checkbox" id="auto-tf-1d" checked> 1d
                            </label>
                        </div>
                    </div>
                </div>
                <div style="margin-top: 1rem;">
                    <button class="btn btn-primary" id="btn-run-now" onclick="runAutoTrainingNow()">
                        &#9889; Jetzt starten
                    </button>
                </div>
            </div>

            <div class="grid-2-equal">
                <!-- Training Status -->
                <div class="card">
                    <div class="card-header">
                        <h3 class="card-title">&#9881; Training Status</h3>
                    </div>
                    <div id="training-status">
                        <div class="loading"><div class="spinner"></div></div>
                    </div>
                </div>

                <!-- Start Training -->
                <div class="card">
                    <div class="card-header">
                        <h3 class="card-title">&#128295; Manuelles Training</h3>
                    </div>
                    <div class="form-group">
                        <label>Symbole (für Training) <span id="symbols-count" style="color: #888; font-weight: normal;"></span></label>
                        <select class="form-control" id="train-symbols" multiple style="height: 150px;">
                            <option disabled>Lade Symbole...</option>
                        </select>
                        <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
                            <button type="button" class="btn btn-secondary" onclick="selectAllSymbols()" style="flex: 1; padding: 0.3rem;">Alle</button>
                            <button type="button" class="btn btn-secondary" onclick="selectNoSymbols()" style="flex: 1; padding: 0.3rem;">Keine</button>
                        </div>
                        <small style="color: #888;">Ctrl+Klick für Mehrfachauswahl</small>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                        <div class="form-group">
                            <label>Timeframe</label>
                            <select class="form-control" id="train-timeframe">
                                <option value="1h" selected>1h</option>
                                <option value="4h">4h</option>
                                <option value="1d">1d</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Lookback (Tage)</label>
                            <input type="number" class="form-control" id="train-lookback" value="365" min="30" max="1000">
                        </div>
                        <div class="form-group">
                            <label>Epochen</label>
                            <input type="number" class="form-control" id="train-epochs" value="100" min="10" max="1000">
                        </div>
                        <div class="form-group">
                            <label>Batch Size</label>
                            <input type="number" class="form-control" id="train-batch" value="32" min="8" max="128">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Learning Rate</label>
                        <input type="number" class="form-control" id="train-lr" value="0.0001" min="0.00001" max="0.01" step="0.0001">
                    </div>
                    <div style="display: flex; gap: 0.5rem;">
                        <button class="btn btn-success" id="btn-train" onclick="startTraining()">&#9654; Training starten</button>
                        <button class="btn btn-danger" id="btn-stop-train" onclick="stopTraining()" disabled>&#9632; Stoppen</button>
                    </div>
                </div>
            </div>

            <!-- Available Models -->
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">&#128230; Verfugbare Modelle</h3>
                    <button class="btn btn-secondary btn-sm" onclick="loadModels()">&#8635; Aktualisieren</button>
                </div>
                <div id="models-list">
                    <div class="loading"><div class="spinner"></div></div>
                </div>
            </div>

            <!-- Training History -->
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">&#128203; Training-Verlauf</h3>
                </div>
                <div id="training-history">
                    <div class="loading"><div class="spinner"></div></div>
                </div>
            </div>
        </div>

        <!-- History Tab -->
        <div id="tab-history" class="tab-content">
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">&#128203; Erkennungs-Verlauf</h3>
                    <div>
                        <select class="form-control" id="history-symbol" style="width: auto; display: inline-block;">
                            <option value="BTCUSD">BTCUSD</option>
                            <option value="ETHUSD">ETHUSD</option>
                            <option value="EURUSD">EURUSD</option>
                            <option value="XAUUSD">XAUUSD</option>
                        </select>
                        <button class="btn btn-primary btn-sm" onclick="loadHistory()">&#8635; Laden</button>
                    </div>
                </div>
                <div id="pattern-history">
                    <div class="info-box">Wählen Sie ein Symbol und klicken Sie auf "Laden".</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Inference endpoints remain on /tcn, training moved to /tcn-train
        const API_BASE = '/tcn/api/v1';
        const TRAIN_API_BASE = '/tcn-train/api/v1';
        let trainingInterval = null;

        // Tab Navigation
        function showTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`tab-${tabName}`).classList.add('active');
            event.target.classList.add('active');
        }

        // Toast Notification
        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        // Format Uptime
        function formatUptime(seconds) {
            const days = Math.floor(seconds / 86400);
            const hours = Math.floor((seconds % 86400) / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            if (days > 0) return `${days}d ${hours}h`;
            if (hours > 0) return `${hours}h ${mins}m`;
            return `${mins}m`;
        }

        // Parse UTC timestamp (timestamps from API are UTC but without Z suffix)
        function parseUTCTimestamp(timestamp) {
            if (!timestamp) return null;
            // If timestamp doesn't have timezone info, treat as UTC
            if (!timestamp.endsWith('Z') && !timestamp.includes('+')) {
                timestamp = timestamp + 'Z';
            }
            return new Date(timestamp);
        }

        // Format UTC timestamp to local timezone
        function formatLocalDateTime(timestamp, options = { day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit' }) {
            const date = parseUTCTimestamp(timestamp);
            if (!date || isNaN(date.getTime())) return '-';
            return date.toLocaleString('de-CH', { timeZone: 'Europe/Zurich', ...options });
        }

        // Pattern Type Detection
        function getPatternType(pattern) {
            const bullish = ['inverse_head_and_shoulders', 'double_bottom', 'triple_bottom', 'ascending_triangle', 'bull_flag', 'cup_and_handle', 'falling_wedge', 'channel_up'];
            const bearish = ['head_and_shoulders', 'double_top', 'triple_top', 'descending_triangle', 'bear_flag', 'rising_wedge', 'channel_down'];
            if (bullish.includes(pattern)) return 'bullish';
            if (bearish.includes(pattern)) return 'bearish';
            return 'neutral';
        }

        // Load Service Info
        async function loadInfo() {
            try {
                const [infoRes, statsRes, trainStatusRes] = await Promise.all([
                    fetch(`${API_BASE}/info`),
                    fetch(`${API_BASE}/stats`),
                    fetch(`${TRAIN_API_BASE}/train/status`).catch(() => null)
                ]);

                if (!infoRes.ok || !statsRes.ok) throw new Error('Failed to load data');

                const info = await infoRes.json();
                const stats = await statsRes.json();
                const trainStatus = trainStatusRes?.ok ? await trainStatusRes.json() : { status: 'unknown' };
                const isTraining = trainStatus.status === 'training' || trainStatus.status === 'preparing';

                // Update status badge
                const badge = document.getElementById('status-badge');
                badge.textContent = info.model?.loaded ? 'Online' : 'Offline';
                badge.className = `service-badge ${info.model?.loaded ? '' : 'offline'}`;

                // Update stats - info has num_classes at top level, model info under model object
                document.getElementById('stat-patterns').textContent = info.num_classes || info.model?.num_classes || '-';
                document.getElementById('stat-params').textContent = info.model?.parameters ? (info.model.parameters / 1000000).toFixed(2) + 'M' : '-';
                document.getElementById('stat-uptime').textContent = stats.uptime_seconds ? formatUptime(stats.uptime_seconds) : '-';
                document.getElementById('stat-models').textContent = stats.available_models || 0;

                // Model Info - Training status now comes from TCN-Train service
                document.getElementById('model-info').innerHTML = `
                    <table class="data-table">
                        <tr><td style="color: #888;">Service</td><td>${info.service}</td></tr>
                        <tr><td style="color: #888;">Version</td><td>${info.version}</td></tr>
                        <tr><td style="color: #888;">Gestartet</td><td>${formatLocalDateTime(info.started_at, { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' })}</td></tr>
                        <tr><td style="color: #888;">Modell geladen</td><td>${info.model?.loaded ? '<span style="color: #4caf50;">Ja</span>' : '<span style="color: #f44336;">Nein</span>'}</td></tr>
                        <tr><td style="color: #888;">Pattern-Klassen</td><td>${info.num_classes || info.model?.num_classes || '-'}</td></tr>
                        <tr><td style="color: #888;">Parameter</td><td>${info.model?.parameters?.toLocaleString() || '-'}</td></tr>
                        <tr><td style="color: #888;">Training aktiv</td><td>${isTraining ? '<span style="color: #ffc107;">Ja</span>' : 'Nein'}</td></tr>
                    </table>
                `;

                // Pattern Classes - pattern_classes is at top level in info response
                const patterns = info.pattern_classes || info.model?.pattern_classes || [];
                document.getElementById('pattern-classes').innerHTML = patterns.length > 0
                    ? patterns.map(p => `<span class="pattern-badge ${getPatternType(p)}">${p.replace(/_/g, ' ')}</span>`).join('')
                    : '<span style="color: #888;">Keine Pattern geladen</span>';

                // Service Status - model info is under stats.model
                const modelLoaded = stats.model?.loaded || false;
                document.getElementById('service-status').innerHTML = `
                    <div class="grid-3">
                        <div style="text-align: center; padding: 1rem; background: rgba(255,255,255,0.03); border-radius: 8px;">
                            <div style="font-size: 1.5rem; color: #64c8ff;">${stats.training_history_count || 0}</div>
                            <div style="color: #888; font-size: 0.85rem;">Training Sessions</div>
                        </div>
                        <div style="text-align: center; padding: 1rem; background: rgba(255,255,255,0.03); border-radius: 8px;">
                            <div style="font-size: 1.5rem; color: ${modelLoaded ? '#4caf50' : '#f44336'};">${modelLoaded ? 'Bereit' : 'Nicht bereit'}</div>
                            <div style="color: #888; font-size: 0.85rem;">Model Status</div>
                        </div>
                        <div style="text-align: center; padding: 1rem; background: rgba(255,255,255,0.03); border-radius: 8px;">
                            <div style="font-size: 1.5rem; color: #a78bfa;">${stats.available_models || 0}</div>
                            <div style="color: #888; font-size: 0.85rem;">Verfugbare Modelle</div>
                        </div>
                    </div>
                `;

            } catch (error) {
                showToast('Fehler beim Laden der Service-Info', 'error');
                console.error(error);
            }
        }

        // Detect Pattern
        async function detectPattern() {
            const btn = document.getElementById('btn-detect');
            btn.classList.add('btn-loading');
            btn.disabled = true;

            try {
                const symbol = document.getElementById('detect-symbol').value;
                const timeframe = document.getElementById('detect-timeframe').value;
                const minConfidence = parseFloat(document.getElementById('detect-confidence').value);

                const response = await fetch(`${API_BASE}/detect/${symbol}?timeframe=${timeframe}&min_confidence=${minConfidence}`);
                if (!response.ok) throw new Error('Detection failed');

                const data = await response.json();
                const result = document.getElementById('detection-result');

                if (data.patterns && data.patterns.length > 0) {
                    result.innerHTML = data.patterns.map(p => `
                        <div class="detection-result">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span class="pattern-badge ${getPatternType(p.pattern_type)}" style="font-size: 0.9rem;">${p.pattern_type.replace(/_/g, ' ')}</span>
                                <span style="color: #64c8ff; font-weight: 600;">${(p.confidence * 100).toFixed(1)}%</span>
                            </div>
                            <div class="confidence-bar">
                                <div class="confidence-fill ${p.confidence >= 0.8 ? 'high' : p.confidence >= 0.6 ? 'medium' : 'low'}" style="width: ${p.confidence * 100}%"></div>
                            </div>
                            ${p.price_target ? `<div style="margin-top: 0.5rem; color: #888;">Ziel: ${p.price_target.toFixed(2)}</div>` : ''}
                        </div>
                    `).join('');
                } else {
                    result.innerHTML = '<div class="detection-result" style="color: #888; text-align: center;">Keine Pattern erkannt</div>';
                }

                showToast(`Pattern-Erkennung fur ${symbol} abgeschlossen`);
            } catch (error) {
                showToast('Fehler bei der Pattern-Erkennung', 'error');
                console.error(error);
            } finally {
                btn.classList.remove('btn-loading');
                btn.disabled = false;
            }
        }

        // =============================================================================
        // Auto-Scan Functions (Pattern Detection)
        // =============================================================================

        // Load Auto-Scan Status for Detection Tab
        async function loadAutoScanStatus() {
            try {
                const response = await fetch(`${API_BASE}/history/statistics`);
                if (!response.ok) throw new Error('Failed to load auto-scan status');

                const stats = await response.json();

                // Update status indicator
                const statusIndicator = document.getElementById('autoscan-status-indicator');
                if (stats.scan_running) {
                    statusIndicator.innerHTML = '<span style="color: #4caf50;">Aktiv</span>';
                    document.getElementById('btn-start-autoscan').disabled = true;
                    document.getElementById('btn-stop-autoscan').disabled = false;
                } else {
                    statusIndicator.innerHTML = '<span style="color: #ffc107;">Gestoppt</span>';
                    document.getElementById('btn-start-autoscan').disabled = false;
                    document.getElementById('btn-stop-autoscan').disabled = true;
                }

                // Update other stats
                document.getElementById('autoscan-total').textContent = stats.total_patterns || 0;
                document.getElementById('autoscan-symbols').textContent = stats.symbols_with_patterns || 0;
                document.getElementById('autoscan-lastscan').textContent = stats.last_scan
                    ? formatLocalDateTime(stats.last_scan)
                    : '-';

            } catch (error) {
                console.error('Error loading auto-scan status:', error);
            }
        }

        // Toggle Auto-Scan
        async function toggleAutoScan(enable) {
            const endpoint = enable ? 'start-auto-scan' : 'stop-auto-scan';
            const btn = enable ? document.getElementById('btn-start-autoscan') : document.getElementById('btn-stop-autoscan');
            btn.classList.add('btn-loading');
            btn.disabled = true;

            try {
                const response = await fetch(`${API_BASE}/history/${endpoint}`, { method: 'POST' });
                if (!response.ok) throw new Error('Failed to toggle auto-scan');

                const result = await response.json();
                showToast(enable ? 'Auto-Erkennung gestartet' : 'Auto-Erkennung gestoppt');
                loadAutoScanStatus();

            } catch (error) {
                showToast('Fehler beim Ändern des Auto-Scan Status', 'error');
                console.error(error);
            } finally {
                btn.classList.remove('btn-loading');
            }
        }

        // Load Symbols for Detection Dropdown
        async function loadDetectionSymbols() {
            const select = document.getElementById('detect-symbol');

            try {
                const response = await fetch('/data/api/v1/managed-symbols');
                if (!response.ok) throw new Error('Failed to load symbols');

                const data = await response.json();

                // Filter active symbols with data
                const symbols = data
                    .filter(s => s.has_timescaledb_data && s.status === 'active')
                    .sort((a, b) => a.symbol.localeCompare(b.symbol));

                select.innerHTML = '';

                // Add default option
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = 'Symbol wählen...';
                select.appendChild(defaultOption);

                // Add symbols
                symbols.forEach(s => {
                    const option = document.createElement('option');
                    option.value = s.symbol;
                    option.textContent = s.display_name || s.symbol;
                    select.appendChild(option);
                });

                // Select first symbol if available
                if (symbols.length > 0) {
                    select.value = symbols[0].symbol;
                }

            } catch (error) {
                console.error('Error loading detection symbols:', error);
                // Fallback
                select.innerHTML = `
                    <option value="BTCUSD">BTCUSD</option>
                    <option value="ETHUSD">ETHUSD</option>
                    <option value="EURUSD">EURUSD</option>
                    <option value="XAUUSD">XAUUSD</option>
                `;
            }
        }

        // Scan All Symbols and Save to History
        async function scanAllAndSave() {
            const btn = document.getElementById('btn-scan-all');
            btn.classList.add('btn-loading');
            btn.disabled = true;

            try {
                // Use the history/scan endpoint which saves to history
                const response = await fetch(`${API_BASE}/history/scan`, { method: 'POST' });
                if (!response.ok) throw new Error('Scan failed');

                const result = await response.json();
                const results = document.getElementById('scan-results');

                results.innerHTML = `
                    <div class="info-box" style="background: rgba(76,175,80,0.1); border-color: rgba(76,175,80,0.3); color: #81c784;">
                        <strong>Scan abgeschlossen</strong><br>
                        ${result.patterns_found || 0} Patterns gefunden, ${result.patterns_added || 0} neu gespeichert
                    </div>
                `;

                showToast(`Scan: ${result.patterns_found || 0} Patterns gefunden`);

                // Refresh stats
                loadAutoScanStatus();

            } catch (error) {
                showToast('Fehler beim Scan', 'error');
                console.error(error);
            } finally {
                btn.classList.remove('btn-loading');
                btn.disabled = false;
            }
        }

        // Legacy function for backwards compatibility
        async function scanAll() {
            return scanAllAndSave();
        }

        // Format duration from start time
        function formatDuration(startTimeISO) {
            if (!startTimeISO) return '-';
            const start = new Date(startTimeISO);
            const now = new Date();
            const diffMs = now - start;
            const diffSecs = Math.floor(diffMs / 1000);
            const mins = Math.floor(diffSecs / 60);
            const secs = diffSecs % 60;
            const hours = Math.floor(mins / 60);
            if (hours > 0) return `${hours}h ${mins % 60}m ${secs}s`;
            if (mins > 0) return `${mins}m ${secs}s`;
            return `${secs}s`;
        }

        // Load Training Status
        async function loadTrainingStatus() {
            try {
                const response = await fetch(`${TRAIN_API_BASE}/train/status`);
                if (!response.ok) throw new Error('Failed to load training status');

                const data = await response.json();
                const container = document.getElementById('training-status');

                const isTraining = data.status === 'training' || data.status === 'preparing';

                if (isTraining) {
                    document.getElementById('btn-train').disabled = true;
                    document.getElementById('btn-stop-train').disabled = false;

                    const progressPercent = data.progress ? (data.progress * 100).toFixed(1) : 0;
                    const duration = formatDuration(data.started_at);

                    container.innerHTML = `
                        <div style="background: linear-gradient(135deg, rgba(76,175,80,0.15), rgba(76,175,80,0.05)); border: 1px solid rgba(76,175,80,0.3); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                                <span style="color: #4caf50; font-weight: 600; display: flex; align-items: center; gap: 0.5rem;">
                                    <span class="spinner" style="width: 16px; height: 16px; border-width: 2px;"></span>
                                    Training lauft...
                                </span>
                                <span style="background: #4caf50; color: #000; padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.8rem; font-weight: 600;">
                                    ${progressPercent}%
                                </span>
                            </div>
                            <div class="progress-bar" style="height: 8px; margin-bottom: 0.75rem;">
                                <div class="progress-fill" style="width: ${progressPercent}%; background: linear-gradient(90deg, #4caf50, #81c784);"></div>
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem; font-size: 0.85rem;">
                                <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 4px;">
                                    <div style="color: #888;">Epoche</div>
                                    <div style="color: #fff; font-weight: 600;">${data.current_epoch || 0} / ${data.total_epochs || '-'}</div>
                                </div>
                                <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 4px;">
                                    <div style="color: #888;">Laufzeit</div>
                                    <div style="color: #fff; font-weight: 600;">${duration}</div>
                                </div>
                                <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 4px;">
                                    <div style="color: #888;">Samples</div>
                                    <div style="color: #fff; font-weight: 600;">${data.samples_count?.toLocaleString() || '-'}</div>
                                </div>
                                <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 4px;">
                                    <div style="color: #888;">Best Loss</div>
                                    <div style="color: #fff; font-weight: 600;">${data.best_loss?.toFixed(4) || '-'}</div>
                                </div>
                            </div>
                            ${data.job_id ? `<div style="margin-top: 0.75rem; color: #666; font-size: 0.75rem;">Job: ${data.job_id}</div>` : ''}
                        </div>
                    `;
                } else {
                    document.getElementById('btn-train').disabled = false;
                    document.getElementById('btn-stop-train').disabled = true;

                    // Try to get last training info
                    try {
                        const histResponse = await fetch(`${TRAIN_API_BASE}/train/history`);
                        if (histResponse.ok) {
                            const histData = await histResponse.json();
                            if (histData.history && histData.history.length > 0) {
                                // Get most recent training
                                const lastTraining = [...histData.history].sort((a, b) =>
                                    new Date(b.started_at) - new Date(a.started_at)
                                )[0];

                                let duration = '-';
                                if (lastTraining.started_at && lastTraining.completed_at) {
                                    const durationSecs = Math.floor((new Date(lastTraining.completed_at) - new Date(lastTraining.started_at)) / 1000);
                                    duration = formatUptime(durationSecs);
                                }

                                container.innerHTML = `
                                    <div style="text-align: center; padding: 1rem; color: #888; margin-bottom: 1rem;">
                                        <div style="font-size: 1.5rem; margin-bottom: 0.3rem;">&#9989;</div>
                                        <div>Bereit für Training</div>
                                    </div>
                                    <div style="background: rgba(255,255,255,0.03); padding: 0.75rem; border-radius: 6px; font-size: 0.85rem;">
                                        <div style="color: #888; margin-bottom: 0.5rem;">Letztes Training:</div>
                                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                                            <div><span style="color: #888;">Status:</span> <span style="color: ${lastTraining.status === 'completed' ? '#4caf50' : '#f44336'};">${lastTraining.status}</span></div>
                                            <div><span style="color: #888;">Datum:</span> ${formatLocalDateTime(lastTraining.started_at)}</div>
                                            <div><span style="color: #888;">Epochen:</span> ${lastTraining.current_epoch || 0}/${lastTraining.total_epochs || '-'}</div>
                                            <div><span style="color: #888;">Loss:</span> ${lastTraining.best_loss?.toFixed(4) || '-'}</div>
                                        </div>
                                    </div>
                                `;
                                return;
                            }
                        }
                    } catch (e) {
                        // Ignore error, show default message
                    }

                    container.innerHTML = `
                        <div style="text-align: center; padding: 1.5rem; color: #888;">
                            <div style="font-size: 2rem; margin-bottom: 0.5rem;">&#9989;</div>
                            <div>Bereit für Training</div>
                            <div style="font-size: 0.85rem; margin-top: 0.5rem;">Noch keine Trainings durchgeführt</div>
                        </div>
                    `;
                }
            } catch (error) {
                console.error(error);
            }
        }

        // Start Training
        async function startTraining() {
            const btn = document.getElementById('btn-train');
            btn.classList.add('btn-loading');
            btn.disabled = true;

            try {
                // Get selected symbols
                const symbolSelect = document.getElementById('train-symbols');
                const symbols = Array.from(symbolSelect.selectedOptions).map(o => o.value);
                if (symbols.length === 0) {
                    showToast('Bitte mindestens ein Symbol auswahlen', 'error');
                    btn.classList.remove('btn-loading');
                    btn.disabled = false;
                    return;
                }

                const timeframe = document.getElementById('train-timeframe').value;
                const lookbackDays = parseInt(document.getElementById('train-lookback').value);
                const epochs = parseInt(document.getElementById('train-epochs').value);
                const batchSize = parseInt(document.getElementById('train-batch').value);
                const learningRate = parseFloat(document.getElementById('train-lr').value);

                const response = await fetch(`${TRAIN_API_BASE}/train`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        symbols,
                        timeframe,
                        lookback_days: lookbackDays,
                        epochs,
                        batch_size: batchSize,
                        learning_rate: learningRate
                    })
                });

                if (!response.ok) {
                    const errData = await response.json();
                    throw new Error(errData.detail || 'Failed to start training');
                }

                showToast('Training gestartet');
                document.getElementById('btn-stop-train').disabled = false;

                // Start polling for status
                trainingInterval = setInterval(loadTrainingStatus, 2000);

            } catch (error) {
                showToast('Fehler beim Starten des Trainings', 'error');
                console.error(error);
                btn.disabled = false;
            } finally {
                btn.classList.remove('btn-loading');
            }
        }

        // Stop Training
        async function stopTraining() {
            try {
                const response = await fetch(`${TRAIN_API_BASE}/train/stop`, { method: 'POST' });
                if (!response.ok) throw new Error('Failed to stop training');

                showToast('Training gestoppt');
                if (trainingInterval) {
                    clearInterval(trainingInterval);
                    trainingInterval = null;
                }
                loadTrainingStatus();
            } catch (error) {
                showToast('Fehler beim Stoppen des Trainings', 'error');
                console.error(error);
            }
        }

        // Load Training History
        async function loadTrainingHistory() {
            try {
                const response = await fetch(`${TRAIN_API_BASE}/train/history`);
                if (!response.ok) throw new Error('Failed to load history');

                const data = await response.json();
                const container = document.getElementById('training-history');

                if (data.history && data.history.length > 0) {
                    // Sort by date (newest first)
                    const sortedHistory = [...data.history].sort((a, b) =>
                        new Date(b.started_at) - new Date(a.started_at)
                    );

                    container.innerHTML = `
                        <table class="data-table">
                            <tr>
                                <th>Datum</th>
                                <th>Status</th>
                                <th>Epochen</th>
                                <th>Samples</th>
                                <th>Best Loss</th>
                                <th>Dauer</th>
                            </tr>
                            ${sortedHistory.map(h => {
                                // Calculate duration from started_at and completed_at
                                let duration = '-';
                                if (h.started_at && h.completed_at) {
                                    const startDate = parseUTCTimestamp(h.started_at);
                                    const endDate = parseUTCTimestamp(h.completed_at);
                                    if (startDate && endDate) {
                                        const durationSecs = Math.floor((endDate - startDate) / 1000);
                                        duration = formatUptime(durationSecs);
                                    }
                                }
                                const statusColor = h.status === 'completed' ? '#4caf50' : h.status === 'failed' ? '#f44336' : '#ffc107';
                                return `
                                <tr>
                                    <td>${formatLocalDateTime(h.started_at)}</td>
                                    <td><span style="color: ${statusColor};">${h.status}</span></td>
                                    <td>${h.current_epoch || 0}/${h.total_epochs || '-'}</td>
                                    <td>${h.samples_count?.toLocaleString() || '-'}</td>
                                    <td>${h.best_loss?.toFixed(4) || '-'}</td>
                                    <td>${duration}</td>
                                </tr>
                            `}).join('')}
                        </table>
                    `;
                } else {
                    container.innerHTML = '<div class="info-box">Noch keine Trainings durchgeführt.</div>';
                }
            } catch (error) {
                console.error(error);
            }
        }

        // Load Available Models
        async function loadModels() {
            const container = document.getElementById('models-list');

            try {
                const response = await fetch(`${TRAIN_API_BASE}/models`);
                if (!response.ok) throw new Error('Failed to load models');

                const data = await response.json();

                if (data.models && data.models.length > 0) {
                    // Sort by creation date (newest first)
                    const sortedModels = data.models.sort((a, b) =>
                        new Date(b.created) - new Date(a.created)
                    );

                    container.innerHTML = `
                        <div style="margin-bottom: 0.5rem; color: #888; font-size: 0.85rem;">
                            ${data.count} Modell${data.count !== 1 ? 'e' : ''} verfugbar
                        </div>
                        ${sortedModels.map((m, idx) => `
                            <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; background: ${idx === 0 ? 'rgba(76,175,80,0.1)' : 'rgba(255,255,255,0.03)'}; border: 1px solid ${idx === 0 ? 'rgba(76,175,80,0.3)' : 'rgba(255,255,255,0.05)'}; border-radius: 6px; margin-bottom: 0.5rem;">
                                <div style="flex: 1;">
                                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                                        <span style="font-weight: 600; color: #fff;">${m.name}</span>
                                        ${idx === 0 ? '<span style="background: #4caf50; color: #000; padding: 0.1rem 0.4rem; border-radius: 3px; font-size: 0.7rem; font-weight: 600;">AKTUELL</span>' : ''}
                                    </div>
                                    <div style="display: flex; gap: 1rem; margin-top: 0.3rem; font-size: 0.8rem; color: #888;">
                                        <span>&#128197; ${formatLocalDateTime(m.created, { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' })}</span>
                                        <span>&#128190; ${m.size_mb} MB</span>
                                    </div>
                                </div>
                                <button class="btn btn-secondary btn-sm" onclick="loadModel('${m.name}')" ${idx === 0 ? 'disabled' : ''}>
                                    ${idx === 0 ? '&#10004; Geladen' : '&#128194; Laden'}
                                </button>
                            </div>
                        `).join('')}
                    `;
                } else {
                    container.innerHTML = `
                        <div class="info-box" style="text-align: center;">
                            <div style="font-size: 2rem; margin-bottom: 0.5rem;">&#128230;</div>
                            <div>Keine trainierten Modelle vorhanden</div>
                            <div style="font-size: 0.85rem; color: #666; margin-top: 0.5rem;">
                                Starten Sie ein Training um ein Modell zu erstellen
                            </div>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('Error loading models:', error);
                container.innerHTML = '<div class="info-box" style="color: #e57373;">Fehler beim Laden der Modelle</div>';
            }
        }

        // Load specific model (reload model in inference service)
        async function loadModel(modelName) {
            try {
                // Notify inference service to reload the model
                const response = await fetch(`${API_BASE}/model/reload`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ model_path: `data/models/tcn/${modelName}` })
                });

                if (!response.ok) {
                    const errData = await response.json();
                    throw new Error(errData.detail || 'Failed to load model');
                }

                showToast(`Modell ${modelName} geladen`);
                loadModels(); // Refresh list
                loadInfo();   // Refresh service info
            } catch (error) {
                showToast('Fehler beim Laden des Modells', 'error');
                console.error(error);
            }
        }

        // Load Pattern History Statistics
        async function loadHistoryStats() {
            try {
                const response = await fetch(`${API_BASE}/history/statistics`);
                if (!response.ok) throw new Error('Failed to load history stats');

                const stats = await response.json();

                // Pattern types (top 5)
                const typeHtml = Object.entries(stats.by_pattern_type || {}).slice(0, 5)
                    .map(([type, count]) => `<div style="display: flex; justify-content: space-between; padding: 0.25rem 0;"><span>${type.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ')}</span><span style="color: #64c8ff;">${count}</span></div>`)
                    .join('');
                document.getElementById('stats-by-type').innerHTML = typeHtml || '<span style="color: #888;">Keine Daten</span>';

                // Categories
                const catHtml = Object.entries(stats.by_category || {})
                    .map(([cat, count]) => `<div style="display: flex; justify-content: space-between; padding: 0.25rem 0;"><span>${cat}</span><span style="color: #a78bfa;">${count}</span></div>`)
                    .join('');
                document.getElementById('stats-by-category').innerHTML = catHtml || '<span style="color: #888;">Keine Daten</span>';

                // Timeframes
                const tfHtml = Object.entries(stats.by_timeframe || {})
                    .map(([tf, count]) => `<div style="display: flex; justify-content: space-between; padding: 0.25rem 0;"><span>${tf}</span><span style="color: #ffc107;">${count}</span></div>`)
                    .join('');
                document.getElementById('stats-by-timeframe').innerHTML = tfHtml || '<span style="color: #888;">Keine Daten</span>';

            } catch (error) {
                console.error('Error loading history stats:', error);
            }
        }

        // Pattern Filter Storage Key
        const PATTERN_FILTERS_KEY = 'tcn_pattern_filters';

        // Save pattern filters to localStorage
        function savePatternFilters() {
            const filters = {
                symbol: document.getElementById('history-symbol-filter').value,
                pattern: document.getElementById('history-pattern-filter').value,
                timeframe: document.getElementById('history-timeframe-filter').value,
                category: document.getElementById('history-category-filter').value,
                direction: document.getElementById('history-direction-filter').value,
                confidence: document.getElementById('history-confidence-filter').value
            };
            localStorage.setItem(PATTERN_FILTERS_KEY, JSON.stringify(filters));
            updateResetButtonVisibility();
        }

        // Load pattern filters from localStorage
        function loadPatternFilters() {
            try {
                const saved = localStorage.getItem(PATTERN_FILTERS_KEY);
                if (saved) {
                    const filters = JSON.parse(saved);
                    if (filters.symbol) document.getElementById('history-symbol-filter').value = filters.symbol;
                    if (filters.pattern) document.getElementById('history-pattern-filter').value = filters.pattern;
                    if (filters.timeframe) document.getElementById('history-timeframe-filter').value = filters.timeframe;
                    if (filters.category) document.getElementById('history-category-filter').value = filters.category;
                    if (filters.direction) document.getElementById('history-direction-filter').value = filters.direction;
                    if (filters.confidence) document.getElementById('history-confidence-filter').value = filters.confidence;
                }
            } catch (e) {
                console.error('Error loading filters:', e);
            }
            updateResetButtonVisibility();
        }

        // Reset all pattern filters
        function resetPatternFilters() {
            document.getElementById('history-symbol-filter').value = '';
            document.getElementById('history-pattern-filter').value = '';
            document.getElementById('history-timeframe-filter').value = '';
            document.getElementById('history-category-filter').value = '';
            document.getElementById('history-direction-filter').value = '';
            document.getElementById('history-confidence-filter').value = '';
            localStorage.removeItem(PATTERN_FILTERS_KEY);
            updateResetButtonVisibility();
            loadPatternHistory();
        }

        // Show/hide reset button based on active filters
        function updateResetButtonVisibility() {
            const hasFilters =
                document.getElementById('history-symbol-filter').value ||
                document.getElementById('history-pattern-filter').value ||
                document.getElementById('history-timeframe-filter').value ||
                document.getElementById('history-category-filter').value ||
                document.getElementById('history-direction-filter').value ||
                document.getElementById('history-confidence-filter').value;

            const btn = document.getElementById('btn-reset-filters');
            if (btn) {
                btn.style.display = hasFilters ? 'inline-block' : 'none';
            }
        }

        // Load Pattern History Table
        async function loadPatternHistory() {
            const symbol = document.getElementById('history-symbol-filter').value;
            const patternType = document.getElementById('history-pattern-filter').value;
            const timeframe = document.getElementById('history-timeframe-filter').value;
            const category = document.getElementById('history-category-filter').value;
            const direction = document.getElementById('history-direction-filter').value;
            const minConfidence = document.getElementById('history-confidence-filter').value;

            // Save filters to localStorage
            savePatternFilters();

            let url = `${API_BASE}/history?limit=50`;
            if (symbol) url += `&symbol=${symbol}`;
            if (patternType) url += `&pattern_type=${patternType}`;
            if (timeframe) url += `&timeframe=${timeframe}`;
            if (category) url += `&category=${category}`;
            if (direction) url += `&direction=${direction}`;
            if (minConfidence) url += `&min_confidence=${minConfidence}`;

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error('Failed to load pattern history');

                const data = await response.json();
                const tbody = document.getElementById('pattern-history-body');

                if (!data.patterns || data.patterns.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; padding: 2rem; color: #888;">Keine Patterns gefunden</td></tr>';
                    document.getElementById('history-count').textContent = '0 Patterns';
                    return;
                }

                // Store pattern data for click handlers
                window.patternHistoryData = {};
                data.patterns.forEach((p, idx) => {
                    window.patternHistoryData[`pattern_${idx}`] = p.pattern_points || null;
                });

                tbody.innerHTML = data.patterns.map((p, idx) => `
                    <tr class="clickable-row" onclick="showPatternChart('${p.symbol}', '${p.timeframe}', '${p.detected_at}', '${p.pattern_type}', '${p.direction}', window.patternHistoryData['pattern_${idx}'])">
                        <td style="font-weight: 500;">${p.symbol}</td>
                        <td><span class="pattern-badge ${p.direction}">${p.pattern_type.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ')}</span></td>
                        <td><span class="pattern-badge ${p.direction}">${p.direction}</span></td>
                        <td style="color: ${p.confidence >= 0.7 ? '#4caf50' : p.confidence >= 0.5 ? '#ffc107' : '#f44336'};">${(p.confidence * 100).toFixed(1)}%</td>
                        <td>${p.timeframe}</td>
                        <td style="color: #888;">${formatLocalDateTime(p.detected_at)}</td>
                        <td style="font-family: monospace;">${p.price_at_detection ? p.price_at_detection.toLocaleString('de-CH', {maximumFractionDigits: 2}) : '-'}</td>
                        <td style="text-align: center;">
                            <button type="button" class="btn-chart" onclick="event.stopPropagation(); showPatternChart('${p.symbol}', '${p.timeframe}', '${p.detected_at}', '${p.pattern_type}', '${p.direction}', window.patternHistoryData['pattern_${idx}'])" title="Chart anzeigen">
                                &#128200;
                            </button>
                        </td>
                    </tr>
                `).join('');

                document.getElementById('history-count').textContent = `${data.count} Patterns angezeigt`;

                // Update symbol filter
                await updateHistorySymbolFilter();

            } catch (error) {
                console.error('Error loading pattern history:', error);
                document.getElementById('pattern-history-body').innerHTML =
                    '<tr><td colspan="8" style="text-align: center; padding: 2rem; color: #f44336;">Fehler beim Laden</td></tr>';
            }
        }

        // Update symbol filter dropdown
        async function updateHistorySymbolFilter() {
            try {
                const response = await fetch(`${API_BASE}/history-by-symbol?limit_per_symbol=1`);
                if (!response.ok) return;

                const data = await response.json();
                const select = document.getElementById('history-symbol-filter');
                const currentValue = select.value;

                // Keep first option
                while (select.options.length > 1) {
                    select.remove(1);
                }

                Object.keys(data.by_symbol || {}).sort().forEach(symbol => {
                    const option = document.createElement('option');
                    option.value = symbol;
                    option.textContent = symbol;
                    select.appendChild(option);
                });

                select.value = currentValue;
            } catch (error) {
                console.error('Error updating symbol filter:', error);
            }
        }

        // Trigger manual pattern scan
        async function triggerManualScan() {
            try {
                showToast('Scan gestartet...');
                const response = await fetch(`${API_BASE}/history/scan`, { method: 'POST' });
                if (!response.ok) throw new Error('Scan failed');

                const result = await response.json();
                showToast(`Scan abgeschlossen: ${result.patterns_found} Patterns gefunden, ${result.patterns_added} neu`);

                loadPatternHistory();
                loadHistoryStats();
            } catch (error) {
                showToast('Fehler beim Scan', 'error');
                console.error(error);
            }
        }

        // Load Available Symbols from Data Service
        async function loadAvailableSymbols() {
            const select = document.getElementById('train-symbols');
            const countSpan = document.getElementById('symbols-count');

            try {
                // managed-symbols liefert Array mit {symbol, category, has_timescaledb_data, ...}
                const response = await fetch('/data/api/v1/managed-symbols');
                if (!response.ok) throw new Error('Failed to load symbols');

                const data = await response.json();

                // Nur Symbole mit Daten, sortiert nach Kategorie und Name
                const symbols = data
                    .filter(s => s.has_timescaledb_data && s.status === 'active')
                    .sort((a, b) => {
                        // Erst nach Kategorie, dann alphabetisch
                        if (a.category !== b.category) return a.category.localeCompare(b.category);
                        return a.symbol.localeCompare(b.symbol);
                    });

                select.innerHTML = '';
                let currentCategory = '';

                symbols.forEach(s => {
                    // Optgroup für Kategorien
                    if (s.category !== currentCategory) {
                        currentCategory = s.category;
                        const optgroup = document.createElement('optgroup');
                        optgroup.label = currentCategory.toUpperCase();
                        select.appendChild(optgroup);
                    }

                    const option = document.createElement('option');
                    option.value = s.symbol;
                    option.textContent = s.display_name || s.symbol;
                    option.selected = true; // Alle standardmässig ausgewählt
                    select.lastElementChild.appendChild(option);
                });

                countSpan.textContent = `(${symbols.length} verfugbar)`;

            } catch (error) {
                console.error('Error loading symbols:', error);
                // Fallback auf einige Standard-Symbole
                select.innerHTML = `
                    <option value="BTCUSD" selected>BTCUSD</option>
                    <option value="ETHUSD" selected>ETHUSD</option>
                    <option value="EURUSD" selected>EURUSD</option>
                    <option value="XAUUSD" selected>XAUUSD</option>
                `;
                countSpan.textContent = '(Fallback)';
            }
        }

        // Select All Symbols
        function selectAllSymbols() {
            const select = document.getElementById('train-symbols');
            Array.from(select.options).forEach(o => o.selected = true);
        }

        // Select No Symbols
        function selectNoSymbols() {
            const select = document.getElementById('train-symbols');
            Array.from(select.options).forEach(o => o.selected = false);
        }

        // =============================================================================
        // Auto-Training Functions
        // =============================================================================

        // Load Auto-Training Status
        async function loadAutoTrainingStatus() {
            const container = document.getElementById('auto-training-status');

            try {
                const response = await fetch(`${TRAIN_API_BASE}/auto-training/status`);
                if (!response.ok) throw new Error('Failed to load auto-training status');

                const data = await response.json();

                // Update interval dropdown
                document.getElementById('auto-interval').value = data.interval || 'weekly';

                // Update scheduled time inputs
                document.getElementById('auto-scheduled-hour').value = data.scheduled_hour ?? 2;
                document.getElementById('auto-scheduled-minute').value = data.scheduled_minute ?? 0;

                // Update timeframe checkboxes
                const timeframes = data.timeframes || ['1h', '4h', '1d'];
                document.getElementById('auto-tf-1h').checked = timeframes.includes('1h');
                document.getElementById('auto-tf-4h').checked = timeframes.includes('4h');
                document.getElementById('auto-tf-1d').checked = timeframes.includes('1d');

                // Update buttons
                document.getElementById('btn-enable-auto').disabled = data.enabled;
                document.getElementById('btn-disable-auto').disabled = !data.enabled;

                // Format dates
                const lastRun = data.last_run ? formatLocalDateTime(data.last_run, { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' }) : 'Noch nie';
                const nextRun = data.next_run ? formatLocalDateTime(data.next_run, { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' }) : '-';

                const intervalLabels = {
                    'daily': 'Taglich',
                    'weekly': 'Wochentlich',
                    'monthly': 'Monatlich',
                    'manual': 'Manuell'
                };

                const scheduledTime = data.scheduled_time || `${String(data.scheduled_hour ?? 2).padStart(2, '0')}:${String(data.scheduled_minute ?? 0).padStart(2, '0')}`;

                container.innerHTML = `
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; font-size: 0.85rem;">
                        <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 4px;">
                            <div style="color: #888;">Status</div>
                            <div style="color: ${data.enabled ? '#4caf50' : '#888'}; font-weight: 600;">
                                ${data.enabled ? '&#10004; Aktiv' : '&#10008; Inaktiv'}
                            </div>
                        </div>
                        <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 4px;">
                            <div style="color: #888;">Intervall</div>
                            <div style="color: #fff; font-weight: 600;">${intervalLabels[data.interval] || data.interval}</div>
                        </div>
                        <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 4px;">
                            <div style="color: #888;">Startzeit</div>
                            <div style="color: #64c8ff; font-weight: 600;">${scheduledTime} Uhr</div>
                        </div>
                        <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 4px;">
                            <div style="color: #888;">Letzter Lauf</div>
                            <div style="color: #fff; font-weight: 600;">${lastRun}</div>
                        </div>
                        <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 4px; grid-column: span 2;">
                            <div style="color: #888;">Nächster Lauf</div>
                            <div style="color: #fff; font-weight: 600;">${nextRun}</div>
                        </div>
                    </div>
                    ${data.current_training ? `
                        <div style="margin-top: 0.75rem; padding: 0.5rem; background: rgba(100,200,255,0.1); border: 1px solid rgba(100,200,255,0.3); border-radius: 4px;">
                            <div style="color: #64c8ff; font-weight: 600;">Training lauft...</div>
                            <div style="font-size: 0.8rem; color: #888; margin-top: 0.25rem;">
                                ${data.current_training.symbols?.length || 0} Symbole,
                                ${data.current_training.completed_timeframes?.length || 0}/${data.current_training.timeframes?.length || 0} Timeframes
                            </div>
                        </div>
                    ` : ''}
                `;

            } catch (error) {
                console.error('Error loading auto-training status:', error);
                container.innerHTML = '<div class="info-box" style="color: #e57373;">Fehler beim Laden des Auto-Training Status</div>';
            }
        }

        // Toggle Auto-Training
        async function toggleAutoTraining(enable) {
            try {
                const endpoint = enable ? 'enable' : 'disable';
                const response = await fetch(`${TRAIN_API_BASE}/auto-training/${endpoint}`, {
                    method: 'POST'
                });

                if (!response.ok) throw new Error('Failed to toggle auto-training');

                showToast(enable ? 'Auto-Training aktiviert' : 'Auto-Training deaktiviert');
                loadAutoTrainingStatus();

            } catch (error) {
                showToast('Fehler beim Andern des Auto-Training Status', 'error');
                console.error(error);
            }
        }

        // Update Auto-Training Config
        async function updateAutoTrainingConfig() {
            const interval = document.getElementById('auto-interval').value;
            const scheduled_hour = parseInt(document.getElementById('auto-scheduled-hour').value) || 2;
            const scheduled_minute = parseInt(document.getElementById('auto-scheduled-minute').value) || 0;
            const timeframes = [];
            if (document.getElementById('auto-tf-1h').checked) timeframes.push('1h');
            if (document.getElementById('auto-tf-4h').checked) timeframes.push('4h');
            if (document.getElementById('auto-tf-1d').checked) timeframes.push('1d');

            try {
                const response = await fetch(`${TRAIN_API_BASE}/auto-training/config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ interval, timeframes, scheduled_hour, scheduled_minute })
                });

                if (!response.ok) throw new Error('Failed to update config');

                showToast('Auto-Training Konfiguration aktualisiert');
                loadAutoTrainingStatus();

            } catch (error) {
                showToast('Fehler beim Speichern der Konfiguration', 'error');
                console.error(error);
            }
        }

        // Run Auto-Training Now
        async function runAutoTrainingNow() {
            const btn = document.getElementById('btn-run-now');
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner" style="width: 14px; height: 14px; border-width: 2px;"></span> Startet...';

            try {
                // Get selected timeframes
                const timeframes = [];
                if (document.getElementById('auto-tf-1h').checked) timeframes.push('1h');
                if (document.getElementById('auto-tf-4h').checked) timeframes.push('4h');
                if (document.getElementById('auto-tf-1d').checked) timeframes.push('1d');

                const response = await fetch(`${TRAIN_API_BASE}/auto-training/run`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ timeframes })
                });

                if (!response.ok) {
                    const errData = await response.json();
                    throw new Error(errData.detail || 'Failed to start auto-training');
                }

                showToast('Auto-Training fur alle Symbole gestartet');
                loadAutoTrainingStatus();
                loadTrainingStatus();

            } catch (error) {
                showToast('Fehler beim Starten des Auto-Trainings', 'error');
                console.error(error);
            } finally {
                btn.disabled = false;
                btn.innerHTML = '&#9889; Jetzt starten';
            }
        }

        // Add event listeners for config changes
        document.getElementById('auto-interval')?.addEventListener('change', updateAutoTrainingConfig);
        document.getElementById('auto-scheduled-hour')?.addEventListener('change', updateAutoTrainingConfig);
        document.getElementById('auto-scheduled-minute')?.addEventListener('change', updateAutoTrainingConfig);
        document.getElementById('auto-tf-1h')?.addEventListener('change', updateAutoTrainingConfig);
        document.getElementById('auto-tf-4h')?.addEventListener('change', updateAutoTrainingConfig);
        document.getElementById('auto-tf-1d')?.addEventListener('change', updateAutoTrainingConfig);

        // Add event listeners for pattern history filters (apply on change)
        document.getElementById('history-symbol-filter')?.addEventListener('change', loadPatternHistory);
        document.getElementById('history-pattern-filter')?.addEventListener('change', loadPatternHistory);
        document.getElementById('history-timeframe-filter')?.addEventListener('change', loadPatternHistory);
        document.getElementById('history-category-filter')?.addEventListener('change', loadPatternHistory);
        document.getElementById('history-direction-filter')?.addEventListener('change', loadPatternHistory);
        document.getElementById('history-confidence-filter')?.addEventListener('change', loadPatternHistory);

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Load saved pattern filters before loading history
            loadPatternFilters();

            loadInfo();
            loadAvailableSymbols();
            loadDetectionSymbols();
            loadAutoScanStatus();
            loadTrainingStatus();
            loadTrainingHistory();
            loadModels();
            loadAutoTrainingStatus();
            loadHistoryStats();
            loadPatternHistory();

            // Auto-refresh every 30 seconds
            setInterval(loadInfo, 30000);

            // Auto-refresh training status every 3 seconds
            setInterval(loadTrainingStatus, 3000);

            // Auto-refresh auto-training status every 10 seconds
            setInterval(loadAutoTrainingStatus, 10000);

            // Auto-refresh auto-scan status every 15 seconds
            setInterval(loadAutoScanStatus, 15000);

            // Auto-refresh pattern history every 60 seconds
            setInterval(() => {
                loadHistoryStats();
                loadPatternHistory();
            }, 60000);

            // Setup chart modal
            setupChartModal();
        });

        // =============================================================================
        // Pattern Modal Functions
        // =============================================================================

        // TCN Pattern SVG visualizations
        const tcnPatternSvgs = {
            'head_and_shoulders': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 70 L40 50 L55 70 L80 20 L105 70 L120 50 L150 70" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="10" y1="70" x2="150" y2="70" stroke="#ffc107" stroke-width="1" stroke-dasharray="4"/>
                <path d="M150 70 L180 85 L210 90" stroke="#ef5350" stroke-width="2" fill="none"/>
                <text x="80" y="15" fill="#64c8ff" font-size="8">Kopf</text>
                <text x="40" y="45" fill="#81c784" font-size="7">L.Schulter</text>
                <text x="105" y="45" fill="#81c784" font-size="7">R.Schulter</text>
                <text x="155" y="65" fill="#ffc107" font-size="7">Neckline</text>
            </svg>`,
            'inverse_head_and_shoulders': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 30 L40 50 L55 30 L80 80 L105 30 L120 50 L150 30" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="10" y1="30" x2="150" y2="30" stroke="#ffc107" stroke-width="1" stroke-dasharray="4"/>
                <path d="M150 30 L180 15 L210 10" stroke="#81c784" stroke-width="2" fill="none"/>
                <text x="80" y="90" fill="#64c8ff" font-size="8">Kopf</text>
                <text x="40" y="58" fill="#81c784" font-size="7">L.Schulter</text>
                <text x="105" y="58" fill="#81c784" font-size="7">R.Schulter</text>
            </svg>`,
            'double_top': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 70 L50 20 L90 55 L130 20 L170 55" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="50" y1="20" x2="130" y2="20" stroke="#ef5350" stroke-width="1" stroke-dasharray="3"/>
                <line x1="10" y1="55" x2="170" y2="55" stroke="#ffc107" stroke-width="1" stroke-dasharray="4"/>
                <path d="M170 55 L200 75 L230 85" stroke="#ef5350" stroke-width="2" fill="none"/>
                <text x="50" y="15" fill="#ef5350" font-size="8">Top 1</text>
                <text x="130" y="15" fill="#ef5350" font-size="8">Top 2</text>
                <text x="175" y="50" fill="#ffc107" font-size="7">Support</text>
            </svg>`,
            'double_bottom': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 30 L50 80 L90 45 L130 80 L170 45" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="50" y1="80" x2="130" y2="80" stroke="#81c784" stroke-width="1" stroke-dasharray="3"/>
                <line x1="10" y1="45" x2="170" y2="45" stroke="#ffc107" stroke-width="1" stroke-dasharray="4"/>
                <path d="M170 45 L200 25 L230 15" stroke="#81c784" stroke-width="2" fill="none"/>
                <text x="50" y="90" fill="#81c784" font-size="8">Bot 1</text>
                <text x="130" y="90" fill="#81c784" font-size="8">Bot 2</text>
                <text x="175" y="50" fill="#ffc107" font-size="7">Resistance</text>
            </svg>`,
            'triple_top': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 70 L35 20 L60 55 L90 20 L120 55 L150 20 L180 55" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="35" y1="20" x2="150" y2="20" stroke="#ef5350" stroke-width="1" stroke-dasharray="3"/>
                <line x1="10" y1="55" x2="180" y2="55" stroke="#ffc107" stroke-width="1" stroke-dasharray="4"/>
                <path d="M180 55 L210 75 L240 85" stroke="#ef5350" stroke-width="2" fill="none"/>
                <text x="90" y="15" fill="#ef5350" font-size="8">3x Widerstand</text>
            </svg>`,
            'triple_bottom': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 30 L35 80 L60 45 L90 80 L120 45 L150 80 L180 45" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="35" y1="80" x2="150" y2="80" stroke="#81c784" stroke-width="1" stroke-dasharray="3"/>
                <line x1="10" y1="45" x2="180" y2="45" stroke="#ffc107" stroke-width="1" stroke-dasharray="4"/>
                <path d="M180 45 L210 25 L240 15" stroke="#81c784" stroke-width="2" fill="none"/>
                <text x="90" y="92" fill="#81c784" font-size="8">3x Support</text>
            </svg>`,
            'ascending_triangle': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 80 L40 30 L60 70 L90 30 L110 60 L140 30 L160 50" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="40" y1="30" x2="160" y2="30" stroke="#ffc107" stroke-width="1.5"/>
                <line x1="10" y1="80" x2="160" y2="50" stroke="#81c784" stroke-width="1.5"/>
                <path d="M160 30 L190 15 L220 10" stroke="#81c784" stroke-width="2" fill="none"/>
                <text x="165" y="27" fill="#ffc107" font-size="7">Flat Resistance</text>
                <text x="85" y="75" fill="#81c784" font-size="7">Rising Support</text>
            </svg>`,
            'descending_triangle': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 20 L40 70 L60 30 L90 70 L110 40 L140 70 L160 50" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="40" y1="70" x2="160" y2="70" stroke="#ffc107" stroke-width="1.5"/>
                <line x1="10" y1="20" x2="160" y2="50" stroke="#ef5350" stroke-width="1.5"/>
                <path d="M160 70 L190 85 L220 90" stroke="#ef5350" stroke-width="2" fill="none"/>
                <text x="165" y="73" fill="#ffc107" font-size="7">Flat Support</text>
                <text x="85" y="25" fill="#ef5350" font-size="7">Falling Resistance</text>
            </svg>`,
            'symmetrical_triangle': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 50 L30 20 L50 70 L80 30 L100 60 L130 40 L150 55" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="30" y1="20" x2="150" y2="47" stroke="#a78bfa" stroke-width="1.5"/>
                <line x1="50" y1="70" x2="150" y2="53" stroke="#a78bfa" stroke-width="1.5"/>
                <path d="M150 47 L180 25 L210 15" stroke="#81c784" stroke-width="2" stroke-dasharray="4" fill="none"/>
                <path d="M150 53 L180 75 L210 85" stroke="#ef5350" stroke-width="2" stroke-dasharray="4" fill="none"/>
                <text x="155" y="20" fill="#81c784" font-size="7">Bullish?</text>
                <text x="155" y="88" fill="#ef5350" font-size="7">Bearish?</text>
            </svg>`,
            'rising_wedge': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 85 L40 60 L55 75 L90 40 L105 55 L140 25 L155 40" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="10" y1="85" x2="155" y2="40" stroke="#81c784" stroke-width="1.5"/>
                <line x1="40" y1="60" x2="155" y2="25" stroke="#ef5350" stroke-width="1.5"/>
                <path d="M155 40 L185 60 L215 75" stroke="#ef5350" stroke-width="2" fill="none"/>
                <text x="80" y="18" fill="#ef5350" font-size="8">Konvergierend</text>
            </svg>`,
            'falling_wedge': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 15 L40 40 L55 25 L90 60 L105 45 L140 75 L155 60" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="10" y1="15" x2="155" y2="60" stroke="#ef5350" stroke-width="1.5"/>
                <line x1="40" y1="40" x2="155" y2="75" stroke="#81c784" stroke-width="1.5"/>
                <path d="M155 60 L185 40 L215 25" stroke="#81c784" stroke-width="2" fill="none"/>
                <text x="80" y="88" fill="#81c784" font-size="8">Konvergierend</text>
            </svg>`,
            'bull_flag': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 90 L50 30" stroke="#81c784" stroke-width="3" fill="none"/>
                <path d="M50 30 L70 40 L85 35 L100 45 L115 40 L130 50" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="50" y1="30" x2="130" y2="50" stroke="#ffc107" stroke-width="1" stroke-dasharray="3"/>
                <line x1="70" y1="40" x2="130" y2="55" stroke="#ffc107" stroke-width="1" stroke-dasharray="3"/>
                <path d="M130 45 L170 15 L200 5" stroke="#81c784" stroke-width="2" fill="none"/>
                <text x="15" y="60" fill="#81c784" font-size="8">Flagpole</text>
                <text x="85" y="60" fill="#ffc107" font-size="7">Flag</text>
            </svg>`,
            'bear_flag': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 10 L50 70" stroke="#ef5350" stroke-width="3" fill="none"/>
                <path d="M50 70 L70 60 L85 65 L100 55 L115 60 L130 50" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="50" y1="70" x2="130" y2="50" stroke="#ffc107" stroke-width="1" stroke-dasharray="3"/>
                <line x1="70" y1="60" x2="130" y2="45" stroke="#ffc107" stroke-width="1" stroke-dasharray="3"/>
                <path d="M130 55 L170 85 L200 95" stroke="#ef5350" stroke-width="2" fill="none"/>
                <text x="15" y="40" fill="#ef5350" font-size="8">Flagpole</text>
                <text x="85" y="42" fill="#ffc107" font-size="7">Flag</text>
            </svg>`,
            'cup_and_handle': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 25 Q 20 25, 30 35 Q 60 85, 100 85 Q 140 85, 160 35 Q 170 25, 180 25" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <path d="M180 25 L190 35 L200 30 L210 38 L220 32" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="10" y1="25" x2="220" y2="25" stroke="#ffc107" stroke-width="1" stroke-dasharray="4"/>
                <path d="M220 28 L250 10" stroke="#81c784" stroke-width="2" fill="none"/>
                <text x="85" y="75" fill="#64c8ff" font-size="8">Cup</text>
                <text x="195" y="45" fill="#64c8ff" font-size="7">Handle</text>
            </svg>`,
            'channel_up': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 80 L40 60 L70 75 L100 55 L130 70 L160 50 L190 65 L220 45" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="10" y1="80" x2="220" y2="45" stroke="#81c784" stroke-width="1.5"/>
                <line x1="40" y1="55" x2="220" y2="25" stroke="#81c784" stroke-width="1.5"/>
                <path d="M220 45 L250 30" stroke="#81c784" stroke-width="2" fill="none"/>
                <text x="120" y="20" fill="#81c784" font-size="8">Aufwärtskanal</text>
            </svg>`,
            'channel_down': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 20 L40 40 L70 25 L100 45 L130 30 L160 50 L190 35 L220 55" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="10" y1="20" x2="220" y2="55" stroke="#ef5350" stroke-width="1.5"/>
                <line x1="40" y1="45" x2="220" y2="75" stroke="#ef5350" stroke-width="1.5"/>
                <path d="M220 55 L250 70" stroke="#ef5350" stroke-width="2" fill="none"/>
                <text x="120" y="85" fill="#ef5350" font-size="8">Abwärtskanal</text>
            </svg>`
        };

        // Get SVG for pattern type with fallback
        function getPatternSvg(patternType) {
            return tcnPatternSvgs[patternType] || `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <text x="140" y="50" fill="#888" font-size="10" text-anchor="middle">Pattern: ${patternType.replace(/_/g, ' ')}</text>
                <text x="140" y="65" fill="#666" font-size="8" text-anchor="middle">Keine Visualisierung verfügbar</text>
            </svg>`;
        }

        // TCN Pattern descriptions
        const tcnPatternDescriptions = {
            'head_and_shoulders': {
                name: 'Head and Shoulders',
                description: 'Drei Gipfel, wobei der mittlere (Kopf) höher ist als die beiden äusseren (Schultern). Signalisiert das Ende eines Aufwärtstrends.',
                implication: 'Starkes bärisches Umkehrsignal. Preisziel entspricht der Distanz vom Kopf zur Nackenlinie.'
            },
            'inverse_head_and_shoulders': {
                name: 'Inverse Head and Shoulders',
                description: 'Drei Tiefpunkte, wobei der mittlere tiefer ist als die beiden äusseren. Signalisiert das Ende eines Abwärtstrends.',
                implication: 'Starkes bullisches Umkehrsignal. Preisziel entspricht der Distanz vom Kopf zur Nackenlinie.'
            },
            'double_top': {
                name: 'Double Top',
                description: 'Zwei aufeinanderfolgende Hochs auf ähnlichem Preisniveau, getrennt durch ein Tal.',
                implication: 'Bärisches Umkehrsignal. Break unter die Unterstützung bestätigt das Muster.'
            },
            'double_bottom': {
                name: 'Double Bottom',
                description: 'Zwei aufeinanderfolgende Tiefs auf ähnlichem Preisniveau, getrennt durch einen Gipfel.',
                implication: 'Bullisches Umkehrsignal. Break über den Widerstand bestätigt das Muster.'
            },
            'triple_top': {
                name: 'Triple Top',
                description: 'Drei aufeinanderfolgende Hochs auf ähnlichem Preisniveau.',
                implication: 'Starkes bärisches Umkehrsignal, stärker als Double Top.'
            },
            'triple_bottom': {
                name: 'Triple Bottom',
                description: 'Drei aufeinanderfolgende Tiefs auf ähnlichem Preisniveau.',
                implication: 'Starkes bullisches Umkehrsignal, stärker als Double Bottom.'
            },
            'ascending_triangle': {
                name: 'Ascending Triangle',
                description: 'Horizontale Widerstandslinie mit aufsteigender Unterstützungslinie. Höhere Tiefs zeigen zunehmenden Kaufdruck.',
                implication: 'Bullisches Fortsetzungsmuster. Ausbruch nach oben wahrscheinlich.'
            },
            'descending_triangle': {
                name: 'Descending Triangle',
                description: 'Horizontale Unterstützungslinie mit absteigender Widerstandslinie. Tiefere Hochs zeigen zunehmenden Verkaufsdruck.',
                implication: 'Bärisches Fortsetzungsmuster. Ausbruch nach unten wahrscheinlich.'
            },
            'symmetrical_triangle': {
                name: 'Symmetrical Triangle',
                description: 'Konvergierende Trend-Linien mit tieferen Hochs und höheren Tiefs. Zeigt Konsolidierung.',
                implication: 'Neutrales Muster. Ausbruchsrichtung bestimmt den Trend.'
            },
            'bull_flag': {
                name: 'Bull Flag',
                description: 'Starke Aufwärtsbewegung gefolgt von paralleler Konsolidierung nach unten.',
                implication: 'Bullisches Fortsetzungsmuster. Erwarteter Ausbruch nach oben.'
            },
            'bear_flag': {
                name: 'Bear Flag',
                description: 'Starke Abwärtsbewegung gefolgt von paralleler Konsolidierung nach oben.',
                implication: 'Bärisches Fortsetzungsmuster. Erwarteter Ausbruch nach unten.'
            },
            'cup_and_handle': {
                name: 'Cup and Handle',
                description: 'U-förmige Rundung (Tasse) gefolgt von kleiner Abwärtskonsolidierung (Henkel).',
                implication: 'Bullisches Fortsetzungsmuster. Ausbruch über den Henkel-Widerstand erwartet.'
            },
            'falling_wedge': {
                name: 'Falling Wedge',
                description: 'Konvergierende Trendlinien, beide nach unten gerichtet. Preis macht tiefere Hochs und tiefere Tiefs.',
                implication: 'Bullisches Umkehrmuster (im Abwärtstrend) oder Fortsetzung (im Aufwärtstrend).'
            },
            'rising_wedge': {
                name: 'Rising Wedge',
                description: 'Konvergierende Trendlinien, beide nach oben gerichtet. Preis macht höhere Hochs und höhere Tiefs.',
                implication: 'Bärisches Umkehrmuster (im Aufwärtstrend) oder Fortsetzung (im Abwärtstrend).'
            },
            'channel_up': {
                name: 'Channel Up',
                description: 'Parallele aufsteigende Trendlinien. Preis bewegt sich zwischen Unterstützung und Widerstand.',
                implication: 'Bullischer Trend. Long bei Unterstützung, Vorsicht bei Widerstand.'
            },
            'channel_down': {
                name: 'Channel Down',
                description: 'Parallele absteigende Trendlinien. Preis bewegt sich zwischen Unterstützung und Widerstand.',
                implication: 'Bärischer Trend. Short bei Widerstand, Vorsicht bei Unterstützung.'
            }
        };

        // Get pattern info with fallback
        function getTcnPatternInfo(patternType) {
            return tcnPatternDescriptions[patternType] || {
                name: patternType.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' '),
                description: 'TCN-erkanntes Chart-Muster.',
                implication: 'Richtung und Stärke beachten für Trading-Entscheidung.'
            };
        }

        // Format price for display
        function formatPrice(price) {
            if (price >= 1000) return price.toFixed(0);
            if (price >= 1) return price.toFixed(2);
            return price.toFixed(5);
        }

        // Draw candlestick chart using Canvas
        function drawCandlestickChart(canvasId, candles, patternIndex) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const container = canvas.parentElement;

            // Set canvas size
            canvas.width = container.clientWidth - 20;
            canvas.height = container.clientHeight - 20;

            const width = canvas.width;
            const height = canvas.height;
            const padding = { top: 20, right: 60, bottom: 30, left: 10 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            if (!candles || candles.length === 0) {
                ctx.fillStyle = '#888';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Keine Daten verfügbar', width / 2, height / 2);
                return;
            }

            // Calculate price range
            const prices = candles.flatMap(c => [c.high, c.low]);
            const minPrice = Math.min(...prices);
            const maxPrice = Math.max(...prices);
            const priceRange = maxPrice - minPrice || 1;
            const pricePadding = priceRange * 0.1;

            const scaledMinPrice = minPrice - pricePadding;
            const scaledMaxPrice = maxPrice + pricePadding;
            const scaledRange = scaledMaxPrice - scaledMinPrice;

            // Calculate candle dimensions
            const candleWidth = Math.max(4, Math.min(20, (chartWidth / candles.length) * 0.7));
            const candleSpacing = chartWidth / candles.length;

            // Helper to convert price to Y coordinate
            const priceToY = (price) => {
                return padding.top + chartHeight - ((price - scaledMinPrice) / scaledRange * chartHeight);
            };

            // Draw grid lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            const gridLines = 5;
            for (let i = 0; i <= gridLines; i++) {
                const y = padding.top + (chartHeight / gridLines) * i;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(width - padding.right, y);
                ctx.stroke();

                // Price labels
                const price = scaledMaxPrice - (scaledRange / gridLines) * i;
                ctx.fillStyle = '#888';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(formatPrice(price), width - padding.right + 5, y + 3);
            }

            // Draw candles
            candles.forEach((candle, i) => {
                const x = padding.left + (i + 0.5) * candleSpacing;
                const isPattern = i === patternIndex;

                const openY = priceToY(candle.open);
                const closeY = priceToY(candle.close);
                const highY = priceToY(candle.high);
                const lowY = priceToY(candle.low);

                const isBullish = candle.close >= candle.open;
                const bodyTop = Math.min(openY, closeY);
                const bodyHeight = Math.max(1, Math.abs(closeY - openY));

                // Highlight pattern candle background
                if (isPattern) {
                    ctx.fillStyle = 'rgba(255, 193, 7, 0.15)';
                    ctx.fillRect(x - candleSpacing / 2, padding.top, candleSpacing, chartHeight);
                }

                // Draw wick
                ctx.strokeStyle = isBullish ? '#81c784' : '#e57373';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, highY);
                ctx.lineTo(x, lowY);
                ctx.stroke();

                // Draw body
                ctx.fillStyle = isBullish ? '#81c784' : '#e57373';
                ctx.fillRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);

                // Draw body outline
                ctx.strokeStyle = isBullish ? '#4caf50' : '#f44336';
                ctx.lineWidth = 1;
                ctx.strokeRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);

                // Pattern marker
                if (isPattern) {
                    ctx.strokeStyle = '#ffc107';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 2]);
                    ctx.strokeRect(x - candleWidth / 2 - 3, highY - 5, candleWidth + 6, lowY - highY + 10);
                    ctx.setLineDash([]);

                    // Arrow pointing to pattern
                    ctx.fillStyle = '#ffc107';
                    ctx.font = 'bold 12px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('▼', x, padding.top - 5);
                }

                // Time labels (show every few candles)
                if (i === 0 || i === candles.length - 1 || i === patternIndex) {
                    const time = new Date(candle.timestamp);
                    const timeStr = time.toLocaleTimeString('de-CH', { hour: '2-digit', minute: '2-digit' });
                    ctx.fillStyle = i === patternIndex ? '#ffc107' : '#666';
                    ctx.font = '9px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(timeStr, x, height - 5);
                }
            });

            // Draw legend
            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Pattern-Kerze markiert (gelb)', padding.left, height - 5);
        }

        // Show pattern modal with real chart and pattern overlay
        async function showPatternChart(symbol, timeframe, timestamp, patternType, direction, patternPoints) {
            const modal = document.getElementById('chartModal');
            const chartContainer = document.getElementById('patternChartContainer');
            const svgContainer = document.getElementById('patternSvgContainer');
            const chartInfo = document.getElementById('chartInfo');
            const loadingEl = document.getElementById('chartLoading');

            // Get pattern info
            const info = getTcnPatternInfo(patternType);

            // Set title and badges
            document.getElementById('chartModalTitle').textContent = `${symbol} - ${info.name}`;
            document.getElementById('chartModalBadges').innerHTML = `
                <span class="pattern-badge ${direction}">${direction}</span>
                <span class="pattern-badge">${timeframe}</span>
            `;

            // Set description
            document.getElementById('chartPatternDescription').textContent = info.description;
            const implEl = document.getElementById('chartPatternImplication');
            implEl.textContent = info.implication;
            implEl.className = 'modal-implication ' + (direction === 'bullish' ? 'bullish' : direction === 'bearish' ? 'bearish' : 'neutral');

            // Update chart info
            document.getElementById('chartSymbol').textContent = symbol;
            document.getElementById('chartTimeframe').textContent = timeframe;
            document.getElementById('chartPatternTime').textContent = formatLocalDateTime(timestamp, { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' });
            document.getElementById('chartPatternType').textContent = info.name;

            // Show loading state
            if (loadingEl) loadingEl.style.display = 'flex';
            chartContainer.style.display = 'none';
            svgContainer.style.display = 'none';
            chartInfo.style.display = 'flex';

            // Show modal
            modal.classList.add('show');

            try {
                // Fetch OHLC data from Data Service using the patterns/chart endpoint
                // Use the pattern detection timestamp to get historical data at that point in time
                const candlesBack = 50; // Show 50 candles of context
                const patternTimestamp = encodeURIComponent(timestamp);

                let ohlcResponse = await fetch(`/data/api/v1/patterns/chart/${symbol}?candles_before=${candlesBack}&candles_after=5&timeframe=${timeframe}&timestamp=${patternTimestamp}`);

                // If historical data not available (e.g., weekend/holiday), try without timestamp for current data
                if (!ohlcResponse.ok || ohlcResponse.status === 404) {
                    console.warn(`Historische Daten für ${timestamp} nicht verfügbar, lade aktuelle Daten...`);
                    ohlcResponse = await fetch(`/data/api/v1/patterns/chart/${symbol}?candles_before=${candlesBack}&candles_after=5&timeframe=${timeframe}`);
                }

                if (!ohlcResponse.ok) {
                    throw new Error(`OHLC-Daten konnten nicht geladen werden: ${ohlcResponse.status}`);
                }

                const ohlcData = await ohlcResponse.json();
                const candles = ohlcData.candles || ohlcData.data || ohlcData;

                // Check for error in response (e.g., market closed)
                if (ohlcData.error || ohlcData.detail) {
                    throw new Error(ohlcData.error || ohlcData.detail || 'Keine Daten verfügbar');
                }

                if (!candles || candles.length === 0) {
                    throw new Error('Keine Candlestick-Daten verfügbar (Markt geschlossen?)');
                }

                // Hide loading, show chart
                if (loadingEl) loadingEl.style.display = 'none';
                chartContainer.style.display = 'block';

                // Draw the chart with pattern overlay
                drawCandlestickChartWithPattern('patternCanvas', candles, patternType, patternPoints, timestamp);

            } catch (error) {
                console.error('Fehler beim Laden des Charts:', error);
                // Fall back to SVG visualization with error message
                if (loadingEl) loadingEl.style.display = 'none';
                chartContainer.style.display = 'none';
                svgContainer.style.display = 'flex';
                svgContainer.innerHTML = `
                    <div style="text-align: center; width: 100%;">
                        ${getPatternSvg(patternType)}
                        <p style="color: #888; font-size: 11px; margin-top: 10px;">
                            Historische Chart-Daten nicht verfügbar<br>
                            <span style="color: #666;">(${error.message})</span>
                        </p>
                    </div>
                `;
            }
        }

        // Get interval in minutes
        function getIntervalMinutes(timeframe) {
            const mapping = {
                'M1': 1, 'M5': 5, 'M15': 15, 'M30': 30,
                'H1': 60, 'H4': 240, 'D1': 1440, 'W1': 10080
            };
            return mapping[timeframe] || 60;
        }

        // Draw candlestick chart with pattern overlay
        function drawCandlestickChartWithPattern(canvasId, candles, patternType, patternPoints, patternTimestamp) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const container = canvas.parentElement;

            // Set canvas size
            canvas.width = container.clientWidth - 20;
            canvas.height = 320;

            const width = canvas.width;
            const height = canvas.height;
            const padding = { top: 30, right: 70, bottom: 45, left: 20 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            if (!candles || candles.length === 0) {
                ctx.fillStyle = '#888';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Keine Daten verfügbar', width / 2, height / 2);
                return;
            }

            // Calculate price range - include pattern points in the range for proper scaling
            const candlePrices = candles.flatMap(c => [c.high, c.low]);
            const patternPrices = (patternPoints && patternPoints.length > 0)
                ? patternPoints.map(p => p.price)
                : [];
            const allPrices = [...candlePrices, ...patternPrices];

            const minPrice = Math.min(...allPrices);
            const maxPrice = Math.max(...allPrices);
            const priceRange = maxPrice - minPrice || 1;
            const pricePadding = priceRange * 0.1;

            const scaledMinPrice = minPrice - pricePadding;
            const scaledMaxPrice = maxPrice + pricePadding;
            const scaledRange = scaledMaxPrice - scaledMinPrice;

            // Calculate candle dimensions
            const candleWidth = Math.max(3, Math.min(15, (chartWidth / candles.length) * 0.65));
            const candleSpacing = chartWidth / candles.length;

            // Helper to convert price to Y coordinate
            const priceToY = (price) => {
                return padding.top + chartHeight - ((price - scaledMinPrice) / scaledRange * chartHeight);
            };

            // Helper to convert index to X coordinate
            const indexToX = (idx) => {
                return padding.left + (idx + 0.5) * candleSpacing;
            };

            // Determine pattern range from pattern_points using actual price-based mapping
            let patternStartIdx = candles.length - 1;
            let patternEndIdx = candles.length - 1;

            if (patternPoints && patternPoints.length > 0) {
                // Use the same mapping logic as drawPatternOverlay to find actual candle positions
                const highPointTypes = ['left_shoulder', 'head', 'right_shoulder', 'first_peak', 'second_peak',
                    'peak', 'peak1', 'peak2', 'peak3', 'top_1', 'top_2', 'pivot_high',
                    'resistance_start', 'resistance_end', 'upper_start', 'upper_end',
                    'pole_start', 'pole_end', 'flag_start', 'flag_end', 'left_rim', 'right_rim', 'handle_start', 'handle_end'];
                const lowPointTypes = ['first_trough', 'second_trough', 'valley', 'trough1', 'trough2', 'trough3',
                    'bottom_1', 'bottom_2', 'pivot_low', 'support_start', 'support_end',
                    'lower_start', 'lower_end', 'cup_bottom', 'neckline_left', 'neckline_right'];

                const isHighPoint = (pointType) => highPointTypes.includes(pointType || '');
                const isLowPoint = (pointType) => lowPointTypes.includes(pointType || '');

                // Find the best matching candle for a pattern point based on price proximity
                const findBestCandleForZone = (point) => {
                    const targetPrice = point.price;
                    const pointType = point.point_type || '';
                    const isHigh = isHighPoint(pointType);
                    const isLow = isLowPoint(pointType);

                    const searchStart = Math.max(0, candles.length - 100);
                    let bestIdx = candles.length - 1;
                    let bestScore = Infinity;

                    for (let i = searchStart; i < candles.length; i++) {
                        const candle = candles[i];
                        let priceDiff;

                        if (isHigh) {
                            priceDiff = Math.abs(candle.high - targetPrice);
                        } else if (isLow) {
                            priceDiff = Math.abs(candle.low - targetPrice);
                        } else {
                            priceDiff = Math.min(
                                Math.abs(candle.high - targetPrice),
                                Math.abs(candle.low - targetPrice)
                            );
                        }

                        if (priceDiff < bestScore) {
                            bestScore = priceDiff;
                            bestIdx = i;
                        }
                    }
                    return bestIdx;
                };

                // Map all pattern points to their actual candle positions
                const mappedIndices = patternPoints.map(p => findBestCandleForZone(p));
                patternStartIdx = Math.max(0, Math.min(...mappedIndices) - 2);  // Small buffer before first point
                patternEndIdx = Math.min(candles.length - 1, Math.max(...mappedIndices) + 2);  // Small buffer after last point
            }

            // Draw pattern zone background (highlighting pattern formation period)
            if (patternPoints && patternPoints.length > 0) {
                const startX = indexToX(patternStartIdx) - candleSpacing / 2;
                const endX = indexToX(patternEndIdx) + candleSpacing / 2;

                // Pattern zone fill - more visible
                ctx.fillStyle = 'rgba(255, 193, 7, 0.15)';
                ctx.fillRect(startX, padding.top, endX - startX, chartHeight);

                // Pattern zone border - solid lines
                ctx.strokeStyle = '#ffc107';
                ctx.lineWidth = 2;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(startX, padding.top);
                ctx.lineTo(startX, padding.top + chartHeight);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(endX, padding.top);
                ctx.lineTo(endX, padding.top + chartHeight);
                ctx.stroke();

                // Pattern zone label at top with background
                const labelText = 'Pattern-Formation';
                ctx.font = 'bold 10px sans-serif';
                const labelX = (startX + endX) / 2;
                const labelWidth = ctx.measureText(labelText).width + 10;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(labelX - labelWidth / 2, padding.top + 3, labelWidth, 16);
                ctx.fillStyle = '#ffc107';
                ctx.textAlign = 'center';
                ctx.fillText(labelText, labelX, padding.top + 15);

                // Start/End markers with arrows
                ctx.font = 'bold 9px sans-serif';
                ctx.fillStyle = '#ffc107';
                ctx.textAlign = 'center';
                // Start arrow and label
                ctx.fillText('▼', startX, padding.top + 32);
                ctx.fillText('Start', startX, padding.top + 44);
                // End arrow and label
                ctx.fillText('▼', endX, padding.top + 32);
                ctx.fillText('Ende', endX, padding.top + 44);
            }

            // Draw grid lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
            ctx.lineWidth = 1;
            const gridLines = 5;
            for (let i = 0; i <= gridLines; i++) {
                const y = padding.top + (chartHeight / gridLines) * i;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(width - padding.right, y);
                ctx.stroke();

                // Price labels on Y-axis
                const price = scaledMaxPrice - (scaledRange / gridLines) * i;
                ctx.fillStyle = '#aaa';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(formatPrice(price), width - padding.right + 5, y + 3);
            }

            // Y-axis label (Preis)
            ctx.save();
            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.translate(width - 8, padding.top + chartHeight / 2);
            ctx.rotate(Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText('Preis', 0, 0);
            ctx.restore();

            // Draw candles
            candles.forEach((candle, i) => {
                const x = indexToX(i);
                const openY = priceToY(candle.open);
                const closeY = priceToY(candle.close);
                const highY = priceToY(candle.high);
                const lowY = priceToY(candle.low);

                const isBullish = candle.close >= candle.open;
                const bodyTop = Math.min(openY, closeY);
                const bodyHeight = Math.max(1, Math.abs(closeY - openY));

                // Draw wick
                ctx.strokeStyle = isBullish ? '#4caf50' : '#f44336';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, highY);
                ctx.lineTo(x, lowY);
                ctx.stroke();

                // Draw body
                ctx.fillStyle = isBullish ? '#81c784' : '#e57373';
                ctx.fillRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);

                // Draw body outline
                ctx.strokeStyle = isBullish ? '#4caf50' : '#f44336';
                ctx.lineWidth = 1;
                ctx.strokeRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
            });

            // Draw pattern overlay lines based on pattern_points
            if (patternPoints && patternPoints.length > 0) {
                drawPatternOverlay(ctx, candles, patternPoints, patternType, indexToX, priceToY, padding, chartHeight);
            }

            // X-axis with time labels
            const numTimeLabels = Math.min(6, candles.length);
            const labelStep = Math.floor(candles.length / (numTimeLabels - 1));

            for (let i = 0; i < candles.length; i += labelStep) {
                if (i >= candles.length) break;
                const candle = candles[i];
                const x = indexToX(i);
                const time = new Date(candle.timestamp);

                // Tick mark
                ctx.strokeStyle = '#555';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, padding.top + chartHeight);
                ctx.lineTo(x, padding.top + chartHeight + 4);
                ctx.stroke();

                // Date and time
                const dateStr = time.toLocaleDateString('de-CH', { day: '2-digit', month: '2-digit' });
                const timeStr = time.toLocaleTimeString('de-CH', { hour: '2-digit', minute: '2-digit' });
                ctx.fillStyle = '#888';
                ctx.font = '9px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(dateStr, x, height - 22);
                ctx.fillText(timeStr, x, height - 11);
            }

            // Also show last candle time if not already shown
            const lastIdx = candles.length - 1;
            if (lastIdx % labelStep !== 0) {
                const candle = candles[lastIdx];
                const x = indexToX(lastIdx);
                const time = new Date(candle.timestamp);
                const dateStr = time.toLocaleDateString('de-CH', { day: '2-digit', month: '2-digit' });
                const timeStr = time.toLocaleTimeString('de-CH', { hour: '2-digit', minute: '2-digit' });
                ctx.fillStyle = '#ffc107';
                ctx.font = '9px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(dateStr, x, height - 22);
                ctx.fillText(timeStr, x, height - 11);
            }

            // X-axis label (Zeit)
            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Zeit', padding.left + chartWidth / 2, height - 1);

            // Draw pattern title and info
            const info = getTcnPatternInfo(patternType);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(info.name, padding.left + 5, padding.top - 12);

            // Pattern duration info
            if (patternPoints && patternPoints.length > 0 && patternStartIdx < patternEndIdx) {
                const startCandle = candles[patternStartIdx];
                const endCandle = candles[patternEndIdx];
                if (startCandle && endCandle) {
                    const startTime = new Date(startCandle.timestamp);
                    const endTime = new Date(endCandle.timestamp);
                    const durationMs = endTime - startTime;
                    const durationHours = Math.round(durationMs / (1000 * 60 * 60));
                    const durationText = durationHours >= 24
                        ? `${Math.round(durationHours / 24)}d`
                        : `${durationHours}h`;

                    ctx.fillStyle = '#888';
                    ctx.font = '9px sans-serif';
                    ctx.textAlign = 'right';
                    ctx.fillText(`Dauer: ~${durationText} (${patternEndIdx - patternStartIdx + 1} Kerzen)`, width - padding.right, padding.top - 12);
                }
            }
        }

        // Draw pattern overlay based on pattern points
        function drawPatternOverlay(ctx, candles, patternPoints, patternType, indexToX, priceToY, padding, chartHeight) {
            if (!patternPoints || patternPoints.length === 0) return;

            // Determine if point is a high point (peaks/shoulders) or low point (troughs/valleys)
            const highPointTypes = ['left_shoulder', 'head', 'right_shoulder', 'first_peak', 'second_peak',
                'peak', 'peak1', 'peak2', 'peak3', 'top_1', 'top_2', 'pivot_high',
                'resistance_start', 'resistance_end', 'upper_start', 'upper_end',
                'pole_start', 'pole_end', 'flag_start', 'flag_end', 'left_rim', 'right_rim', 'handle_start', 'handle_end'];
            const lowPointTypes = ['first_trough', 'second_trough', 'valley', 'trough1', 'trough2', 'trough3',
                'bottom_1', 'bottom_2', 'pivot_low', 'support_start', 'support_end',
                'lower_start', 'lower_end', 'cup_bottom', 'neckline_left', 'neckline_right'];

            const isHighPoint = (pointType) => highPointTypes.includes(pointType || '');
            const isLowPoint = (pointType) => lowPointTypes.includes(pointType || '');

            // Find the best matching candle for a pattern point based on price proximity
            // This avoids placing markers in data gaps (weekends, holidays)
            const findBestCandleForPoint = (point) => {
                const targetPrice = point.price;
                const pointType = point.point_type || '';
                const isHigh = isHighPoint(pointType);
                const isLow = isLowPoint(pointType);

                // Search within the pattern formation area (last portion of candles)
                // Limit search to reasonable range to find nearest matching candle
                const searchStart = Math.max(0, candles.length - 100);
                let bestIdx = candles.length - 1;
                let bestScore = Infinity;

                for (let i = searchStart; i < candles.length; i++) {
                    const candle = candles[i];
                    let priceDiff;

                    if (isHigh) {
                        // For high points, find candle where high is closest to target price
                        priceDiff = Math.abs(candle.high - targetPrice);
                    } else if (isLow) {
                        // For low points, find candle where low is closest to target price
                        priceDiff = Math.abs(candle.low - targetPrice);
                    } else {
                        // Unknown type - use closest of high or low
                        priceDiff = Math.min(
                            Math.abs(candle.high - targetPrice),
                            Math.abs(candle.low - targetPrice)
                        );
                    }

                    if (priceDiff < bestScore) {
                        bestScore = priceDiff;
                        bestIdx = i;
                    }
                }

                return bestIdx;
            };

            // Pre-calculate best candle index for each pattern point
            const pointToCandleMap = new Map();
            patternPoints.forEach(p => {
                pointToCandleMap.set(p, findBestCandleForPoint(p));
            });

            // Sort pattern points by their mapped candle index to maintain time order
            const sortedPoints = [...patternPoints].sort((a, b) => {
                return pointToCandleMap.get(a) - pointToCandleMap.get(b);
            });

            // Map pattern point to candle index
            const mapIndex = (pointOrIndex) => {
                if (typeof pointOrIndex === 'object' && pointOrIndex !== null) {
                    return pointToCandleMap.get(pointOrIndex) || candles.length - 1;
                }
                // For raw index, fall back to last candle
                return candles.length - 1;
            };

            // Get actual price from candle at mapped index
            const getActualPrice = (point) => {
                const candleIdx = mapIndex(point);
                const candle = candles[candleIdx];
                if (!candle) return point.price;

                const pointType = point.point_type || '';

                if (isHighPoint(pointType)) {
                    return candle.high;
                } else if (isLowPoint(pointType)) {
                    return candle.low;
                } else {
                    // Unknown type - use the one closest to stored price
                    const storedPrice = point.price;
                    return Math.abs(candle.high - storedPrice) < Math.abs(candle.low - storedPrice)
                        ? candle.high : candle.low;
                }
            };

            // Categorize points by type
            const headShoulderTypes = ['left_shoulder', 'head', 'right_shoulder', 'neckline_left', 'neckline_right'];
            const doubleTypes = ['first_peak', 'second_peak', 'valley', 'first_trough', 'second_trough', 'peak'];
            const tripleTypes = ['peak1', 'peak2', 'peak3', 'trough1', 'trough2', 'trough3'];
            const triangleTypes = ['upper_start', 'upper_end', 'lower_start', 'lower_end', 'apex'];
            const channelTypes = ['upper_start', 'upper_end', 'lower_start', 'lower_end'];
            const flagTypes = ['pole_start', 'pole_end', 'flag_start', 'flag_end'];
            const cupTypes = ['left_rim', 'cup_bottom', 'right_rim', 'handle_start', 'handle_end'];
            const wedgeTypes = ['upper_start', 'upper_end', 'lower_start', 'lower_end'];

            // Also support generic pivot types
            const pivotHighs = patternPoints.filter(p => p.point_type === 'pivot_high');
            const pivotLows = patternPoints.filter(p => p.point_type === 'pivot_low');

            ctx.save();

            // Pattern line color based on type
            const direction = getPatternDirection(patternType);
            const colors = {
                bullish: { line: '#4caf50', point: '#81c784', secondary: '#2196f3' },
                bearish: { line: '#f44336', point: '#e57373', secondary: '#ff9800' },
                neutral: { line: '#ffc107', point: '#ffeb3b', secondary: '#9c27b0' }
            }[direction] || { line: '#ffc107', point: '#ffeb3b', secondary: '#9c27b0' };

            // Draw pattern-specific overlays based on pattern type
            if (patternType.includes('head_and_shoulders') || patternType.includes('inverse_head')) {
                drawHeadAndShoulders(ctx, patternPoints, mapIndex, getActualPrice, indexToX, priceToY, colors);
            } else if (patternType.includes('double_top') || patternType.includes('double_bottom')) {
                drawDoublePattern(ctx, patternPoints, mapIndex, getActualPrice, indexToX, priceToY, colors);
            } else if (patternType.includes('triple_top') || patternType.includes('triple_bottom')) {
                drawTriplePattern(ctx, patternPoints, mapIndex, getActualPrice, indexToX, priceToY, colors);
            } else if (patternType.includes('triangle') || patternType.includes('wedge')) {
                drawTriangleWedge(ctx, patternPoints, mapIndex, getActualPrice, indexToX, priceToY, colors);
            } else if (patternType.includes('channel')) {
                drawChannel(ctx, patternPoints, mapIndex, getActualPrice, indexToX, priceToY, colors);
            } else if (patternType.includes('flag')) {
                drawFlag(ctx, patternPoints, mapIndex, getActualPrice, indexToX, priceToY, colors);
            } else if (patternType.includes('cup_and_handle')) {
                drawCupAndHandle(ctx, patternPoints, mapIndex, getActualPrice, indexToX, priceToY, colors);
            } else {
                // Generic pivot point drawing
                drawGenericPivots(ctx, patternPoints, mapIndex, getActualPrice, indexToX, priceToY, colors);
            }

            ctx.restore();
        }

        // Draw Head and Shoulders pattern
        function drawHeadAndShoulders(ctx, points, mapIndex, getActualPrice, indexToX, priceToY, colors) {
            const byType = {};
            points.forEach(p => byType[p.point_type] = p);

            // Get the three main points
            const ls = byType['left_shoulder'];
            const head = byType['head'];
            const rs = byType['right_shoulder'];

            // Collect points and sort by their mapped candle index (time order)
            const mainPoints = [ls, head, rs].filter(p => p);
            if (mainPoints.length >= 2) {
                // Sort by mapped index to ensure correct time order (left to right)
                const sortedPoints = mainPoints
                    .map(p => ({ point: p, mappedIdx: mapIndex(p) }))
                    .sort((a, b) => a.mappedIdx - b.mappedIdx)
                    .map(item => item.point);

                // Draw pattern line through points in time order
                ctx.strokeStyle = colors.line;
                ctx.lineWidth = 2.5;
                ctx.setLineDash([]);
                ctx.beginPath();
                sortedPoints.forEach((p, i) => {
                    const x = indexToX(mapIndex(p));
                    const y = priceToY(getActualPrice(p));
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();

                // Draw circles with correct labels based on point type
                sortedPoints.forEach((p) => {
                    const x = indexToX(mapIndex(p));
                    const y = priceToY(getActualPrice(p));
                    const isHead = p.point_type === 'head';
                    const radius = isHead ? 8 : 6;

                    // Fill circle
                    ctx.fillStyle = isHead ? colors.secondary : colors.point;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();

                    // Label based on actual point type
                    const labelMap = { 'left_shoulder': 'LS', 'head': 'H', 'right_shoulder': 'RS' };
                    const label = labelMap[p.point_type] || '?';
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 9px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(label, x, y - radius - 4);
                });
            }

            // Draw neckline
            const nl1 = byType['neckline_left'];
            const nl2 = byType['neckline_right'];
            if (nl1 && nl2) {
                ctx.strokeStyle = '#9c27b0';
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 3]);
                ctx.beginPath();
                ctx.moveTo(indexToX(mapIndex(nl1)), priceToY(getActualPrice(nl1)));
                ctx.lineTo(indexToX(mapIndex(nl2)), priceToY(getActualPrice(nl2)));
                ctx.stroke();
                ctx.setLineDash([]);

                // Neckline label
                const nlMidX = (indexToX(mapIndex(nl1)) + indexToX(mapIndex(nl2))) / 2;
                const nlMidY = (priceToY(getActualPrice(nl1)) + priceToY(getActualPrice(nl2))) / 2;
                ctx.fillStyle = '#9c27b0';
                ctx.font = 'bold 9px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Neckline', nlMidX, nlMidY - 8);
            }
        }

        // Draw Double Top/Bottom pattern
        function drawDoublePattern(ctx, points, mapIndex, getActualPrice, indexToX, priceToY, colors) {
            const byType = {};
            points.forEach(p => byType[p.point_type] = p);

            // Support both naming conventions:
            // Backend uses: top_1, valley, top_2 / bottom_1, peak, bottom_2
            // Also support: first_peak, valley, second_peak / first_trough, peak, second_trough
            let orderedPoints = [];

            // Double Top patterns
            if (byType['top_1'] || byType['first_peak']) {
                const p1 = byType['top_1'] || byType['first_peak'];
                const mid = byType['valley'];
                const p2 = byType['top_2'] || byType['second_peak'];
                orderedPoints = [p1, mid, p2].filter(p => p);
            }
            // Double Bottom patterns
            else if (byType['bottom_1'] || byType['first_trough']) {
                const p1 = byType['bottom_1'] || byType['first_trough'];
                const mid = byType['peak'];
                const p2 = byType['bottom_2'] || byType['second_trough'];
                orderedPoints = [p1, mid, p2].filter(p => p);
            }

            if (orderedPoints.length >= 2) {
                ctx.strokeStyle = colors.line;
                ctx.lineWidth = 2.5;
                ctx.setLineDash([]);
                ctx.beginPath();
                orderedPoints.forEach((p, i) => {
                    const x = indexToX(mapIndex(p));
                    const y = priceToY(getActualPrice(p));
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();

                // Draw circles with labels
                orderedPoints.forEach((p, i) => {
                    const x = indexToX(mapIndex(p));
                    const y = priceToY(getActualPrice(p));
                    const isMiddle = i === 1;
                    const radius = isMiddle ? 5 : 7;

                    // Fill circle
                    ctx.fillStyle = isMiddle ? colors.secondary : colors.point;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();

                    // Label for tops/bottoms
                    if (!isMiddle) {
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 10px sans-serif';
                        ctx.textAlign = 'center';
                        const label = i === 0 ? '1' : '2';
                        ctx.fillText(label, x, y - radius - 5);
                    }
                });

                // Draw horizontal resistance/support line connecting the two peaks/troughs
                if (orderedPoints.length >= 3) {
                    const p1 = orderedPoints[0];
                    const p2 = orderedPoints[2];
                    const avgPrice = (getActualPrice(p1) + getActualPrice(p2)) / 2;

                    ctx.strokeStyle = colors.line;
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([5, 3]);
                    ctx.beginPath();
                    ctx.moveTo(indexToX(mapIndex(p1)), priceToY(avgPrice));
                    ctx.lineTo(indexToX(mapIndex(p2)), priceToY(avgPrice));
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }

        // Draw Triple Top/Bottom pattern
        function drawTriplePattern(ctx, points, mapIndex, getActualPrice, indexToX, priceToY, colors) {
            const byType = {};
            points.forEach(p => byType[p.point_type] = p);

            // Identify peaks and troughs
            const peaks = points.filter(p =>
                p.point_type.includes('peak') || p.point_type.includes('top') ||
                p.point_type.includes('high') || p.point_type.includes('resistance')
            ).sort((a, b) => a.index - b.index);

            const troughs = points.filter(p =>
                p.point_type.includes('trough') || p.point_type.includes('bottom') ||
                p.point_type.includes('low') || p.point_type.includes('support')
            ).sort((a, b) => a.index - b.index);

            // Determine if triple top or triple bottom
            const isTripleTop = peaks.length >= troughs.length;
            const mainPoints = isTripleTop ? peaks : troughs;
            const secondaryPoints = isTripleTop ? troughs : peaks;

            // Sort all points by index for line drawing
            const allPoints = [...points].sort((a, b) => a.index - b.index);

            if (allPoints.length >= 2) {
                // Draw connecting line
                ctx.strokeStyle = colors.line;
                ctx.lineWidth = 2.5;
                ctx.setLineDash([]);
                ctx.beginPath();
                allPoints.forEach((p, i) => {
                    const x = indexToX(mapIndex(p));
                    const y = priceToY(getActualPrice(p));
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();

                // Draw horizontal resistance/support line through main points
                if (mainPoints.length >= 2) {
                    const avgPrice = mainPoints.reduce((sum, p) => sum + getActualPrice(p), 0) / mainPoints.length;
                    const minIdx = Math.min(...mainPoints.map(p => p.index));
                    const maxIdx = Math.max(...mainPoints.map(p => p.index));

                    ctx.strokeStyle = colors.line;
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([5, 3]);
                    ctx.beginPath();
                    ctx.moveTo(indexToX(mapIndex(minIdx)), priceToY(avgPrice));
                    ctx.lineTo(indexToX(mapIndex(maxIdx)), priceToY(avgPrice));
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // Draw circles with numbers
                let peakNum = 1, troughNum = 1;
                allPoints.forEach(p => {
                    const x = indexToX(mapIndex(p));
                    const y = priceToY(getActualPrice(p));
                    const isPeak = peaks.includes(p);
                    const radius = 6;

                    // Fill circle
                    ctx.fillStyle = isPeak ? colors.point : colors.secondary;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();

                    // Label
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 9px sans-serif';
                    ctx.textAlign = 'center';
                    const label = isPeak ? (peakNum++).toString() : '';
                    if (label) ctx.fillText(label, x, y - radius - 4);
                });
            }
        }

        // Draw Triangle/Wedge pattern
        function drawTriangleWedge(ctx, points, mapIndex, getActualPrice, indexToX, priceToY, colors) {
            const byType = {};
            points.forEach(p => byType[p.point_type] = p);

            // Support both naming conventions:
            // Backend may use: upper_start/upper_end OR resistance_start/resistance_end
            // Backend may use: lower_start/lower_end OR support_start/support_end
            const us = byType['upper_start'] || byType['resistance_start'];
            const ue = byType['upper_end'] || byType['resistance_end'];
            const ls = byType['lower_start'] || byType['support_start'];
            const le = byType['lower_end'] || byType['support_end'];

            // Upper trendline (Resistance)
            if (us && ue) {
                ctx.strokeStyle = colors.line;
                ctx.lineWidth = 2.5;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(indexToX(mapIndex(us)), priceToY(getActualPrice(us)));
                ctx.lineTo(indexToX(mapIndex(ue)), priceToY(getActualPrice(ue)));
                ctx.stroke();

                // Label for upper trendline
                const midX = (indexToX(mapIndex(us)) + indexToX(mapIndex(ue))) / 2;
                const midY = (priceToY(getActualPrice(us)) + priceToY(getActualPrice(ue))) / 2;
                ctx.fillStyle = colors.line;
                ctx.font = 'bold 9px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('R', midX, midY - 8);
            }

            // Lower trendline (Support)
            if (ls && le) {
                ctx.strokeStyle = colors.secondary;
                ctx.lineWidth = 2.5;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(indexToX(mapIndex(ls)), priceToY(getActualPrice(ls)));
                ctx.lineTo(indexToX(mapIndex(le)), priceToY(getActualPrice(le)));
                ctx.stroke();

                // Label for lower trendline
                const midX = (indexToX(mapIndex(ls)) + indexToX(mapIndex(le))) / 2;
                const midY = (priceToY(getActualPrice(ls)) + priceToY(getActualPrice(le))) / 2;
                ctx.fillStyle = colors.secondary;
                ctx.font = 'bold 9px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('S', midX, midY + 14);
            }

            // Draw apex if exists (convergence point)
            const apex = byType['apex'];
            if (apex) {
                const x = indexToX(mapIndex(apex));
                const y = priceToY(getActualPrice(apex));
                ctx.fillStyle = '#ffeb3b';
                ctx.beginPath();
                ctx.arc(x, y, 7, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // Apex label
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 9px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Apex', x, y - 10);
            }

            // Draw corner points with circles
            [us, ue, ls, le].filter(p => p).forEach((p, i) => {
                const x = indexToX(mapIndex(p));
                const y = priceToY(getActualPrice(p));
                const isUpper = p === us || p === ue;

                ctx.fillStyle = isUpper ? colors.point : colors.secondary;
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.stroke();
            });
        }

        // Draw Channel pattern (parallel trendlines)
        function drawChannel(ctx, points, mapIndex, getActualPrice, indexToX, priceToY, colors) {
            const byType = {};
            points.forEach(p => byType[p.point_type] = p);

            // Support both naming conventions
            const us = byType['upper_start'] || byType['resistance_start'];
            const ue = byType['upper_end'] || byType['resistance_end'];
            const ls = byType['lower_start'] || byType['support_start'];
            const le = byType['lower_end'] || byType['support_end'];

            // Upper channel line (Resistance)
            if (us && ue) {
                ctx.strokeStyle = colors.line;
                ctx.lineWidth = 2.5;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(indexToX(mapIndex(us)), priceToY(getActualPrice(us)));
                ctx.lineTo(indexToX(mapIndex(ue)), priceToY(getActualPrice(ue)));
                ctx.stroke();

                // Upper channel label
                const midX = (indexToX(mapIndex(us)) + indexToX(mapIndex(ue))) / 2;
                const midY = (priceToY(getActualPrice(us)) + priceToY(getActualPrice(ue))) / 2;
                ctx.fillStyle = colors.line;
                ctx.font = 'bold 9px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Upper', midX, midY - 8);
            }

            // Lower channel line (Support)
            if (ls && le) {
                ctx.strokeStyle = colors.secondary;
                ctx.lineWidth = 2.5;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(indexToX(mapIndex(ls)), priceToY(getActualPrice(ls)));
                ctx.lineTo(indexToX(mapIndex(le)), priceToY(getActualPrice(le)));
                ctx.stroke();

                // Lower channel label
                const midX = (indexToX(mapIndex(ls)) + indexToX(mapIndex(le))) / 2;
                const midY = (priceToY(getActualPrice(ls)) + priceToY(getActualPrice(le))) / 2;
                ctx.fillStyle = colors.secondary;
                ctx.font = 'bold 9px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Lower', midX, midY + 14);
            }

            // Draw corner points with labels
            const allPoints = [
                { point: us, label: 'H1', isUpper: true },
                { point: ue, label: 'H2', isUpper: true },
                { point: ls, label: 'L1', isUpper: false },
                { point: le, label: 'L2', isUpper: false }
            ].filter(item => item.point);

            allPoints.forEach(({ point, label, isUpper }) => {
                const x = indexToX(mapIndex(point));
                const y = priceToY(getActualPrice(point));

                ctx.fillStyle = isUpper ? colors.point : colors.secondary;
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Point label
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 8px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(label, x, isUpper ? y - 8 : y + 14);
            });
        }

        // Draw Flag pattern (Bull Flag / Bear Flag)
        function drawFlag(ctx, points, mapIndex, getActualPrice, indexToX, priceToY, colors) {
            const byType = {};
            points.forEach(p => byType[p.point_type] = p);

            // Pole (the initial strong move)
            const ps = byType['pole_start'];
            const pe = byType['pole_end'];
            if (ps && pe) {
                ctx.strokeStyle = colors.line;
                ctx.lineWidth = 3;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(indexToX(mapIndex(ps)), priceToY(getActualPrice(ps)));
                ctx.lineTo(indexToX(mapIndex(pe)), priceToY(getActualPrice(pe)));
                ctx.stroke();

                // Pole start/end points
                [ps, pe].forEach((p, i) => {
                    const x = indexToX(mapIndex(p));
                    const y = priceToY(getActualPrice(p));
                    ctx.fillStyle = colors.point;
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                });

                // Pole label
                const midX = (indexToX(mapIndex(ps)) + indexToX(mapIndex(pe))) / 2;
                const midY = (priceToY(getActualPrice(ps)) + priceToY(getActualPrice(pe))) / 2;
                ctx.fillStyle = colors.line;
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Pole', midX - 20, midY);
            }

            // Flag (the consolidation pattern)
            const fs = byType['flag_start'] || pe;  // flag_start often equals pole_end
            const fe = byType['flag_end'];
            if (fs && fe) {
                // Draw flag rectangle/channel area
                ctx.strokeStyle = colors.secondary;
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 2]);
                ctx.beginPath();
                ctx.moveTo(indexToX(mapIndex(fs)), priceToY(getActualPrice(fs)));
                ctx.lineTo(indexToX(mapIndex(fe)), priceToY(getActualPrice(fe)));
                ctx.stroke();
                ctx.setLineDash([]);

                // Flag endpoint
                const x = indexToX(mapIndex(fe));
                const y = priceToY(getActualPrice(fe));
                ctx.fillStyle = colors.secondary;
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Flag label
                const flagMidX = (indexToX(mapIndex(fs)) + indexToX(mapIndex(fe))) / 2;
                const flagMidY = (priceToY(getActualPrice(fs)) + priceToY(getActualPrice(fe))) / 2;
                ctx.fillStyle = colors.secondary;
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Flag', flagMidX + 20, flagMidY);
            }
        }

        // Draw Cup and Handle pattern
        function drawCupAndHandle(ctx, points, mapIndex, getActualPrice, indexToX, priceToY, colors) {
            const byType = {};
            points.forEach(p => byType[p.point_type] = p);

            // Cup curve (simplified as line through points)
            const cupPoints = ['left_rim', 'cup_bottom', 'right_rim'].filter(t => byType[t]).map(t => byType[t]);
            const cupLabels = ['LR', 'Bottom', 'RR'];  // Left Rim, Bottom, Right Rim

            if (cupPoints.length >= 2) {
                ctx.strokeStyle = colors.line;
                ctx.lineWidth = 2.5;
                ctx.setLineDash([]);

                // Draw as curve
                ctx.beginPath();
                if (cupPoints.length === 3) {
                    const [left, bottom, right] = cupPoints;
                    ctx.moveTo(indexToX(mapIndex(left)), priceToY(getActualPrice(left)));
                    ctx.quadraticCurveTo(
                        indexToX(mapIndex(bottom)), priceToY(getActualPrice(bottom)),
                        indexToX(mapIndex(right)), priceToY(getActualPrice(right))
                    );
                } else {
                    cupPoints.forEach((p, i) => {
                        const x = indexToX(mapIndex(p));
                        const y = priceToY(getActualPrice(p));
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    });
                }
                ctx.stroke();

                // Draw cup points with labels
                cupPoints.forEach((p, i) => {
                    const x = indexToX(mapIndex(p));
                    const y = priceToY(getActualPrice(p));
                    const isBottom = i === 1;
                    const radius = isBottom ? 7 : 5;

                    ctx.fillStyle = isBottom ? colors.secondary : colors.point;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    // Label
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 8px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(cupLabels[i], x, isBottom ? y + radius + 12 : y - radius - 5);
                });

                // Add "Cup" label in the middle
                if (cupPoints.length >= 2) {
                    const firstPoint = cupPoints[0];
                    const lastPoint = cupPoints[cupPoints.length - 1];
                    const cupMidX = (indexToX(mapIndex(firstPoint.index)) + indexToX(mapIndex(lastPoint.index))) / 2;
                    const cupMidY = cupPoints.length === 3
                        ? priceToY(getActualPrice(cupPoints[1]))
                        : (priceToY(getActualPrice(firstPoint)) + priceToY(getActualPrice(lastPoint))) / 2;

                    ctx.fillStyle = colors.line;
                    ctx.font = 'bold 10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('Cup', cupMidX, cupMidY + 25);
                }
            }

            // Handle
            const hs = byType['handle_start'];
            const he = byType['handle_end'];
            if (hs && he) {
                ctx.strokeStyle = colors.secondary;
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 2]);
                ctx.beginPath();
                ctx.moveTo(indexToX(mapIndex(hs)), priceToY(getActualPrice(hs)));
                ctx.lineTo(indexToX(mapIndex(he)), priceToY(getActualPrice(he)));
                ctx.stroke();
                ctx.setLineDash([]);

                // Handle endpoints
                [hs, he].forEach((p, i) => {
                    const x = indexToX(mapIndex(p));
                    const y = priceToY(getActualPrice(p));
                    ctx.fillStyle = colors.secondary;
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                });

                // Handle label
                const handleMidX = (indexToX(mapIndex(hs)) + indexToX(mapIndex(he))) / 2;
                const handleMidY = (priceToY(getActualPrice(hs)) + priceToY(getActualPrice(he))) / 2;
                ctx.fillStyle = colors.secondary;
                ctx.font = 'bold 9px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Handle', handleMidX, handleMidY - 10);
            }
        }

        // Draw generic pivot points (fallback for unrecognized patterns)
        function drawGenericPivots(ctx, points, mapIndex, getActualPrice, indexToX, priceToY, colors) {
            const sorted = [...points].sort((a, b) => a.index - b.index);

            if (sorted.length >= 2) {
                // Draw connecting line
                ctx.strokeStyle = colors.line;
                ctx.lineWidth = 2.5;
                ctx.setLineDash([]);
                ctx.beginPath();
                sorted.forEach((p, i) => {
                    const x = indexToX(mapIndex(p));
                    const y = priceToY(getActualPrice(p));
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();

                // Draw numbered points
                let highNum = 1, lowNum = 1;
                sorted.forEach((p, idx) => {
                    const x = indexToX(mapIndex(p));
                    const y = priceToY(getActualPrice(p));
                    const isHigh = p.point_type.includes('high') || p.point_type.includes('peak') ||
                                   p.point_type.includes('shoulder') || p.point_type.includes('head') ||
                                   p.point_type.includes('top') || p.point_type.includes('resistance');

                    // Circle
                    ctx.fillStyle = isHigh ? colors.point : colors.secondary;
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();

                    // Label with H1, H2... for highs and L1, L2... for lows
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 8px sans-serif';
                    ctx.textAlign = 'center';
                    const label = isHigh ? `H${highNum++}` : `L${lowNum++}`;
                    ctx.fillText(label, x, isHigh ? y - 10 : y + 14);
                });
            } else if (sorted.length === 1) {
                // Single point
                const p = sorted[0];
                const x = indexToX(mapIndex(p));
                const y = priceToY(getActualPrice(p));

                ctx.fillStyle = colors.point;
                ctx.beginPath();
                ctx.arc(x, y, 7, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 9px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('P', x, y - 10);
            }
        }

        // Get pattern direction
        function getPatternDirection(patternType) {
            const bullishPatterns = ['inverse_head_and_shoulders', 'double_bottom', 'triple_bottom',
                                     'ascending_triangle', 'bull_flag', 'cup_and_handle', 'falling_wedge', 'channel_up'];
            const bearishPatterns = ['head_and_shoulders', 'double_top', 'triple_top',
                                     'descending_triangle', 'bear_flag', 'rising_wedge', 'channel_down'];

            if (bullishPatterns.includes(patternType)) return 'bullish';
            if (bearishPatterns.includes(patternType)) return 'bearish';
            return 'neutral';
        }

        // Close chart modal
        function closeChartModal() {
            document.getElementById('chartModal').classList.remove('show');
        }

        // Setup chart modal events
        function setupChartModal() {
            const modal = document.getElementById('chartModal');
            if (!modal) return;

            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    closeChartModal();
                }
            });

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && modal.classList.contains('show')) {
                    closeChartModal();
                }
            });
        }
    </script>

    <!-- Pattern Modal for Pattern Visualization -->
    <div class="modal-overlay chart-modal" id="chartModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">
                    <span id="chartModalTitle">Pattern</span>
                    <span id="chartModalBadges" style="margin-left: 0.5rem;"></span>
                </h3>
                <button type="button" class="modal-close" onclick="closeChartModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="modal-section">
                    <div class="modal-section-title">Pattern-Chart</div>
                    <!-- Loading indicator -->
                    <div id="chartLoading" style="display: flex; justify-content: center; align-items: center; padding: 2rem; color: #888;">
                        <span style="margin-right: 0.5rem;">⏳</span> Chart wird geladen...
                    </div>
                    <!-- Real candlestick chart with pattern overlay -->
                    <div class="chart-container" id="patternChartContainer" style="display: none; height: 320px; padding: 0.5rem;">
                        <canvas id="patternCanvas" style="width: 100%; height: 100%;"></canvas>
                    </div>
                    <!-- Fallback SVG visualization -->
                    <div class="chart-container" id="patternSvgContainer" style="display: none; justify-content: center; align-items: center; padding: 1rem;">
                        <!-- SVG wird dynamisch eingefügt -->
                    </div>
                    <div class="chart-info" id="chartInfo" style="display: none;">
                        <div class="chart-info-item">
                            <span class="chart-info-label">Symbol:</span>
                            <span class="chart-info-value" id="chartSymbol">-</span>
                        </div>
                        <div class="chart-info-item">
                            <span class="chart-info-label">Timeframe:</span>
                            <span class="chart-info-value" id="chartTimeframe">-</span>
                        </div>
                        <div class="chart-info-item">
                            <span class="chart-info-label">Erkannt:</span>
                            <span class="chart-info-value" id="chartPatternTime">-</span>
                        </div>
                        <div class="chart-info-item">
                            <span class="chart-info-label">Typ:</span>
                            <span class="chart-info-value" id="chartPatternType">-</span>
                        </div>
                    </div>
                </div>
                <div class="modal-section">
                    <div class="modal-section-title">Pattern-Beschreibung</div>
                    <div class="modal-description" id="chartPatternDescription"></div>
                </div>
                <div class="modal-section">
                    <div class="modal-section-title">Trading-Implikation</div>
                    <div class="modal-implication" id="chartPatternImplication"></div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>
