<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TCN Pattern Service - Konfiguration</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            color: #e8e8e8;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1.5rem;
        }

        header {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1rem 0;
            margin-bottom: 1.5rem;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        header .container {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #64c8ff;
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .back-link:hover {
            color: #fff;
        }

        .header-title {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .service-badge {
            background: rgba(76, 175, 80, 0.2);
            color: #81c784;
            padding: 0.3rem 0.8rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .service-badge.offline {
            background: rgba(244, 67, 54, 0.2);
            color: #e57373;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 0.5rem;
        }

        .tab-btn {
            padding: 0.75rem 1.5rem;
            background: transparent;
            border: none;
            color: #a0a0a0;
            font-size: 1rem;
            cursor: pointer;
            border-radius: 8px 8px 0 0;
            transition: all 0.2s;
        }

        .tab-btn:hover {
            background: rgba(255, 255, 255, 0.05);
            color: #e8e8e8;
        }

        .tab-btn.active {
            background: rgba(100, 200, 255, 0.15);
            color: #64c8ff;
            border-bottom: 2px solid #64c8ff;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Card */
        .card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 1.5rem;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .card-title {
            font-size: 1.2rem;
            color: #64c8ff;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Buttons */
        .btn {
            padding: 0.6rem 1.2rem;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
        }

        .btn-primary {
            background: rgba(100, 200, 255, 0.2);
            color: #64c8ff;
            border: 1px solid rgba(100, 200, 255, 0.3);
        }

        .btn-primary:hover {
            background: rgba(100, 200, 255, 0.3);
        }

        .btn-success {
            background: rgba(76, 175, 80, 0.2);
            color: #81c784;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .btn-success:hover {
            background: rgba(76, 175, 80, 0.3);
        }

        .btn-danger {
            background: rgba(244, 67, 54, 0.2);
            color: #e57373;
            border: 1px solid rgba(244, 67, 54, 0.3);
        }

        .btn-danger:hover {
            background: rgba(244, 67, 54, 0.3);
        }

        .btn-warning {
            background: rgba(255, 152, 0, 0.2);
            color: #ffb74d;
            border: 1px solid rgba(255, 152, 0, 0.3);
        }

        .btn-warning:hover {
            background: rgba(255, 152, 0, 0.3);
        }

        .btn-loading {
            position: relative;
            pointer-events: none;
            opacity: 0.8;
        }

        .btn-loading::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 12px;
            top: 50%;
            right: 8px;
            margin-top: -6px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .btn-sm {
            padding: 0.4rem 0.8rem;
            font-size: 0.8rem;
        }

        /* Grid Layout */
        .grid-2 {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 1.5rem;
        }

        .grid-2-equal {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
        }

        .grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
        }

        @media (max-width: 900px) {
            .grid-2, .grid-2-equal, .grid-3 {
                grid-template-columns: 1fr;
            }
        }

        /* Training Status */
        .training-status {
            font-size: 0.9rem;
        }

        .training-status .training-active {
            color: #4ade80;
            font-weight: 600;
            animation: blink 1s ease-in-out infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .progress-bar {
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            overflow: hidden;
            margin: 0.75rem 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #64c8ff, #a78bfa);
            border-radius: 6px;
            transition: width 0.3s;
        }

        /* Pattern Badge */
        .pattern-badge {
            display: inline-block;
            padding: 0.3rem 0.6rem;
            margin: 0.2rem;
            border-radius: 6px;
            font-size: 0.75rem;
            background: rgba(156, 39, 176, 0.2);
            color: #ce93d8;
            border: 1px solid rgba(156, 39, 176, 0.3);
        }

        .pattern-badge.bullish {
            background: rgba(76, 175, 80, 0.2);
            color: #81c784;
            border-color: rgba(76, 175, 80, 0.3);
        }

        .pattern-badge.bearish {
            background: rgba(244, 67, 54, 0.2);
            color: #e57373;
            border-color: rgba(244, 67, 54, 0.3);
        }

        .pattern-badge.neutral {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
            border-color: rgba(255, 193, 7, 0.3);
        }

        /* Table */
        .data-table {
            width: 100%;
            border-collapse: collapse;
        }

        .data-table th,
        .data-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .data-table th {
            color: #888;
            font-weight: 500;
            font-size: 0.85rem;
        }

        .data-table tr:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            background: rgba(30, 30, 30, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
            animation: slideIn 0.3s ease;
        }

        .toast.success {
            border-left: 4px solid #4caf50;
        }

        .toast.error {
            border-left: 4px solid #f44336;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Loading Spinner */
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 3rem;
            color: #888;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(100, 200, 255, 0.2);
            border-top-color: #64c8ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .confidence-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 0.5rem;
        }

        .confidence-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s;
        }

        .confidence-fill.high { background: #4caf50; }
        .confidence-fill.medium { background: #ffc107; }
        .confidence-fill.low { background: #f44336; }

        /* Form Elements */
        .form-group {
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #aaa;
            font-size: 0.9rem;
        }

        .form-control {
            width: 100%;
            padding: 0.6rem 1rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #e8e8e8;
            font-size: 0.9rem;
        }

        .form-control:focus {
            outline: none;
            border-color: #64c8ff;
        }

        select.form-control {
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%2364c8ff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 0.7rem center;
            background-size: 1em;
            padding-right: 2.5rem;
        }

        select.form-control option {
            background-color: #1a1a2e;
            color: #e8e8e8;
            padding: 0.5rem;
        }

        select.form-control option:hover,
        select.form-control option:focus,
        select.form-control option:checked {
            background-color: #2a2a4e;
            color: #64c8ff;
        }

        /* Info Box */
        .info-box {
            background: rgba(33, 150, 243, 0.1);
            border: 1px solid rgba(33, 150, 243, 0.3);
            border-radius: 8px;
            padding: 1rem;
            font-size: 0.85rem;
            color: #90caf9;
        }

        /* Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 5000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(100, 200, 255, 0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.25rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-title {
            color: #64c8ff;
            font-size: 1.2rem;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem;
            line-height: 1;
        }

        .modal-close:hover {
            color: #fff;
        }

        .modal-body {
            padding: 1.25rem;
        }

        .modal-section {
            margin-bottom: 1.25rem;
        }

        .modal-section:last-child {
            margin-bottom: 0;
        }

        .modal-section-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #888;
            margin-bottom: 0.5rem;
        }

        /* Chart Modal - Larger */
        .chart-modal .modal {
            max-width: 900px;
            width: 95%;
        }

        .chart-container {
            width: 100%;
            height: 280px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }

        .chart-loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            color: #888;
        }

        .chart-error {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            color: #e57373;
            flex-direction: column;
            gap: 0.5rem;
        }

        .chart-canvas-container {
            width: 100%;
            height: 100%;
            padding: 10px;
        }

        .chart-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            margin-top: 0.5rem;
            font-size: 0.8rem;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .chart-info-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .chart-info-label {
            color: #888;
        }

        .chart-info-value {
            color: #64c8ff;
            font-weight: 500;
        }

        .modal-implication {
            padding: 0.75rem;
            border-radius: 6px;
            font-style: italic;
        }

        .modal-implication.bullish {
            background: rgba(76, 175, 80, 0.15);
            color: #81c784;
            border-left: 3px solid #81c784;
        }

        .modal-implication.bearish {
            background: rgba(244, 67, 54, 0.15);
            color: #e57373;
            border-left: 3px solid #e57373;
        }

        .modal-implication.neutral {
            background: rgba(255, 152, 0, 0.15);
            color: #ffb74d;
            border-left: 3px solid #ffb74d;
        }

        .modal-description {
            color: #ccc;
            line-height: 1.6;
        }

        /* Chart Button */
        .btn-chart {
            background: rgba(156, 39, 176, 0.2);
            color: #ce93d8;
            border: 1px solid rgba(156, 39, 176, 0.3);
            padding: 0.2rem 0.5rem;
            font-size: 0.75rem;
            cursor: pointer;
            border-radius: 4px;
        }

        .btn-chart:hover {
            background: rgba(156, 39, 176, 0.3);
        }

        /* Clickable table row */
        .data-table tr.clickable-row {
            cursor: pointer;
            transition: background 0.2s;
        }

        .data-table tr.clickable-row:hover {
            background: rgba(100, 200, 255, 0.1);
        }

        /* Status Grid for Status Tab */
        .status-grid-4 {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        @media (max-width: 800px) {
            .status-grid-4 {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .status-card {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 1.25rem;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.08);
            transition: all 0.3s;
        }

        .status-card:hover {
            border-color: rgba(100, 200, 255, 0.3);
        }

        .status-card.healthy {
            border-color: rgba(76, 175, 80, 0.4);
            background: rgba(76, 175, 80, 0.1);
        }

        .status-card.unhealthy {
            border-color: rgba(244, 67, 54, 0.4);
            background: rgba(244, 67, 54, 0.1);
        }

        .status-icon {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
        }

        .status-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.6;
            margin-bottom: 0.25rem;
        }

        .status-value {
            font-size: 1rem;
            font-weight: 600;
            color: #64c8ff;
        }

        .status-value.success {
            color: #81c784;
        }

        .status-value.error {
            color: #ef5350;
        }

        /* Pattern Stats Bar */
        .pattern-stats-bar {
            display: flex;
            justify-content: space-around;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 0.75rem;
            margin-bottom: 1rem;
        }

        .pattern-stat {
            text-align: center;
        }

        .pattern-stat-value {
            font-size: 1.25rem;
            font-weight: 600;
        }

        .pattern-stat-value.bullish {
            color: #81c784;
        }

        .pattern-stat-value.bearish {
            color: #ef5350;
        }

        .pattern-stat-value.neutral {
            color: #ffc107;
        }

        .pattern-stat-label {
            font-size: 0.75rem;
            opacity: 0.6;
        }

        /* Pattern Filters */
        .pattern-filters {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 1.5rem;
        }

        .pattern-filter-btn {
            padding: 0.5rem 1rem;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.2);
            color: #e8e8e8;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.85rem;
        }

        .pattern-filter-btn:hover {
            background: rgba(100, 200, 255, 0.1);
            border-color: rgba(100, 200, 255, 0.3);
        }

        .pattern-filter-btn.active {
            background: rgba(100, 200, 255, 0.2);
            border-color: #64c8ff;
            color: #64c8ff;
        }

        .pattern-filter-btn.bullish.active {
            background: rgba(76, 175, 80, 0.2);
            border-color: #81c784;
            color: #81c784;
        }

        .pattern-filter-btn.bearish.active {
            background: rgba(244, 67, 54, 0.2);
            border-color: #ef5350;
            color: #ef5350;
        }

        .pattern-filter-btn.neutral.active {
            background: rgba(255, 193, 7, 0.2);
            border-color: #ffc107;
            color: #ffc107;
        }

        /* Pattern Overview Grid */
        .pattern-overview-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
        }

        @media (max-width: 1200px) {
            .pattern-overview-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 900px) {
            .pattern-overview-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 600px) {
            .pattern-overview-grid {
                grid-template-columns: 1fr;
            }
        }

        .pattern-overview-card {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.08);
            transition: all 0.3s;
        }

        .pattern-overview-card:hover {
            border-color: rgba(100, 200, 255, 0.3);
            transform: translateY(-2px);
        }

        .pattern-overview-card.hidden {
            display: none;
        }

        .pattern-overview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .pattern-overview-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #64c8ff;
        }

        .pattern-overview-badge {
            font-size: 0.65rem;
            padding: 0.2rem 0.5rem;
            border-radius: 10px;
            font-weight: 500;
        }

        .pattern-overview-badge.bullish {
            background: rgba(76, 175, 80, 0.2);
            color: #81c784;
        }

        .pattern-overview-badge.bearish {
            background: rgba(244, 67, 54, 0.2);
            color: #ef5350;
        }

        .pattern-overview-badge.neutral {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }

        .pattern-overview-svg {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 6px;
            padding: 0.5rem;
            margin-bottom: 0.75rem;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .pattern-overview-svg svg {
            width: 100%;
            max-width: 200px;
            height: 70px;
        }

        .pattern-overview-signal {
            font-size: 0.75rem;
            color: #888;
            text-align: center;
        }

        /* Pattern Detail Modal */
        .pattern-detail-modal .modal {
            max-width: 900px;
            width: 95%;
        }

        .pattern-detail-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .pattern-detail-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #64c8ff;
        }

        .pattern-detail-badges {
            display: flex;
            gap: 0.5rem;
        }

        .pattern-detail-grid {
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }

        @media (max-width: 700px) {
            .pattern-detail-grid {
                grid-template-columns: 1fr;
            }
        }

        .pattern-detail-svg-container {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            padding: 1.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .pattern-detail-svg-container svg {
            width: 100%;
            max-width: 250px;
            height: 150px;
        }

        .pattern-detail-description {
            color: #ccc;
            line-height: 1.7;
            font-size: 0.95rem;
        }

        .pattern-detail-section {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 1.25rem;
            margin-bottom: 1rem;
        }

        .pattern-detail-section-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1rem;
            font-weight: 600;
            color: #64c8ff;
            margin-bottom: 1rem;
        }

        /* Komponenten-Karten */
        .pattern-components {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        .pattern-component-card {
            flex: 1;
            min-width: 140px;
            background: rgba(100, 200, 255, 0.08);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
        }

        .pattern-component-number {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #64c8ff;
            margin-bottom: 0.25rem;
        }

        .pattern-component-name {
            font-weight: 600;
            color: #e8e8e8;
            margin-bottom: 0.25rem;
        }

        .pattern-component-desc {
            font-size: 0.8rem;
            color: #888;
        }

        /* Trading Grid */
        .pattern-trading-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }

        @media (max-width: 500px) {
            .pattern-trading-grid {
                grid-template-columns: 1fr;
            }
        }

        .pattern-trading-card {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
        }

        .pattern-trading-card.entry {
            border-left: 3px solid #64c8ff;
        }

        .pattern-trading-card.target {
            border-left: 3px solid #81c784;
        }

        .pattern-trading-card.stoploss {
            border-left: 3px solid #ef5350;
        }

        .pattern-trading-card.invalidation {
            border-left: 3px solid #ffb74d;
        }

        .pattern-trading-label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #888;
            margin-bottom: 0.5rem;
        }

        .pattern-trading-value {
            color: #e8e8e8;
            font-size: 0.9rem;
        }

        /* Quick Facts Grid */
        .pattern-facts-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
        }

        @media (max-width: 600px) {
            .pattern-facts-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .pattern-fact-item {
            text-align: center;
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .pattern-fact-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #888;
            margin-bottom: 0.25rem;
        }

        .pattern-fact-value {
            font-weight: 600;
            color: #64c8ff;
        }

        .pattern-fact-value.bullish { color: #81c784; }
        .pattern-fact-value.bearish { color: #ef5350; }

        /* Bedeutung Liste */
        .pattern-meaning-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .pattern-meaning-list li {
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            padding: 0.5rem 0;
            color: #ccc;
            font-size: 0.9rem;
        }

        .pattern-meaning-list li::before {
            content: "‚Ä¢";
            color: #64c8ff;
            font-weight: bold;
        }

        /* Related Patterns */
        .related-patterns {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .related-pattern-chip {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.75rem 1rem;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .related-pattern-chip:hover {
            background: rgba(100, 200, 255, 0.2);
            border-color: rgba(100, 200, 255, 0.4);
            transform: translateY(-2px);
        }

        .related-pattern-name {
            font-weight: 500;
            color: #e8e8e8;
            font-size: 0.85rem;
        }

        .related-pattern-relation {
            font-size: 0.7rem;
            color: #888;
            margin-top: 0.25rem;
        }

        /* Zuverl√§ssigkeits-Sterne */
        .reliability-stars {
            color: #ffc107;
            letter-spacing: 2px;
        }

        /* Neckline Info */
        .pattern-neckline-info {
            color: #ffc107;
            font-size: 0.85rem;
            padding-top: 0.75rem;
            border-top: 1px dashed rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
        }

        /* Pattern Overview Card Clickable */
        .pattern-overview-card {
            cursor: pointer;
        }

        .pattern-overview-card:hover {
            border-color: rgba(100, 200, 255, 0.5);
            transform: translateY(-3px);
            box-shadow: 0 4px 15px rgba(100, 200, 255, 0.15);
        }
    </style>
</head>
<body>
    <header>
        <div class="container" style="flex-direction: column; gap: 0.5rem;">
            <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                <a href="index.html" class="back-link">&#8592; Dashboard</a>
                <h1 class="header-title">&#128202; TCN Pattern Service</h1>
                <span class="service-badge" id="status-badge">Laden...</span>
            </div>
            <!-- Compact Header Status Bar -->
            <div style="display: flex; gap: 1.5rem; align-items: center; flex-wrap: wrap; font-size: 0.85rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.1);">
                <div style="display: flex; align-items: center; gap: 0.4rem;" title="Service-Status">
                    <span>‚è≥</span>
                    <span style="color: #888;">Status:</span>
                    <strong id="statusValue-service" style="color: #64c8ff;">L√§dt...</strong>
                </div>
                <div style="display: flex; align-items: center; gap: 0.4rem;" title="Aktuell geladenes Modell">
                    <span>üß†</span>
                    <span style="color: #888;">Modell:</span>
                    <strong id="statusValue-model" style="color: #64c8ff;">L√§dt...</strong>
                </div>
                <div style="display: flex; align-items: center; gap: 0.4rem;" title="CPU oder CUDA GPU">
                    <span>üñ•Ô∏è</span>
                    <span style="color: #888;">Device:</span>
                    <strong id="statusValue-device" style="color: #64c8ff;">L√§dt...</strong>
                </div>
                <div style="display: flex; align-items: center; gap: 0.4rem;" title="Anzahl Modell-Parameter (Komplexit√§t)">
                    <span>‚öôÔ∏è</span>
                    <span style="color: #888;">Parameter:</span>
                    <strong id="stat-params" style="color: #64c8ff;">-</strong>
                </div>
                <div style="display: flex; align-items: center; gap: 0.4rem;" title="Zeit seit Service-Start">
                    <span>‚è±Ô∏è</span>
                    <span style="color: #888;">Uptime:</span>
                    <strong id="stat-uptime" style="color: #64c8ff;">-</strong>
                </div>
                <button class="btn btn-primary btn-sm" onclick="refreshStatusTab()" style="margin-left: auto; padding: 0.3rem 0.6rem; font-size: 0.8rem;">‚Üª</button>
            </div>
        </div>
    </header>

    <div class="container">

        <!-- Tabs -->
        <div class="tabs">
            <button class="tab-btn active" onclick="showTab('status')">üìä √úbersicht</button>
            <button class="tab-btn" onclick="showTab('detection')">&#128269; Pattern-Erkennung</button>
            <button class="tab-btn" onclick="showTab('training')">&#9881; Training</button>
        </div>

        <!-- Status Tab -->
        <div id="tab-status" class="tab-content active">
            <!-- Pattern Overview Card -->
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">üìà Erkennbare Chart-Patterns (16 Typen)</h3>
                </div>

                <!-- Pattern Stats Bar -->
                <div class="pattern-stats-bar">
                    <div class="pattern-stat">
                        <div class="pattern-stat-value bullish">8</div>
                        <div class="pattern-stat-label">Bullish</div>
                    </div>
                    <div class="pattern-stat">
                        <div class="pattern-stat-value bearish">6</div>
                        <div class="pattern-stat-label">Bearish</div>
                    </div>
                    <div class="pattern-stat">
                        <div class="pattern-stat-value neutral">2</div>
                        <div class="pattern-stat-label">Neutral</div>
                    </div>
                    <div class="pattern-stat">
                        <div class="pattern-stat-value" style="color: #64c8ff;">16</div>
                        <div class="pattern-stat-label">Gesamt</div>
                    </div>
                </div>

                <!-- Pattern Filter Buttons -->
                <div class="pattern-filters">
                    <button class="pattern-filter-btn active" data-filter="all">Alle Patterns (16)</button>
                    <button class="pattern-filter-btn bullish" data-filter="bullish">‚Üë Bullish (8)</button>
                    <button class="pattern-filter-btn bearish" data-filter="bearish">‚Üì Bearish (6)</button>
                    <button class="pattern-filter-btn neutral" data-filter="neutral">‚óÜ Neutral (2)</button>
                </div>

                <!-- Pattern Grid -->
                <div class="pattern-overview-grid">
                    <!-- Head & Shoulders -->
                    <div class="pattern-overview-card" data-direction="bearish">
                        <div class="pattern-overview-header">
                            <span class="pattern-overview-title">Head & Shoulders</span>
                            <span class="pattern-overview-badge bearish">Bearish</span>
                        </div>
                        <div class="pattern-overview-svg">
                            <svg viewBox="0 0 200 70" fill="none">
                                <path d="M10 50 L30 35 L40 50 L60 15 L80 50 L90 35 L110 50" stroke="#64c8ff" stroke-width="2" fill="none"/>
                                <line x1="10" y1="50" x2="110" y2="50" stroke="#ffc107" stroke-width="1" stroke-dasharray="4"/>
                                <path d="M110 50 L140 60 L160 65" stroke="#ef5350" stroke-width="2" fill="none"/>
                            </svg>
                        </div>
                        <div class="pattern-overview-signal">Signal: Short ‚Ä¢ Ziel: Kopfh√∂he</div>
                    </div>

                    <!-- Inverse Head & Shoulders -->
                    <div class="pattern-overview-card" data-direction="bullish">
                        <div class="pattern-overview-header">
                            <span class="pattern-overview-title">Inv. Head & Shoulders</span>
                            <span class="pattern-overview-badge bullish">Bullish</span>
                        </div>
                        <div class="pattern-overview-svg">
                            <svg viewBox="0 0 200 70" fill="none">
                                <path d="M10 20 L30 35 L40 20 L60 55 L80 20 L90 35 L110 20" stroke="#64c8ff" stroke-width="2" fill="none"/>
                                <line x1="10" y1="20" x2="110" y2="20" stroke="#ffc107" stroke-width="1" stroke-dasharray="4"/>
                                <path d="M110 20 L140 10 L160 5" stroke="#81c784" stroke-width="2" fill="none"/>
                            </svg>
                        </div>
                        <div class="pattern-overview-signal">Signal: Long ‚Ä¢ Ziel: Kopftiefe</div>
                    </div>

                    <!-- Double Top -->
                    <div class="pattern-overview-card" data-direction="bearish">
                        <div class="pattern-overview-header">
                            <span class="pattern-overview-title">Double Top</span>
                            <span class="pattern-overview-badge bearish">Bearish</span>
                        </div>
                        <div class="pattern-overview-svg">
                            <svg viewBox="0 0 200 70" fill="none">
                                <path d="M10 50 L40 15 L70 40 L100 15 L130 40" stroke="#64c8ff" stroke-width="2" fill="none"/>
                                <line x1="40" y1="15" x2="100" y2="15" stroke="#ef5350" stroke-width="1" stroke-dasharray="3"/>
                                <path d="M130 40 L155 55 L175 60" stroke="#ef5350" stroke-width="2" fill="none"/>
                            </svg>
                        </div>
                        <div class="pattern-overview-signal">Signal: Short ‚Ä¢ Typ: Reversal</div>
                    </div>

                    <!-- Double Bottom -->
                    <div class="pattern-overview-card" data-direction="bullish">
                        <div class="pattern-overview-header">
                            <span class="pattern-overview-title">Double Bottom</span>
                            <span class="pattern-overview-badge bullish">Bullish</span>
                        </div>
                        <div class="pattern-overview-svg">
                            <svg viewBox="0 0 200 70" fill="none">
                                <path d="M10 20 L40 55 L70 30 L100 55 L130 30" stroke="#64c8ff" stroke-width="2" fill="none"/>
                                <line x1="40" y1="55" x2="100" y2="55" stroke="#81c784" stroke-width="1" stroke-dasharray="3"/>
                                <path d="M130 30 L155 15 L175 10" stroke="#81c784" stroke-width="2" fill="none"/>
                            </svg>
                        </div>
                        <div class="pattern-overview-signal">Signal: Long ‚Ä¢ Typ: Reversal</div>
                    </div>

                    <!-- Triple Top -->
                    <div class="pattern-overview-card" data-direction="bearish">
                        <div class="pattern-overview-header">
                            <span class="pattern-overview-title">Triple Top</span>
                            <span class="pattern-overview-badge bearish">Bearish</span>
                        </div>
                        <div class="pattern-overview-svg">
                            <svg viewBox="0 0 200 70" fill="none">
                                <path d="M10 50 L30 15 L45 40 L65 15 L80 40 L100 15 L120 40" stroke="#64c8ff" stroke-width="2" fill="none"/>
                                <line x1="30" y1="15" x2="100" y2="15" stroke="#ef5350" stroke-width="1" stroke-dasharray="3"/>
                                <path d="M120 40 L150 55 L170 60" stroke="#ef5350" stroke-width="2" fill="none"/>
                            </svg>
                        </div>
                        <div class="pattern-overview-signal">Signal: Short ‚Ä¢ St√§rke: Hoch</div>
                    </div>

                    <!-- Triple Bottom -->
                    <div class="pattern-overview-card" data-direction="bullish">
                        <div class="pattern-overview-header">
                            <span class="pattern-overview-title">Triple Bottom</span>
                            <span class="pattern-overview-badge bullish">Bullish</span>
                        </div>
                        <div class="pattern-overview-svg">
                            <svg viewBox="0 0 200 70" fill="none">
                                <path d="M10 20 L30 55 L45 30 L65 55 L80 30 L100 55 L120 30" stroke="#64c8ff" stroke-width="2" fill="none"/>
                                <line x1="30" y1="55" x2="100" y2="55" stroke="#81c784" stroke-width="1" stroke-dasharray="3"/>
                                <path d="M120 30 L150 15 L170 10" stroke="#81c784" stroke-width="2" fill="none"/>
                            </svg>
                        </div>
                        <div class="pattern-overview-signal">Signal: Long ‚Ä¢ St√§rke: Hoch</div>
                    </div>

                    <!-- Ascending Triangle -->
                    <div class="pattern-overview-card" data-direction="bullish">
                        <div class="pattern-overview-header">
                            <span class="pattern-overview-title">Ascending Triangle</span>
                            <span class="pattern-overview-badge bullish">Bullish</span>
                        </div>
                        <div class="pattern-overview-svg">
                            <svg viewBox="0 0 200 70" fill="none">
                                <path d="M10 55 L30 20 L45 50 L65 20 L80 45 L100 20 L115 40" stroke="#64c8ff" stroke-width="2" fill="none"/>
                                <line x1="30" y1="20" x2="115" y2="20" stroke="#ffc107" stroke-width="1.5"/>
                                <line x1="10" y1="55" x2="115" y2="40" stroke="#81c784" stroke-width="1.5"/>
                                <path d="M115 20 L145 10 L165 5" stroke="#81c784" stroke-width="2" fill="none"/>
                            </svg>
                        </div>
                        <div class="pattern-overview-signal">Signal: Long ‚Ä¢ Typ: Continuation</div>
                    </div>

                    <!-- Descending Triangle -->
                    <div class="pattern-overview-card" data-direction="bearish">
                        <div class="pattern-overview-header">
                            <span class="pattern-overview-title">Descending Triangle</span>
                            <span class="pattern-overview-badge bearish">Bearish</span>
                        </div>
                        <div class="pattern-overview-svg">
                            <svg viewBox="0 0 200 70" fill="none">
                                <path d="M10 15 L30 50 L45 20 L65 50 L80 25 L100 50 L115 30" stroke="#64c8ff" stroke-width="2" fill="none"/>
                                <line x1="30" y1="50" x2="115" y2="50" stroke="#ffc107" stroke-width="1.5"/>
                                <line x1="10" y1="15" x2="115" y2="30" stroke="#ef5350" stroke-width="1.5"/>
                                <path d="M115 50 L145 60 L165 65" stroke="#ef5350" stroke-width="2" fill="none"/>
                            </svg>
                        </div>
                        <div class="pattern-overview-signal">Signal: Short ‚Ä¢ Typ: Continuation</div>
                    </div>

                    <!-- Symmetrical Triangle -->
                    <div class="pattern-overview-card" data-direction="neutral">
                        <div class="pattern-overview-header">
                            <span class="pattern-overview-title">Symmetrical Triangle</span>
                            <span class="pattern-overview-badge neutral">Neutral</span>
                        </div>
                        <div class="pattern-overview-svg">
                            <svg viewBox="0 0 200 70" fill="none">
                                <path d="M10 35 L25 15 L40 50 L60 22 L75 45 L95 30 L110 40" stroke="#64c8ff" stroke-width="2" fill="none"/>
                                <line x1="25" y1="15" x2="110" y2="35" stroke="#a78bfa" stroke-width="1.5"/>
                                <line x1="40" y1="50" x2="110" y2="40" stroke="#a78bfa" stroke-width="1.5"/>
                                <path d="M110 35 L135 20 L155 15" stroke="#81c784" stroke-width="2" stroke-dasharray="4" fill="none"/>
                                <path d="M110 40 L135 55 L155 60" stroke="#ef5350" stroke-width="2" stroke-dasharray="4" fill="none"/>
                            </svg>
                        </div>
                        <div class="pattern-overview-signal">Signal: Breakout ‚Ä¢ Typ: Continuation</div>
                    </div>

                    <!-- Rising Wedge -->
                    <div class="pattern-overview-card" data-direction="bearish">
                        <div class="pattern-overview-header">
                            <span class="pattern-overview-title">Rising Wedge</span>
                            <span class="pattern-overview-badge bearish">Bearish</span>
                        </div>
                        <div class="pattern-overview-svg">
                            <svg viewBox="0 0 200 70" fill="none">
                                <path d="M10 60 L30 45 L45 55 L65 35 L80 45 L100 25 L115 35" stroke="#64c8ff" stroke-width="2" fill="none"/>
                                <line x1="10" y1="60" x2="115" y2="35" stroke="#81c784" stroke-width="1.5"/>
                                <line x1="30" y1="45" x2="115" y2="20" stroke="#ef5350" stroke-width="1.5"/>
                                <path d="M115 35 L145 50 L165 60" stroke="#ef5350" stroke-width="2" fill="none"/>
                            </svg>
                        </div>
                        <div class="pattern-overview-signal">Signal: Short ‚Ä¢ Typ: Reversal</div>
                    </div>

                    <!-- Falling Wedge -->
                    <div class="pattern-overview-card" data-direction="bullish">
                        <div class="pattern-overview-header">
                            <span class="pattern-overview-title">Falling Wedge</span>
                            <span class="pattern-overview-badge bullish">Bullish</span>
                        </div>
                        <div class="pattern-overview-svg">
                            <svg viewBox="0 0 200 70" fill="none">
                                <path d="M10 10 L30 25 L45 15 L65 35 L80 25 L100 45 L115 35" stroke="#64c8ff" stroke-width="2" fill="none"/>
                                <line x1="10" y1="10" x2="115" y2="35" stroke="#ef5350" stroke-width="1.5"/>
                                <line x1="30" y1="25" x2="115" y2="50" stroke="#81c784" stroke-width="1.5"/>
                                <path d="M115 35 L145 20 L165 10" stroke="#81c784" stroke-width="2" fill="none"/>
                            </svg>
                        </div>
                        <div class="pattern-overview-signal">Signal: Long ‚Ä¢ Typ: Reversal</div>
                    </div>

                    <!-- Bull Flag -->
                    <div class="pattern-overview-card" data-direction="bullish">
                        <div class="pattern-overview-header">
                            <span class="pattern-overview-title">Bull Flag</span>
                            <span class="pattern-overview-badge bullish">Bullish</span>
                        </div>
                        <div class="pattern-overview-svg">
                            <svg viewBox="0 0 200 70" fill="none">
                                <path d="M10 60 L40 20" stroke="#81c784" stroke-width="3" fill="none"/>
                                <path d="M40 20 L55 28 L70 24 L85 32 L100 28 L110 35" stroke="#64c8ff" stroke-width="2" fill="none"/>
                                <path d="M110 30 L145 10 L170 5" stroke="#81c784" stroke-width="2" fill="none"/>
                            </svg>
                        </div>
                        <div class="pattern-overview-signal">Signal: Long ‚Ä¢ Ziel: Flagpole</div>
                    </div>

                    <!-- Bear Flag -->
                    <div class="pattern-overview-card" data-direction="bearish">
                        <div class="pattern-overview-header">
                            <span class="pattern-overview-title">Bear Flag</span>
                            <span class="pattern-overview-badge bearish">Bearish</span>
                        </div>
                        <div class="pattern-overview-svg">
                            <svg viewBox="0 0 200 70" fill="none">
                                <path d="M10 10 L40 50" stroke="#ef5350" stroke-width="3" fill="none"/>
                                <path d="M40 50 L55 42 L70 46 L85 38 L100 42 L110 35" stroke="#64c8ff" stroke-width="2" fill="none"/>
                                <path d="M110 40 L145 60 L170 65" stroke="#ef5350" stroke-width="2" fill="none"/>
                            </svg>
                        </div>
                        <div class="pattern-overview-signal">Signal: Short ‚Ä¢ Ziel: Flagpole</div>
                    </div>

                    <!-- Cup & Handle -->
                    <div class="pattern-overview-card" data-direction="bullish">
                        <div class="pattern-overview-header">
                            <span class="pattern-overview-title">Cup & Handle</span>
                            <span class="pattern-overview-badge bullish">Bullish</span>
                        </div>
                        <div class="pattern-overview-svg">
                            <svg viewBox="0 0 200 70" fill="none">
                                <path d="M10 18 Q 20 18, 30 28 Q 55 60, 90 60 Q 125 60, 140 28 Q 150 18, 160 18" stroke="#64c8ff" stroke-width="2" fill="none"/>
                                <path d="M160 18 L167 25 L174 22 L181 27 L188 23" stroke="#64c8ff" stroke-width="2" fill="none"/>
                                <line x1="10" y1="18" x2="188" y2="18" stroke="#ffc107" stroke-width="1" stroke-dasharray="4"/>
                            </svg>
                        </div>
                        <div class="pattern-overview-signal">Signal: Long ‚Ä¢ Ziel: Cup-Tiefe</div>
                    </div>

                    <!-- Channel Up -->
                    <div class="pattern-overview-card" data-direction="bullish">
                        <div class="pattern-overview-header">
                            <span class="pattern-overview-title">Channel Up</span>
                            <span class="pattern-overview-badge bullish">Bullish</span>
                        </div>
                        <div class="pattern-overview-svg">
                            <svg viewBox="0 0 200 70" fill="none">
                                <path d="M10 55 L50 35 L90 45 L130 25 L170 35" stroke="#64c8ff" stroke-width="2" fill="none"/>
                                <line x1="10" y1="55" x2="170" y2="15" stroke="#81c784" stroke-width="1" stroke-dasharray="4"/>
                                <line x1="50" y1="55" x2="170" y2="35" stroke="#81c784" stroke-width="1" stroke-dasharray="4"/>
                            </svg>
                        </div>
                        <div class="pattern-overview-signal">Signal: Long ‚Ä¢ Typ: Trend</div>
                    </div>

                    <!-- Channel Down -->
                    <div class="pattern-overview-card" data-direction="bearish">
                        <div class="pattern-overview-header">
                            <span class="pattern-overview-title">Channel Down</span>
                            <span class="pattern-overview-badge bearish">Bearish</span>
                        </div>
                        <div class="pattern-overview-svg">
                            <svg viewBox="0 0 200 70" fill="none">
                                <path d="M10 15 L50 35 L90 25 L130 45 L170 35" stroke="#64c8ff" stroke-width="2" fill="none"/>
                                <line x1="10" y1="15" x2="170" y2="55" stroke="#ef5350" stroke-width="1" stroke-dasharray="4"/>
                                <line x1="50" y1="15" x2="170" y2="35" stroke="#ef5350" stroke-width="1" stroke-dasharray="4"/>
                            </svg>
                        </div>
                        <div class="pattern-overview-signal">Signal: Short ‚Ä¢ Typ: Trend</div>
                    </div>
                </div>
            </div>

        </div>

        <!-- Detection Tab -->
        <div id="tab-detection" class="tab-content">
            <!-- Compact Control Bar: Auto-Erkennung + Manuelle Erkennung + Multi-Scan -->
            <div class="card" style="padding: 1rem;">
                <div style="display: flex; gap: 1.5rem; align-items: flex-start; flex-wrap: wrap;">
                    <!-- Auto-Erkennung -->
                    <div style="flex: 1; min-width: 280px;">
                        <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.5rem;">
                            <span style="color: #64c8ff; font-weight: 500;">&#128336; Auto-Erkennung</span>
                            <button class="btn btn-success btn-sm" id="btn-start-autoscan" onclick="toggleAutoScan(true)" style="padding: 0.3rem 0.6rem;">&#9654; Start</button>
                            <button class="btn btn-danger btn-sm" id="btn-stop-autoscan" onclick="toggleAutoScan(false)" disabled style="padding: 0.3rem 0.6rem;">&#9632; Stop</button>
                        </div>
                        <div style="display: flex; gap: 1rem; font-size: 0.85rem; color: #aaa;">
                            <span>Status: <strong id="autoscan-status-indicator" style="color: #fff;">-</strong></span>
                            <span>Patterns: <strong id="autoscan-total" style="color: #64c8ff;">-</strong></span>
                            <span>Symbole: <strong id="autoscan-symbols" style="color: #a78bfa;">-</strong></span>
                            <span>Letzter: <strong id="autoscan-lastscan" style="color: #fff;">-</strong></span>
                        </div>
                    </div>

                    <!-- Manuelle Erkennung -->
                    <div style="flex: 1; min-width: 320px; border-left: 1px solid rgba(255,255,255,0.1); padding-left: 1.5rem;">
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                            <span style="color: #64c8ff; font-weight: 500;">&#128269; Manuelle Erkennung</span>
                        </div>
                        <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                            <select class="form-control" id="detect-symbol" style="width: 120px; padding: 0.4rem;">
                                <option value="">Symbol...</option>
                            </select>
                            <select class="form-control" id="detect-timeframe" style="width: 70px; padding: 0.4rem;">
                                <option value="5m">M5</option>
                                <option value="15m">M15</option>
                                <option value="30m">M30</option>
                                <option value="1h" selected>H1</option>
                                <option value="4h">H4</option>
                                <option value="1d">D1</option>
                            </select>
                            <input type="number" class="form-control" id="detect-confidence" value="0.5" min="0" max="1" step="0.05" style="width: 70px; padding: 0.4rem;" title="Min. Confidence">
                            <button class="btn btn-success btn-sm" id="btn-detect" onclick="detectPattern()" style="padding: 0.4rem 0.8rem;">&#128269; Erkennen</button>
                        </div>
                    </div>

                    <!-- Multi-Symbol Scan -->
                    <div style="flex: 0 0 auto; border-left: 1px solid rgba(255,255,255,0.1); padding-left: 1.5rem;">
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                            <span style="color: #64c8ff; font-weight: 500;">&#128640; Multi-Scan</span>
                        </div>
                        <button class="btn btn-primary btn-sm" id="btn-scan-all" onclick="scanAllAndSave()" style="padding: 0.4rem 0.8rem;">&#128640; Alle scannen</button>
                        <button class="btn btn-danger btn-sm" id="btn-cancel-scan" onclick="cancelScan()" style="padding: 0.4rem 0.8rem; display: none;">&#9632; Abbrechen</button>
                    </div>
                </div>
                <!-- Scan Progress -->
                <div id="scan-progress" style="margin-top: 0.75rem; display: none;">
                    <div style="background: rgba(100,200,255,0.1); border: 1px solid rgba(100,200,255,0.3); border-radius: 8px; padding: 0.75rem;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                            <span style="color: #64c8ff; font-weight: 500; display: flex; align-items: center; gap: 0.5rem;">
                                <span class="spinner" style="width: 14px; height: 14px; border-width: 2px;"></span>
                                <span id="scan-progress-text">Scanne...</span>
                            </span>
                            <span id="scan-progress-percent" style="color: #64c8ff; font-weight: 600;">0%</span>
                        </div>
                        <div class="progress-bar" style="height: 6px; margin-bottom: 0.5rem;">
                            <div id="scan-progress-bar" class="progress-fill" style="width: 0%;"></div>
                        </div>
                        <div style="display: flex; gap: 1rem; font-size: 0.8rem; color: #aaa;">
                            <span>Symbol: <strong id="scan-current-symbol" style="color: #fff;">-</strong></span>
                            <span>Timeframe: <strong id="scan-current-tf" style="color: #fff;">-</strong></span>
                            <span>Gefunden: <strong id="scan-patterns-found" style="color: #81c784;">0</strong></span>
                        </div>
                    </div>
                </div>
                <div id="scan-results"></div>
            </div>

            <!-- Pattern History Table (moved from Verlauf tab) -->
            <div class="card">
                <div class="card-header" style="flex-direction: column; align-items: stretch; gap: 0.5rem;">
                    <!-- Titel -->
                    <h3 class="card-title" style="margin: 0;">&#128203; Erkannte Patterns</h3>
                    <!-- Filter Row mit Buttons (Reihenfolge wie Tabellenspalten: Symbol, Pattern, Richtung, Konfidenz, Timeframe) -->
                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center;">
                        <select class="form-control" id="history-symbol-filter" style="width: auto;">
                            <option value="">Alle Symbole</option>
                        </select>
                        <select class="form-control" id="history-pattern-filter" style="width: auto;">
                            <option value="">Alle Patterns</option>
                            <option value="head_and_shoulders">Head &amp; Shoulders</option>
                            <option value="inverse_head_and_shoulders">Inv. Head &amp; Shoulders</option>
                            <option value="double_top">Double Top</option>
                            <option value="double_bottom">Double Bottom</option>
                            <option value="triple_top">Triple Top</option>
                            <option value="triple_bottom">Triple Bottom</option>
                            <option value="ascending_triangle">Ascending Triangle</option>
                            <option value="descending_triangle">Descending Triangle</option>
                            <option value="symmetrical_triangle">Symmetrical Triangle</option>
                            <option value="rising_wedge">Rising Wedge</option>
                            <option value="falling_wedge">Falling Wedge</option>
                            <option value="bull_flag">Bull Flag</option>
                            <option value="bear_flag">Bear Flag</option>
                            <option value="channel_up">Channel Up</option>
                            <option value="channel_down">Channel Down</option>
                            <option value="cup_and_handle">Cup &amp; Handle</option>
                        </select>
                        <select class="form-control" id="history-direction-filter" style="width: auto;">
                            <option value="">Alle Richtungen</option>
                            <option value="bullish">Bullish</option>
                            <option value="bearish">Bearish</option>
                            <option value="neutral">Neutral</option>
                        </select>
                        <select class="form-control" id="history-confidence-filter" style="width: auto;">
                            <option value="">Alle Konfidenzen</option>
                            <option value="0.8">‚â• 80%</option>
                            <option value="0.7">‚â• 70%</option>
                            <option value="0.6">‚â• 60%</option>
                            <option value="0.5">‚â• 50%</option>
                        </select>
                        <select class="form-control" id="history-timeframe-filter" style="width: auto;">
                            <option value="">Alle Timeframes</option>
                            <option value="5m">M5</option>
                            <option value="15m">M15</option>
                            <option value="30m">M30</option>
                            <option value="1h">H1</option>
                            <option value="4h">H4</option>
                            <option value="1d">D1</option>
                        </select>
                        <select class="form-control" id="history-category-filter" style="width: auto;">
                            <option value="">Alle Kategorien</option>
                            <option value="reversal">Reversal</option>
                            <option value="continuation">Continuation</option>
                            <option value="trend">Trend</option>
                        </select>
                        <div style="margin-left: auto; display: flex; gap: 0.25rem;">
                            <button class="btn btn-secondary btn-sm" id="btn-reset-filters" onclick="resetPatternFilters()" style="display: none;" title="Filter zur√ºcksetzen">
                                &#10005; Filter
                            </button>
                            <button class="btn btn-primary btn-sm" onclick="loadPatternHistory()">&#8635; Aktualisieren</button>
                        </div>
                    </div>
                </div>
                <div id="pattern-history-table" style="overflow-x: auto;">
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Symbol</th>
                                <th>Pattern</th>
                                <th>Richtung</th>
                                <th>Konfidenz</th>
                                <th>Timeframe</th>
                                <th>Zeitraum</th>
                                <th>Preis</th>
                                <th style="text-align: center;">Chart</th>
                            </tr>
                        </thead>
                        <tbody id="pattern-history-body">
                            <tr><td colspan="8" style="text-align: center; padding: 2rem; color: #888;">Lade Pattern-Historie...</td></tr>
                        </tbody>
                    </table>
                </div>
                <div style="margin-top: 1rem; display: flex; justify-content: space-between; align-items: center;">
                    <span id="history-count" style="color: #888; font-size: 0.85rem;"></span>
                </div>
            </div>

            <!-- Statistics -->
            <div class="grid-3">
                <div class="card">
                    <div class="card-header">
                        <h3 class="card-title">Nach Pattern-Typ</h3>
                    </div>
                    <div id="stats-by-type" style="font-size: 0.85rem;">Lade...</div>
                </div>
                <div class="card">
                    <div class="card-header">
                        <h3 class="card-title">Nach Kategorie</h3>
                    </div>
                    <div id="stats-by-category" style="font-size: 0.85rem;">Lade...</div>
                </div>
                <div class="card">
                    <div class="card-header">
                        <h3 class="card-title">Nach Timeframe</h3>
                    </div>
                    <div id="stats-by-timeframe" style="font-size: 0.85rem;">Lade...</div>
                </div>
            </div>
        </div>

        <!-- Training Tab -->
        <div id="tab-training" class="tab-content">
            <!-- Combined Training Card -->
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">&#128295; Training</h3>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <span id="auto-training-badge" style="display: none; background: #4caf50; color: #000; padding: 0.2rem 0.6rem; border-radius: 4px; font-size: 0.75rem; font-weight: 600;">AUTO</span>
                        <button class="btn btn-secondary btn-sm" onclick="loadTrainingStatus(); loadAutoTrainingStatus();">Aktualisieren</button>
                    </div>
                </div>

                <!-- Training Progress (nur sichtbar wenn Training l√§uft) -->
                <div id="training-progress-section" style="display: none;">
                    <div id="training-status"></div>
                </div>

                <!-- Training Configuration Grid -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem;">
                    <!-- Left: Manual Training -->
                    <div>
                        <h4 style="color: #888; font-size: 0.9rem; margin: 0 0 1rem 0; padding-bottom: 0.5rem; border-bottom: 1px solid #333;">Manuelles Training</h4>
                        <div class="form-group">
                            <label>Symbole <span id="symbols-count" style="color: #888; font-weight: normal;"></span></label>
                            <select class="form-control" id="train-symbols" multiple style="height: 120px;">
                                <option disabled>Lade Symbole...</option>
                            </select>
                            <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
                                <button type="button" class="btn btn-secondary" onclick="selectAllSymbols()" style="flex: 1; padding: 0.3rem; font-size: 0.8rem;">Alle</button>
                                <button type="button" class="btn btn-secondary" onclick="selectNoSymbols()" style="flex: 1; padding: 0.3rem; font-size: 0.8rem;">Keine</button>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                            <div class="form-group">
                                <label>Timeframe</label>
                                <select class="form-control" id="train-timeframe">
                                    <option value="5m">M5</option>
                                    <option value="15m">M15</option>
                                    <option value="30m">M30</option>
                                    <option value="1h" selected>H1</option>
                                    <option value="4h">H4</option>
                                    <option value="1d">D1</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>Lookback (Tage)</label>
                                <input type="number" class="form-control" id="train-lookback" value="365" min="30" max="1000">
                            </div>
                            <div class="form-group">
                                <label>Epochen</label>
                                <input type="number" class="form-control" id="train-epochs" value="100" min="10" max="1000">
                            </div>
                            <div class="form-group">
                                <label>Batch Size</label>
                                <input type="number" class="form-control" id="train-batch" value="32" min="8" max="128">
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Learning Rate</label>
                            <input type="number" class="form-control" id="train-lr" value="0.0001" min="0.00001" max="0.01" step="0.0001">
                        </div>
                        <div style="display: flex; gap: 0.5rem;">
                            <button class="btn btn-success" id="btn-train" onclick="startTraining()">&#9654; Training starten</button>
                            <button class="btn btn-danger" id="btn-stop-train" onclick="stopTraining()" disabled>&#9632; Stoppen</button>
                        </div>
                    </div>

                    <!-- Right: Auto-Training -->
                    <div>
                        <h4 style="color: #888; font-size: 0.9rem; margin: 0 0 1rem 0; padding-bottom: 0.5rem; border-bottom: 1px solid #333;">Auto-Training</h4>
                        <div id="auto-training-status" style="margin-bottom: 1rem;">
                            <div class="loading"><div class="spinner"></div></div>
                        </div>
                        <div class="form-group">
                            <label>Intervall</label>
                            <select class="form-control" id="auto-interval">
                                <option value="daily">T√§glich</option>
                                <option value="weekly" selected>W√∂chentlich</option>
                                <option value="monthly">Monatlich</option>
                                <option value="manual">Manuell</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Startzeit</label>
                            <div style="display: flex; gap: 0.5rem; align-items: center;">
                                <input type="number" class="form-control" id="auto-scheduled-hour" value="2" min="0" max="23" style="width: 60px; text-align: center;">
                                <span style="color: #888;">:</span>
                                <input type="number" class="form-control" id="auto-scheduled-minute" value="0" min="0" max="59" style="width: 60px; text-align: center;">
                                <span style="color: #888; font-size: 0.85rem;">Uhr</span>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Timeframes</label>
                            <div style="display: flex; gap: 0.75rem; flex-wrap: wrap; padding-top: 0.5rem;">
                                <label style="display: flex; align-items: center; gap: 0.3rem; cursor: pointer; font-size: 0.9rem;">
                                    <input type="checkbox" id="auto-tf-5m"> M5
                                </label>
                                <label style="display: flex; align-items: center; gap: 0.3rem; cursor: pointer; font-size: 0.9rem;">
                                    <input type="checkbox" id="auto-tf-15m"> M15
                                </label>
                                <label style="display: flex; align-items: center; gap: 0.3rem; cursor: pointer; font-size: 0.9rem;">
                                    <input type="checkbox" id="auto-tf-30m"> M30
                                </label>
                                <label style="display: flex; align-items: center; gap: 0.3rem; cursor: pointer; font-size: 0.9rem;">
                                    <input type="checkbox" id="auto-tf-1h" checked> H1
                                </label>
                                <label style="display: flex; align-items: center; gap: 0.3rem; cursor: pointer; font-size: 0.9rem;">
                                    <input type="checkbox" id="auto-tf-4h" checked> H4
                                </label>
                                <label style="display: flex; align-items: center; gap: 0.3rem; cursor: pointer; font-size: 0.9rem;">
                                    <input type="checkbox" id="auto-tf-1d" checked> D1
                                </label>
                            </div>
                        </div>
                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            <button class="btn btn-success btn-sm" id="btn-enable-auto" onclick="toggleAutoTraining(true)">
                                &#9654; Aktivieren
                            </button>
                            <button class="btn btn-danger btn-sm" id="btn-disable-auto" onclick="toggleAutoTraining(false)" disabled>
                                &#9632; Deaktivieren
                            </button>
                            <button class="btn btn-primary btn-sm" id="btn-run-now" onclick="runAutoTrainingNow()">
                                &#9889; Jetzt starten
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Available Models -->
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">&#128230; Verfugbare Modelle</h3>
                    <button class="btn btn-secondary btn-sm" onclick="loadModels()">&#8635; Aktualisieren</button>
                </div>
                <div id="models-list">
                    <div class="loading"><div class="spinner"></div></div>
                </div>
            </div>

            <!-- Training History -->
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">&#128203; Training-Verlauf</h3>
                </div>
                <div id="training-history">
                    <div class="loading"><div class="spinner"></div></div>
                </div>
            </div>
        </div>

        <!-- History Tab -->
        <div id="tab-history" class="tab-content">
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">&#128203; Erkennungs-Verlauf</h3>
                    <div>
                        <select class="form-control" id="history-symbol" style="width: auto; display: inline-block;">
                            <option value="BTCUSD">BTCUSD</option>
                            <option value="ETHUSD">ETHUSD</option>
                            <option value="EURUSD">EURUSD</option>
                            <option value="XAUUSD">XAUUSD</option>
                        </select>
                        <button class="btn btn-primary btn-sm" onclick="loadHistory()">&#8635; Laden</button>
                    </div>
                </div>
                <div id="pattern-history">
                    <div class="info-box">W√§hlen Sie ein Symbol und klicken Sie auf "Laden".</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Inference endpoints remain on /tcn, training moved to /tcn-train
        const API_BASE = '/tcn/api/v1';
        const TRAIN_API_BASE = '/tcn-train/api/v1';
        let trainingInterval = null;

        // =============================================================================
        // Pattern Detail Data (basierend auf docs/tcn_patterns/)
        // =============================================================================
        let currentPatternDetailKey = null;

        const patternDetailData = {
            head_and_shoulders: {
                name: "Head & Shoulders",
                direction: "bearish",
                category: "reversal",
                shortDescription: "Das Head & Shoulders Pattern besteht aus drei aufeinanderfolgenden Gipfeln, wobei der mittlere Gipfel (Kopf) h√∂her ist als die beiden √§u√üeren Gipfel (Schultern). Die Formation wird durch eine Trendlinie verbunden, die die Tiefpunkte zwischen den Gipfeln markiert.",
                components: [
                    { number: "1", name: "Erste Schulter", desc: "Lokales Maximum nach starkem Anstieg" },
                    { number: "2", name: "Kopf (Head)", desc: "H√∂chster Punkt, √ºberwindet Schulter 1" },
                    { number: "3", name: "Zweite Schulter", desc: "Drittes Hoch, niedriger als Kopf" }
                ],
                neckline: "Die Neckline verbindet die beiden Tiefpunkte zwischen den Schultern und dem Kopf. Sie dient als kritische Unterst√ºtzungslinie.",
                meaning: [
                    "Eines der zuverl√§ssigsten Umkehrmuster in der technischen Analyse",
                    "Signalisiert starken √úbergang von Kaufdruck zu Verkaufsdruck",
                    "Sinkende Hochpunkte deuten auf Abschw√§chen des Aufw√§rtstrends hin"
                ],
                entry: "Bruch unter die Neckline (Best√§tigung des Musters)",
                target: "Kopfh√∂he von Neckline subtrahiert",
                stopLoss: "Oberhalb des Kopfmaximums",
                invalidation: "Kurs kehrt schnell √ºber die Neckline zur√ºck",
                patternType: "Bearische Umkehr",
                reliability: "‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê",
                reliabilityText: "Sehr Hoch",
                strength: "Sehr stark",
                context: "Nach Aufw√§rtstrend",
                relatedPatterns: [
                    { key: "inverse_head_and_shoulders", name: "Inverse H&S", relation: "Gegenst√ºck" },
                    { key: "double_top", name: "Double Top", relation: "√Ñhnlich" },
                    { key: "triple_top", name: "Triple Top", relation: "St√§rker" }
                ]
            },
            inverse_head_and_shoulders: {
                name: "Inverse Head & Shoulders",
                direction: "bullish",
                category: "reversal",
                shortDescription: "Das Inverse Head & Shoulders Pattern ist das bullische Gegenst√ºck zum klassischen Head & Shoulders. Es besteht aus drei aufeinanderfolgenden Tiefpunkten, wobei der mittlere Tiefpunkt (Kopf) tiefer liegt als die beiden √§u√üeren (Schultern).",
                components: [
                    { number: "1", name: "Erste Schulter", desc: "Lokales Minimum nach Abw√§rtsbewegung" },
                    { number: "2", name: "Kopf (Head)", desc: "Tiefster Punkt des Musters" },
                    { number: "3", name: "Zweite Schulter", desc: "Drittes Tief, h√∂her als Kopf" }
                ],
                neckline: "Die Neckline verbindet die Hochpunkte zwischen den Schultern. Der Bruch dar√ºber aktiviert das Muster.",
                meaning: [
                    "Signalisiert das Ende eines Abw√§rtstrends",
                    "Steigende Tiefpunkte zeigen zunehmende Kaufkraft",
                    "Sehr zuverl√§ssiges bullisches Umkehrsignal"
                ],
                entry: "Bruch √ºber die Neckline mit erh√∂htem Volumen",
                target: "Kopftiefe von Neckline nach oben addiert",
                stopLoss: "Unterhalb des Kopfminimums",
                invalidation: "Kurs f√§llt unter die Neckline zur√ºck",
                patternType: "Bullische Umkehr",
                reliability: "‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê",
                reliabilityText: "Sehr Hoch",
                strength: "Sehr stark",
                context: "Nach Abw√§rtstrend",
                relatedPatterns: [
                    { key: "head_and_shoulders", name: "Head & Shoulders", relation: "Gegenst√ºck" },
                    { key: "double_bottom", name: "Double Bottom", relation: "√Ñhnlich" },
                    { key: "triple_bottom", name: "Triple Bottom", relation: "St√§rker" }
                ]
            },
            double_top: {
                name: "Double Top",
                direction: "bearish",
                category: "reversal",
                shortDescription: "Das Double Top Pattern besteht aus zwei aufeinanderfolgenden Hochpunkten auf nahezu gleichem Niveau mit einem R√ºckgang dazwischen. Die Formation sieht aus wie ein gro√ües \"M\" und signalisiert den Widerstand des Marktes gegen weitere Anstiege.",
                components: [
                    { number: "1", name: "Erste Spitze", desc: "Hochpunkt nach Aufw√§rtsbewegung" },
                    { number: "‚Üì", name: "R√ºckgang", desc: "Pullback zur Neckline" },
                    { number: "2", name: "Zweite Spitze", desc: "Scheitert am ersten Niveau" }
                ],
                neckline: "Die Neckline ist das Unterst√ºtzungsniveau zwischen den beiden Spitzen. Ein Bruch darunter aktiviert das Muster.",
                meaning: [
                    "K√§ufer haben zweimal versucht, den Preis zu treiben, aber sind gescheitert",
                    "Zeigt psychologisches Widerstandsniveau",
                    "Kontrolle geht von K√§ufern zu Verk√§ufern √ºber"
                ],
                entry: "Bruch unter die Neckline",
                target: "Muster-H√∂he von Neckline subtrahiert",
                stopLoss: "Oberhalb der Hochpunkte",
                invalidation: "Kurs bricht √ºber beide Hochpunkte",
                patternType: "Bearische Umkehr",
                reliability: "‚≠ê‚≠ê‚≠ê‚≠ê",
                reliabilityText: "Hoch",
                strength: "Stark",
                context: "Nach Aufw√§rtstrend",
                relatedPatterns: [
                    { key: "double_bottom", name: "Double Bottom", relation: "Gegenst√ºck" },
                    { key: "triple_top", name: "Triple Top", relation: "St√§rker" },
                    { key: "head_and_shoulders", name: "Head & Shoulders", relation: "Verwandt" }
                ]
            },
            double_bottom: {
                name: "Double Bottom",
                direction: "bullish",
                category: "reversal",
                shortDescription: "Das Double Bottom Pattern besteht aus zwei aufeinanderfolgenden Tiefpunkten auf nahezu gleichem Niveau mit einem Anstieg dazwischen. Die Formation sieht aus wie ein \"W\" und signalisiert starke Unterst√ºtzung.",
                components: [
                    { number: "1", name: "Erstes Tief", desc: "Tiefpunkt nach Abw√§rtsbewegung" },
                    { number: "‚Üë", name: "Erholung", desc: "Anstieg zur Neckline" },
                    { number: "2", name: "Zweites Tief", desc: "Test der Unterst√ºtzung" }
                ],
                neckline: "Die Neckline ist das Widerstandsniveau zwischen den beiden Tiefs. Ein Bruch dar√ºber aktiviert das Muster.",
                meaning: [
                    "Verk√§ufer haben zweimal versucht, den Preis zu dr√ºcken, aber sind gescheitert",
                    "Zeigt starkes Unterst√ºtzungsniveau",
                    "Kontrolle geht von Verk√§ufern zu K√§ufern √ºber"
                ],
                entry: "Bruch √ºber die Neckline",
                target: "Muster-H√∂he von Neckline addiert",
                stopLoss: "Unterhalb der Tiefpunkte",
                invalidation: "Kurs bricht unter beide Tiefpunkte",
                patternType: "Bullische Umkehr",
                reliability: "‚≠ê‚≠ê‚≠ê‚≠ê",
                reliabilityText: "Hoch",
                strength: "Stark",
                context: "Nach Abw√§rtstrend",
                relatedPatterns: [
                    { key: "double_top", name: "Double Top", relation: "Gegenst√ºck" },
                    { key: "triple_bottom", name: "Triple Bottom", relation: "St√§rker" },
                    { key: "inverse_head_and_shoulders", name: "Inverse H&S", relation: "Verwandt" }
                ]
            },
            triple_top: {
                name: "Triple Top",
                direction: "bearish",
                category: "reversal",
                shortDescription: "Das Triple Top Pattern besteht aus drei aufeinanderfolgenden Hochpunkten auf nahezu gleichem Niveau. Es ist eine verst√§rkte Version des Double Top und signalisiert einen noch st√§rkeren Widerstand.",
                components: [
                    { number: "1", name: "Erste Spitze", desc: "Erstes Hoch nach Aufw√§rtstrend" },
                    { number: "2", name: "Zweite Spitze", desc: "Zweiter Test des Widerstands" },
                    { number: "3", name: "Dritte Spitze", desc: "Dritter gescheiterter Versuch" }
                ],
                neckline: "Die Neckline verbindet die Tiefpunkte zwischen den drei Spitzen und dient als kritische Unterst√ºtzung.",
                meaning: [
                    "Dreifacher Widerstand ist sehr signifikant",
                    "K√§ufer haben drei Mal versagt - starkes Verkaufssignal",
                    "Seltener als Double Top, aber zuverl√§ssiger"
                ],
                entry: "Bruch unter die Neckline mit Volumenbest√§tigung",
                target: "H√∂he des Musters von Neckline subtrahiert",
                stopLoss: "Oberhalb der Hochpunkte",
                invalidation: "Kurs bricht √ºber die drei Hochpunkte",
                patternType: "Bearische Umkehr",
                reliability: "‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê",
                reliabilityText: "Sehr Hoch (Selten)",
                strength: "Sehr stark",
                context: "Nach l√§ngerem Aufw√§rtstrend",
                relatedPatterns: [
                    { key: "triple_bottom", name: "Triple Bottom", relation: "Gegenst√ºck" },
                    { key: "double_top", name: "Double Top", relation: "Schw√§cher" },
                    { key: "head_and_shoulders", name: "Head & Shoulders", relation: "Verwandt" }
                ]
            },
            triple_bottom: {
                name: "Triple Bottom",
                direction: "bullish",
                category: "reversal",
                shortDescription: "Das Triple Bottom Pattern besteht aus drei aufeinanderfolgenden Tiefpunkten auf nahezu gleichem Niveau. Es ist eine verst√§rkte Version des Double Bottom und signalisiert eine noch st√§rkere Unterst√ºtzung.",
                components: [
                    { number: "1", name: "Erstes Tief", desc: "Erstes Tief nach Abw√§rtstrend" },
                    { number: "2", name: "Zweites Tief", desc: "Zweiter Test der Unterst√ºtzung" },
                    { number: "3", name: "Drittes Tief", desc: "Dritter gescheiterter Durchbruch" }
                ],
                neckline: "Die Neckline verbindet die Hochpunkte zwischen den drei Tiefs und dient als Widerstand.",
                meaning: [
                    "Dreifache Unterst√ºtzung ist sehr signifikant",
                    "Verk√§ufer haben drei Mal versagt - starkes Kaufsignal",
                    "Seltener als Double Bottom, aber zuverl√§ssiger"
                ],
                entry: "Bruch √ºber die Neckline mit Volumenbest√§tigung",
                target: "H√∂he des Musters von Neckline addiert",
                stopLoss: "Unterhalb der Tiefpunkte",
                invalidation: "Kurs bricht unter die drei Tiefpunkte",
                patternType: "Bullische Umkehr",
                reliability: "‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê",
                reliabilityText: "Sehr Hoch (Selten)",
                strength: "Sehr stark",
                context: "Nach l√§ngerem Abw√§rtstrend",
                relatedPatterns: [
                    { key: "triple_top", name: "Triple Top", relation: "Gegenst√ºck" },
                    { key: "double_bottom", name: "Double Bottom", relation: "Schw√§cher" },
                    { key: "inverse_head_and_shoulders", name: "Inverse H&S", relation: "Verwandt" }
                ]
            },
            ascending_triangle: {
                name: "Ascending Triangle",
                direction: "bullish",
                category: "continuation",
                shortDescription: "Das Ascending Triangle ist eine bullische Fortsetzungsformation mit einer horizontalen Widerstands-Linie (Oberseite) und einer steigenden Trendlinie (Unterseite). Der Kurs bewegt sich in einem dreieckigen Bereich, wobei jedes Tief h√∂her ist als das vorherige.",
                components: [
                    { number: "1", name: "Horiz. Widerstand", desc: "Mehrere Hochs auf gleichem Niveau" },
                    { number: "2", name: "Steigende Linie", desc: "H√∂here Tiefpunkte" },
                    { number: "3", name: "Ausbruch", desc: "Bruch √ºber den Widerstand" }
                ],
                neckline: "Die horizontale Widerstandslinie wird durch mehrere Hochpunkte auf nahezu gleichem Niveau gebildet.",
                meaning: [
                    "Zeigt zunehmendes Kaufinteresse (h√∂here Tiefs)",
                    "K√§ufer werden st√§rker, w√§hrend Verk√§ufer gleich bleiben",
                    "Volatilit√§t nimmt ab, Spannung baut sich auf"
                ],
                entry: "Bruch √ºber die Widerstandslinie mit erh√∂htem Volumen",
                target: "H√∂he des Dreiecks vom Ausbruchspunkt nach oben",
                stopLoss: "Unter der steigenden Trendlinie",
                invalidation: "Kurs bricht unter die Trendlinie",
                patternType: "Bullische Fortsetzung",
                reliability: "‚≠ê‚≠ê‚≠ê‚≠ê",
                reliabilityText: "Hoch",
                strength: "Stark",
                context: "Aufw√§rtstrend",
                relatedPatterns: [
                    { key: "descending_triangle", name: "Descending Triangle", relation: "Gegenst√ºck" },
                    { key: "symmetrical_triangle", name: "Symm. Triangle", relation: "Neutral" },
                    { key: "bull_flag", name: "Bull Flag", relation: "Schneller" }
                ]
            },
            descending_triangle: {
                name: "Descending Triangle",
                direction: "bearish",
                category: "continuation",
                shortDescription: "Das Descending Triangle Pattern ist eine b√§rische Fortsetzungsformation mit einer horizontalen Unterst√ºtzungs-Linie (Unterseite) und einer fallenden Trendlinie (Oberseite). Der Kurs bewegt sich in einem dreieckigen Bereich, wobei jeder Anstieg niedriger ist als der vorherige.",
                components: [
                    { number: "1", name: "Horiz. Support", desc: "Mehrere Tiefs auf gleichem Niveau" },
                    { number: "2", name: "Fallende Linie", desc: "Niedrigere Hochpunkte" },
                    { number: "3", name: "Ausbruch", desc: "Bruch unter die Unterst√ºtzung" }
                ],
                neckline: "Die horizontale Unterst√ºtzungslinie wird durch mehrere Tiefpunkte auf nahezu gleichem Niveau gebildet.",
                meaning: [
                    "Zeigt zunehmendes Verkaufsinteresse (niedrigere Hochs)",
                    "Verk√§ufer werden st√§rker, w√§hrend K√§ufer schw√§cher werden",
                    "Der dreieckige Quetsch zeigt abnehmende Volatilit√§t"
                ],
                entry: "Bruch unter die Unterst√ºtzungslinie mit erh√∂htem Volumen",
                target: "H√∂he des Dreiecks vom Ausbruchspunkt nach unten",
                stopLoss: "√úber der fallenden Trendlinie",
                invalidation: "Kurs bricht √ºber die Trendlinie",
                patternType: "B√§rische Fortsetzung",
                reliability: "‚≠ê‚≠ê‚≠ê‚≠ê",
                reliabilityText: "Hoch",
                strength: "Stark",
                context: "Abw√§rtstrend",
                relatedPatterns: [
                    { key: "ascending_triangle", name: "Ascending Triangle", relation: "Gegenst√ºck" },
                    { key: "symmetrical_triangle", name: "Symm. Triangle", relation: "Neutral" },
                    { key: "bear_flag", name: "Bear Flag", relation: "Schneller" }
                ]
            },
            symmetrical_triangle: {
                name: "Symmetrical Triangle",
                direction: "neutral",
                category: "continuation",
                shortDescription: "Das Symmetrical Triangle ist eine neutrale Fortsetzungsformation mit konvergierenden Trendlinien - sowohl fallenden Hochs als auch steigenden Tiefs. Der Ausbruch kann in beide Richtungen erfolgen, typischerweise in Richtung des vorherigen Trends.",
                components: [
                    { number: "1", name: "Fallende Hochs", desc: "Obere Trendlinie f√§llt" },
                    { number: "2", name: "Steigende Tiefs", desc: "Untere Trendlinie steigt" },
                    { number: "3", name: "Apex", desc: "Konvergenzpunkt der Linien" }
                ],
                neckline: "Beide Trendlinien konvergieren zum Apex. Der Ausbruch erfolgt typischerweise vor Erreichen des Apex.",
                meaning: [
                    "Zeigt Unentschlossenheit zwischen K√§ufern und Verk√§ufern",
                    "Volatilit√§t nimmt ab, bis ein Ausbruch erfolgt",
                    "Fortsetzung des vorherigen Trends ist wahrscheinlicher"
                ],
                entry: "Bruch √ºber/unter die Trendlinie mit Volumenbest√§tigung",
                target: "Breitester Teil des Dreiecks vom Ausbruchspunkt",
                stopLoss: "Auf der gegen√ºberliegenden Seite des Dreiecks",
                invalidation: "Falscher Ausbruch mit schneller R√ºckkehr",
                patternType: "Neutrale Fortsetzung",
                reliability: "‚≠ê‚≠ê‚≠ê",
                reliabilityText: "Mittel",
                strength: "Mittel",
                context: "Trend-Konsolidierung",
                relatedPatterns: [
                    { key: "ascending_triangle", name: "Ascending Triangle", relation: "Bullisch" },
                    { key: "descending_triangle", name: "Descending Triangle", relation: "Bearisch" },
                    { key: "rectangle", name: "Rectangle", relation: "√Ñhnlich" }
                ]
            },
            bull_flag: {
                name: "Bull Flag",
                direction: "bullish",
                category: "continuation",
                shortDescription: "Das Bull Flag Pattern ist eine bullische Fortsetzungsformation bestehend aus zwei Teilen: dem \"Flaggenmast\" (starker Anstieg) und der \"Flagge\" (Konsolidierung mit leichtem R√ºckgang). Die Formation signalisiert eine Unterbrechung des Aufw√§rtstrends vor dem Fortgang.",
                components: [
                    { number: "1", name: "Flaggenmast", desc: "Steiler, schneller Anstieg" },
                    { number: "2", name: "Flagge", desc: "Konsolidierung (25-50% R√ºckgang)" },
                    { number: "3", name: "Ausbruch", desc: "Fortsetzung nach oben" }
                ],
                neckline: "Die Flagge wird von zwei parallelen, leicht nach unten geneigten Trendlinien gebildet.",
                meaning: [
                    "Signalisiert Verschnaufpause in starkem Aufw√§rtstrend",
                    "K√§ufer sind nur vor√ºbergehend schw√§cher",
                    "Trend bleibt intakt, Volumen sinkt w√§hrend Flagge"
                ],
                entry: "Bruch √ºber die obere Grenze der Flagge",
                target: "L√§nge des Mastes vom Ausbruchspunkt nach oben",
                stopLoss: "Unter der Flagge oder unter dem Flaggen-Tief",
                invalidation: "Kurs bricht unter die Flagge",
                patternType: "Bullische Fortsetzung",
                reliability: "‚≠ê‚≠ê‚≠ê‚≠ê",
                reliabilityText: "Hoch",
                strength: "Stark",
                context: "Starker Aufw√§rtstrend",
                relatedPatterns: [
                    { key: "bear_flag", name: "Bear Flag", relation: "Gegenst√ºck" },
                    { key: "ascending_triangle", name: "Ascending Triangle", relation: "Verwandt" },
                    { key: "cup_and_handle", name: "Cup & Handle", relation: "L√§ngerfristig" }
                ]
            },
            bear_flag: {
                name: "Bear Flag",
                direction: "bearish",
                category: "continuation",
                shortDescription: "Das Bear Flag Pattern ist eine b√§rische Fortsetzungsformation bestehend aus zwei Teilen: dem \"Flaggenmast\" (starker Abfall) und der \"Flagge\" (Konsolidierung mit leichtem Anstieg). Die Formation signalisiert eine Unterbrechung des Abw√§rtstrends vor dem Fortgang.",
                components: [
                    { number: "1", name: "Flaggenmast", desc: "Steiler, schneller Abfall" },
                    { number: "2", name: "Flagge", desc: "Konsolidierung (25-50% Erholung)" },
                    { number: "3", name: "Ausbruch", desc: "Fortsetzung nach unten" }
                ],
                neckline: "Die Flagge wird von zwei parallelen, leicht nach oben geneigten Trendlinien gebildet.",
                meaning: [
                    "Signalisiert Verschnaufpause in starkem Abw√§rtstrend",
                    "Verk√§ufer sind nur vor√ºbergehend schw√§cher",
                    "Trend bleibt intakt, Volumen sinkt w√§hrend Flagge"
                ],
                entry: "Bruch unter die untere Grenze der Flagge",
                target: "L√§nge des Mastes vom Ausbruchspunkt nach unten",
                stopLoss: "√úber der Flagge oder √ºber dem Flaggen-Hoch",
                invalidation: "Kurs bricht √ºber die Flagge",
                patternType: "B√§rische Fortsetzung",
                reliability: "‚≠ê‚≠ê‚≠ê‚≠ê",
                reliabilityText: "Hoch",
                strength: "Stark",
                context: "Starker Abw√§rtstrend",
                relatedPatterns: [
                    { key: "bull_flag", name: "Bull Flag", relation: "Gegenst√ºck" },
                    { key: "descending_triangle", name: "Descending Triangle", relation: "Verwandt" },
                    { key: "head_and_shoulders", name: "Head & Shoulders", relation: "Umkehr" }
                ]
            },
            rising_wedge: {
                name: "Rising Wedge",
                direction: "bearish",
                category: "reversal",
                shortDescription: "Das Rising Wedge ist eine b√§rische Umkehrformation mit zwei aufw√§rts geneigten, konvergierenden Trendlinien. Der Kurs macht h√∂here Hochs und h√∂here Tiefs, aber die Dynamik l√§sst nach.",
                components: [
                    { number: "1", name: "Steigende Hochs", desc: "Obere Linie steigt" },
                    { number: "2", name: "Steigende Tiefs", desc: "Untere Linie steigt steiler" },
                    { number: "3", name: "Konvergenz", desc: "Linien n√§hern sich an" }
                ],
                neckline: "Beide Trendlinien steigen, aber die untere Linie steigt schneller, was zur Konvergenz f√ºhrt.",
                meaning: [
                    "Zeigt nachlassende Aufw√§rtsdynamik trotz h√∂herer Kurse",
                    "Ersch√∂pfungsmuster - K√§ufer verlieren Kraft",
                    "Typisch am Ende eines Aufw√§rtstrends"
                ],
                entry: "Bruch unter die untere Trendlinie",
                target: "Breitester Teil des Wedge nach unten",
                stopLoss: "√úber dem letzten Hochpunkt",
                invalidation: "Kurs bricht √ºber die obere Linie mit Volumen",
                patternType: "Bearische Umkehr",
                reliability: "‚≠ê‚≠ê‚≠ê‚≠ê",
                reliabilityText: "Hoch",
                strength: "Stark",
                context: "Ende eines Aufw√§rtstrends",
                relatedPatterns: [
                    { key: "falling_wedge", name: "Falling Wedge", relation: "Gegenst√ºck" },
                    { key: "ascending_triangle", name: "Ascending Triangle", relation: "Unterschied" },
                    { key: "head_and_shoulders", name: "Head & Shoulders", relation: "√Ñhnlich" }
                ]
            },
            falling_wedge: {
                name: "Falling Wedge",
                direction: "bullish",
                category: "reversal",
                shortDescription: "Das Falling Wedge ist eine bullische Umkehrformation mit zwei abw√§rts geneigten, konvergierenden Trendlinien. Der Kurs macht tiefere Tiefs und tiefere Hochs, aber die Dynamik l√§sst nach.",
                components: [
                    { number: "1", name: "Fallende Tiefs", desc: "Untere Linie f√§llt" },
                    { number: "2", name: "Fallende Hochs", desc: "Obere Linie f√§llt steiler" },
                    { number: "3", name: "Konvergenz", desc: "Linien n√§hern sich an" }
                ],
                neckline: "Beide Trendlinien fallen, aber die obere Linie f√§llt schneller, was zur Konvergenz f√ºhrt.",
                meaning: [
                    "Zeigt nachlassende Abw√§rtsdynamik trotz tieferer Kurse",
                    "Ersch√∂pfungsmuster - Verk√§ufer verlieren Kraft",
                    "Typisch am Ende eines Abw√§rtstrends"
                ],
                entry: "Bruch √ºber die obere Trendlinie",
                target: "Breitester Teil des Wedge nach oben",
                stopLoss: "Unter dem letzten Tiefpunkt",
                invalidation: "Kurs bricht unter die untere Linie mit Volumen",
                patternType: "Bullische Umkehr",
                reliability: "‚≠ê‚≠ê‚≠ê‚≠ê",
                reliabilityText: "Hoch",
                strength: "Stark",
                context: "Ende eines Abw√§rtstrends",
                relatedPatterns: [
                    { key: "rising_wedge", name: "Rising Wedge", relation: "Gegenst√ºck" },
                    { key: "descending_triangle", name: "Descending Triangle", relation: "Unterschied" },
                    { key: "inverse_head_and_shoulders", name: "Inverse H&S", relation: "√Ñhnlich" }
                ]
            },
            cup_and_handle: {
                name: "Cup & Handle",
                direction: "bullish",
                category: "continuation",
                shortDescription: "Das Cup & Handle Pattern ist eine bullische Fortsetzungsformation mit einer U-f√∂rmigen \"Tasse\" (Cup) gefolgt von einer kleineren Konsolidierungs-Phase genannt \"Henkel\" (Handle). Die Formation tritt nach einem Aufw√§rtstrend auf und signalisiert eine Pause vor der Fortsetzung.",
                components: [
                    { number: "1", name: "Tasse (Cup)", desc: "U-f√∂rmiges Muster √ºber Wochen/Monate" },
                    { number: "2", name: "Henkel (Handle)", desc: "Kleine Konsolidierung (max 50% der Tasse)" },
                    { number: "3", name: "Ausbruch", desc: "Bruch √ºber den Henkel" }
                ],
                neckline: "Das Widerstandsniveau am oberen Rand der Tasse wird durch den urspr√ºnglichen Hochpunkt definiert.",
                meaning: [
                    "Verk√§ufer hatten Gelegenheit zum Verkauf (Tasse), aber Trend setzte sich fort",
                    "Der Henkel testet das Sentiment ein weiteres Mal",
                    "Sehr zuverl√§ssig, da mehrere Umkehrversuche gescheitert sind"
                ],
                entry: "Bruch √ºber das Hochpunkt des Henkels",
                target: "Tiefe der Tasse vom Ausbruchspunkt nach oben",
                stopLoss: "Unter der Henkel-Linie oder unter der Tassen-Unterst√ºtzung",
                invalidation: "Kurs f√§llt unter die Tassen-Unterst√ºtzung",
                patternType: "Bullische Fortsetzung",
                reliability: "‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê",
                reliabilityText: "Sehr Hoch",
                strength: "Sehr stark",
                context: "Aufw√§rtstrend (Wochen/Monate)",
                relatedPatterns: [
                    { key: "rounding_bottom", name: "Rounding Bottom", relation: "√Ñhnlich" },
                    { key: "ascending_triangle", name: "Ascending Triangle", relation: "K√ºrzer" },
                    { key: "bull_flag", name: "Bull Flag", relation: "Schneller" }
                ]
            },
            rectangle: {
                name: "Rectangle",
                direction: "neutral",
                category: "continuation",
                shortDescription: "Das Rectangle Pattern ist eine neutrale Konsolidierungsformation mit horizontalen Unterst√ºtzungs- und Widerstandslinien. Der Kurs pendelt zwischen diesen Linien, bis ein Ausbruch in Richtung des vorherigen Trends erfolgt.",
                components: [
                    { number: "1", name: "Widerstand", desc: "Horizontale obere Grenze" },
                    { number: "2", name: "Unterst√ºtzung", desc: "Horizontale untere Grenze" },
                    { number: "3", name: "Trading Range", desc: "Seitw√§rtsbewegung dazwischen" }
                ],
                neckline: "Beide Linien sind horizontal und definieren die Trading Range. Der Ausbruch in Trendrichtung ist wahrscheinlicher.",
                meaning: [
                    "Zeigt eine Pause im Trend - Angebot und Nachfrage im Gleichgewicht",
                    "Akkumulationsphase (bullisch) oder Distributionsphase (bearisch)",
                    "Je l√§nger die Konsolidierung, desto st√§rker der Ausbruch"
                ],
                entry: "Bruch √ºber/unter die Range-Grenze mit Volumen",
                target: "H√∂he der Range vom Ausbruchspunkt",
                stopLoss: "Auf der gegen√ºberliegenden Seite der Range",
                invalidation: "Falscher Ausbruch mit R√ºckkehr in die Range",
                patternType: "Neutrale Fortsetzung",
                reliability: "‚≠ê‚≠ê‚≠ê",
                reliabilityText: "Mittel",
                strength: "Mittel",
                context: "Trend-Konsolidierung",
                relatedPatterns: [
                    { key: "symmetrical_triangle", name: "Symm. Triangle", relation: "√Ñhnlich" },
                    { key: "bull_flag", name: "Bull Flag", relation: "Bullisch" },
                    { key: "bear_flag", name: "Bear Flag", relation: "Bearisch" }
                ]
            },
            rounding_bottom: {
                name: "Rounding Bottom",
                direction: "bullish",
                category: "reversal",
                shortDescription: "Das Rounding Bottom (Saucer Bottom) ist eine bullische Umkehrformation mit einer langsamen, U-f√∂rmigen Kursbewegung. Der √úbergang von Abw√§rts- zu Aufw√§rtstrend erfolgt graduell √ºber einen l√§ngeren Zeitraum.",
                components: [
                    { number: "1", name: "Abstieg", desc: "Langsamer, gradueller R√ºckgang" },
                    { number: "2", name: "Boden", desc: "Flacher, gerundeter Tiefpunkt" },
                    { number: "3", name: "Anstieg", desc: "Langsamer, gradueller Anstieg" }
                ],
                neckline: "Das Widerstandsniveau wird durch den Startpunkt der Formation definiert. Ein Bruch dar√ºber best√§tigt das Muster.",
                meaning: [
                    "Signalisiert langsamen Stimmungswandel von bearisch zu bullisch",
                    "Institutionelle Akkumulation √ºber l√§ngeren Zeitraum",
                    "Sehr zuverl√§ssig f√ºr l√§ngerfristige Trendwenden"
                ],
                entry: "Bruch √ºber den Widerstand am rechten Rand",
                target: "Tiefe des Bodens vom Ausbruchspunkt nach oben",
                stopLoss: "Unter dem tiefsten Punkt des Bodens",
                invalidation: "Kurs f√§llt zur√ºck unter den Boden",
                patternType: "Bullische Umkehr",
                reliability: "‚≠ê‚≠ê‚≠ê",
                reliabilityText: "Zuverl√§ssig (L√§ngerfristig)",
                strength: "Stark",
                context: "Nach l√§ngerem Abw√§rtstrend",
                relatedPatterns: [
                    { key: "cup_and_handle", name: "Cup & Handle", relation: "Mit Henkel" },
                    { key: "double_bottom", name: "Double Bottom", relation: "Schneller" },
                    { key: "inverse_head_and_shoulders", name: "Inverse H&S", relation: "√Ñhnlich" }
                ]
            }
        };

        // =============================================================================
        // Pattern Detail Modal Functions
        // =============================================================================

        // Pattern-Key aus Titel ableiten
        function getPatternKeyFromTitle(title) {
            const mapping = {
                'head & shoulders': 'head_and_shoulders',
                'inv. head & shoulders': 'inverse_head_and_shoulders',
                'inverse head & shoulders': 'inverse_head_and_shoulders',
                'double top': 'double_top',
                'double bottom': 'double_bottom',
                'triple top': 'triple_top',
                'triple bottom': 'triple_bottom',
                'ascending triangle': 'ascending_triangle',
                'descending triangle': 'descending_triangle',
                'symmetrical triangle': 'symmetrical_triangle',
                'bull flag': 'bull_flag',
                'bear flag': 'bear_flag',
                'rising wedge': 'rising_wedge',
                'falling wedge': 'falling_wedge',
                'cup & handle': 'cup_and_handle',
                'rectangle': 'rectangle',
                'rounding bottom': 'rounding_bottom'
            };
            return mapping[title.toLowerCase()] || title.toLowerCase().replace(/ /g, '_');
        }

        // Modal √∂ffnen
        function showPatternDetail(patternKey) {
            const data = patternDetailData[patternKey];
            if (!data) {
                console.error('Pattern nicht gefunden:', patternKey);
                showToast('Pattern-Details nicht gefunden', 'error');
                return;
            }

            currentPatternDetailKey = patternKey;

            // Title
            document.getElementById('patternDetailTitle').textContent = data.name;

            // Badges
            const badgesHtml = `
                <span class="pattern-overview-badge ${data.direction}">${data.direction === 'bullish' ? 'Bullish' : data.direction === 'bearish' ? 'Bearish' : 'Neutral'}</span>
                <span class="pattern-overview-badge" style="background: rgba(156, 39, 176, 0.2); color: #ce93d8;">${data.category === 'reversal' ? 'Umkehr' : 'Fortsetzung'}</span>
            `;
            document.getElementById('patternDetailBadges').innerHTML = badgesHtml;

            // SVG - gr√∂√üer f√ºr Detail-Ansicht
            const svg = getPatternSvg(patternKey);
            document.getElementById('patternDetailSvg').innerHTML = svg;

            // Beschreibung
            document.getElementById('patternDetailDescription').textContent = data.shortDescription;

            // Komponenten
            const componentsHtml = data.components.map(c => `
                <div class="pattern-component-card">
                    <div class="pattern-component-number">${c.number}</div>
                    <div class="pattern-component-name">${c.name}</div>
                    <div class="pattern-component-desc">${c.desc}</div>
                </div>
            `).join('');
            document.getElementById('patternDetailComponents').innerHTML = componentsHtml;

            // Neckline/Support Info
            document.getElementById('patternDetailNeckline').innerHTML = `<strong>‚ÑπÔ∏è</strong> ${data.neckline}`;

            // Bedeutung
            const meaningHtml = data.meaning.map(m => `<li>${m}</li>`).join('');
            document.getElementById('patternDetailMeaning').innerHTML = meaningHtml;

            // Trading Strategie
            document.getElementById('patternDetailEntry').textContent = data.entry;
            document.getElementById('patternDetailTarget').textContent = data.target;
            document.getElementById('patternDetailStopLoss').textContent = data.stopLoss;
            document.getElementById('patternDetailInvalidation').textContent = data.invalidation;

            // Quick Facts
            document.getElementById('patternDetailType').textContent = data.patternType;
            document.getElementById('patternDetailType').className = `pattern-fact-value ${data.direction}`;
            document.getElementById('patternDetailReliability').innerHTML = `${data.reliability}<br><span style="font-size: 0.7rem; color: #888;">${data.reliabilityText}</span>`;
            document.getElementById('patternDetailStrength').textContent = data.strength;
            document.getElementById('patternDetailContext').textContent = data.context;

            // Related Patterns
            const relatedHtml = data.relatedPatterns.map(r => `
                <div class="related-pattern-chip" onclick="showPatternDetail('${r.key}')">
                    <span class="related-pattern-name">${r.name}</span>
                    <span class="related-pattern-relation">${r.relation}</span>
                </div>
            `).join('');
            document.getElementById('patternDetailRelated').innerHTML = relatedHtml;

            // Modal anzeigen
            document.getElementById('patternDetailModal').classList.add('show');
        }

        // Modal schlie√üen
        function closePatternDetailModal() {
            document.getElementById('patternDetailModal').classList.remove('show');
        }

        // Zu Pattern-Erkennung wechseln
        function goToPatternDetectionFromDetail() {
            closePatternDetailModal();
            // Tab wechseln
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('tab-detection').classList.add('active');
            document.querySelectorAll('.tab-btn')[1].classList.add('active');
        }

        // Click-Handler f√ºr Pattern-Cards initialisieren
        function initPatternCardClickHandlers() {
            document.querySelectorAll('.pattern-overview-card').forEach(card => {
                const titleElement = card.querySelector('.pattern-overview-title');
                if (titleElement) {
                    const title = titleElement.textContent;
                    const patternKey = getPatternKeyFromTitle(title);

                    card.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showPatternDetail(patternKey);
                    });
                }
            });
        }

        // Keyboard Navigation f√ºr Modal
        document.addEventListener('keydown', (e) => {
            if (document.getElementById('patternDetailModal').classList.contains('show')) {
                if (e.key === 'Escape') {
                    closePatternDetailModal();
                }
            }
        });

        // Tab Navigation
        function showTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`tab-${tabName}`).classList.add('active');
            event.target.classList.add('active');

            // Load status tab data when switching to it
            if (tabName === 'status') {
                refreshStatusTab();
            }
        }

        // Status Tab Functions
        async function refreshStatusTab() {
            // Reload all header status info
            await loadInfo();
        }

        // Pattern Filter Logic for Status Tab
        document.querySelectorAll('.pattern-filter-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const filter = btn.dataset.filter;

                // Update active button
                document.querySelectorAll('.pattern-filter-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                // Filter patterns
                document.querySelectorAll('.pattern-overview-card').forEach(card => {
                    if (filter === 'all' || card.dataset.direction === filter) {
                        card.classList.remove('hidden');
                    } else {
                        card.classList.add('hidden');
                    }
                });
            });
        });

        // Toast Notification
        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        // Format Uptime
        function formatUptime(seconds) {
            const days = Math.floor(seconds / 86400);
            const hours = Math.floor((seconds % 86400) / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            if (days > 0) return `${days}d ${hours}h`;
            if (hours > 0) return `${hours}h ${mins}m`;
            if (mins > 0) return `${mins}m ${secs}s`;
            return `${secs}s`;
        }

        // Parse UTC timestamp (timestamps from API are UTC but without Z suffix)
        function parseUTCTimestamp(timestamp) {
            if (!timestamp) return null;
            // If timestamp doesn't have timezone info, treat as UTC
            if (!timestamp.endsWith('Z') && !timestamp.includes('+')) {
                timestamp = timestamp + 'Z';
            }
            return new Date(timestamp);
        }

        // Format UTC timestamp to local timezone
        function formatLocalDateTime(timestamp, options = { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' }) {
            const date = parseUTCTimestamp(timestamp);
            if (!date || isNaN(date.getTime())) return '-';
            return date.toLocaleString('de-CH', { timeZone: 'Europe/Zurich', ...options });
        }

        // Format pattern time range (start to end)
        function formatPatternTimeRange(startTime, endTime) {
            if (!startTime || !endTime) return '-';
            const startDate = parseUTCTimestamp(startTime);
            const endDate = parseUTCTimestamp(endTime);
            if (!startDate || !endDate || isNaN(startDate.getTime()) || isNaN(endDate.getTime())) return '-';

            const options = { day: '2-digit', month: '2-digit', year: '2-digit' };
            const start = startDate.toLocaleString('de-CH', { timeZone: 'Europe/Zurich', ...options });
            const end = endDate.toLocaleString('de-CH', { timeZone: 'Europe/Zurich', ...options });
            return `${start} - ${end}`;
        }

        // Pattern Type Detection
        function getPatternType(pattern) {
            const bullish = ['inverse_head_and_shoulders', 'double_bottom', 'triple_bottom', 'ascending_triangle', 'bull_flag', 'cup_and_handle', 'falling_wedge', 'channel_up'];
            const bearish = ['head_and_shoulders', 'double_top', 'triple_top', 'descending_triangle', 'bear_flag', 'rising_wedge', 'channel_down'];
            if (bullish.includes(pattern)) return 'bullish';
            if (bearish.includes(pattern)) return 'bearish';
            return 'neutral';
        }

        function formatPatternName(pattern) {
            const names = {
                'head_and_shoulders': 'Head & Shoulders',
                'inverse_head_and_shoulders': 'Inv. H&S',
                'double_top': 'Double Top',
                'double_bottom': 'Double Bottom',
                'triple_top': 'Triple Top',
                'triple_bottom': 'Triple Bottom',
                'ascending_triangle': 'Asc. Triangle',
                'descending_triangle': 'Desc. Triangle',
                'symmetrical_triangle': 'Sym. Triangle',
                'bull_flag': 'Bull Flag',
                'bear_flag': 'Bear Flag',
                'cup_and_handle': 'Cup & Handle',
                'rising_wedge': 'Rising Wedge',
                'falling_wedge': 'Falling Wedge',
                'channel_up': 'Channel Up',
                'channel_down': 'Channel Down'
            };
            return names[pattern] || pattern.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
        }

        // Load Service Info
        async function loadInfo() {
            try {
                const [infoRes, statsRes, trainStatusRes] = await Promise.all([
                    fetch(`${API_BASE}/info`),
                    fetch(`${API_BASE}/stats`),
                    fetch(`${TRAIN_API_BASE}/train/status`).catch(() => null)
                ]);

                if (!infoRes.ok || !statsRes.ok) throw new Error('Failed to load data');

                const info = await infoRes.json();
                const stats = await statsRes.json();
                const trainStatus = trainStatusRes?.ok ? await trainStatusRes.json() : { status: 'unknown' };
                const isTraining = trainStatus.status === 'training' || trainStatus.status === 'preparing';

                // Update status badge
                const badge = document.getElementById('status-badge');
                badge.textContent = info.model?.loaded ? 'Online' : 'Offline';
                badge.className = `service-badge ${info.model?.loaded ? '' : 'offline'}`;

                // Update header status bar KPIs
                document.getElementById('stat-params').textContent = info.model?.parameters ? (info.model.parameters / 1000000).toFixed(2) + 'M' : '-';
                document.getElementById('stat-uptime').textContent = stats.uptime_seconds ? formatUptime(stats.uptime_seconds) : '-';

                // Update header status values
                const serviceValue = document.getElementById('statusValue-service');
                const modelValue = document.getElementById('statusValue-model');
                const deviceValue = document.getElementById('statusValue-device');

                if (serviceValue) {
                    serviceValue.textContent = info.model?.loaded ? 'Online' : 'Offline';
                    serviceValue.style.color = info.model?.loaded ? '#81c784' : '#e57373';
                }
                if (modelValue) {
                    // Extract model name from path (e.g., "/app/data/models/tcn/latest.pt" -> "latest.pt")
                    const modelPath = info.model?.path || '';
                    const modelName = modelPath ? modelPath.split('/').pop() : null;
                    modelValue.textContent = info.model?.loaded ? (modelName || 'Geladen') : 'Nicht geladen';
                    modelValue.style.color = info.model?.loaded ? '#81c784' : '#ffb74d';
                }
                if (deviceValue) {
                    const device = info.model?.device || 'CPU';
                    deviceValue.textContent = device;
                    deviceValue.style.color = device.toLowerCase().includes('cuda') ? '#81c784' : '#64c8ff';
                }
            } catch (error) {
                showToast('Fehler beim Laden der Service-Info', 'error');
                console.error(error);
            }
        }

        // Detect Pattern
        async function detectPattern() {
            const btn = document.getElementById('btn-detect');
            btn.classList.add('btn-loading');
            btn.disabled = true;

            const symbol = document.getElementById('detect-symbol').value;
            const timeframe = document.getElementById('detect-timeframe').value;
            const minConfidence = parseFloat(document.getElementById('detect-confidence').value);

            if (!symbol) {
                showToast('Bitte Symbol ausw√§hlen', 'error');
                btn.classList.remove('btn-loading');
                btn.disabled = false;
                return;
            }

            // Show progress bar
            const progressDiv = document.getElementById('scan-progress');
            progressDiv.style.display = 'block';
            document.getElementById('scan-progress-text').textContent = 'Erkenne Patterns...';
            document.getElementById('scan-progress-percent').textContent = '50%';
            document.getElementById('scan-progress-bar').style.width = '50%';
            document.getElementById('scan-current-symbol').textContent = symbol;
            document.getElementById('scan-current-tf').textContent = timeframe;
            document.getElementById('scan-patterns-found').textContent = '...';

            try {
                const response = await fetch(`${API_BASE}/detect/${symbol}?timeframe=${timeframe}&min_confidence=${minConfidence}`);
                if (!response.ok) throw new Error('Detection failed');

                const data = await response.json();
                const patternsFound = data.patterns ? data.patterns.length : 0;

                // Update progress to 100%
                document.getElementById('scan-progress-percent').textContent = '100%';
                document.getElementById('scan-progress-bar').style.width = '100%';
                document.getElementById('scan-patterns-found').textContent = patternsFound;
                document.getElementById('scan-progress-text').textContent = 'Abgeschlossen';

                // Show result toast
                if (patternsFound > 0) {
                    showToast(`${patternsFound} Pattern(s) f√ºr ${symbol} erkannt`);
                } else {
                    showToast(`Keine Patterns f√ºr ${symbol} erkannt`, 'info');
                }

                // Refresh the pattern history table
                await loadPatternHistory();

                // Hide progress after short delay
                setTimeout(() => {
                    progressDiv.style.display = 'none';
                }, 1500);

            } catch (error) {
                showToast('Fehler bei der Pattern-Erkennung', 'error');
                console.error(error);
                progressDiv.style.display = 'none';
            } finally {
                btn.classList.remove('btn-loading');
                btn.disabled = false;
            }
        }

        // =============================================================================
        // Auto-Scan Functions (Pattern Detection)
        // =============================================================================

        // Load Auto-Scan Status for Detection Tab
        async function loadAutoScanStatus() {
            try {
                const response = await fetch(`${API_BASE}/history/statistics`);
                if (!response.ok) throw new Error('Failed to load auto-scan status');

                const stats = await response.json();

                // Update status indicator
                const statusIndicator = document.getElementById('autoscan-status-indicator');
                if (stats.scan_running) {
                    statusIndicator.innerHTML = '<span style="color: #4caf50;">Aktiv</span>';
                    document.getElementById('btn-start-autoscan').disabled = true;
                    document.getElementById('btn-stop-autoscan').disabled = false;
                } else {
                    statusIndicator.innerHTML = '<span style="color: #ffc107;">Gestoppt</span>';
                    document.getElementById('btn-start-autoscan').disabled = false;
                    document.getElementById('btn-stop-autoscan').disabled = true;
                }

                // Update other stats
                document.getElementById('autoscan-total').textContent = stats.total_patterns || 0;
                document.getElementById('autoscan-symbols').textContent = stats.symbols_with_patterns || 0;
                document.getElementById('autoscan-lastscan').textContent = stats.last_scan
                    ? formatLocalDateTime(stats.last_scan)
                    : '-';

            } catch (error) {
                console.error('Error loading auto-scan status:', error);
            }
        }

        // Toggle Auto-Scan
        async function toggleAutoScan(enable) {
            const endpoint = enable ? 'start-auto-scan' : 'stop-auto-scan';
            const btn = enable ? document.getElementById('btn-start-autoscan') : document.getElementById('btn-stop-autoscan');
            btn.classList.add('btn-loading');
            btn.disabled = true;

            try {
                const response = await fetch(`${API_BASE}/history/${endpoint}`, { method: 'POST' });
                if (!response.ok) throw new Error('Failed to toggle auto-scan');

                const result = await response.json();
                showToast(enable ? 'Auto-Erkennung gestartet' : 'Auto-Erkennung gestoppt');
                loadAutoScanStatus();

            } catch (error) {
                showToast('Fehler beim √Ñndern des Auto-Scan Status', 'error');
                console.error(error);
            } finally {
                btn.classList.remove('btn-loading');
            }
        }

        // Load Symbols for Detection Dropdown
        async function loadDetectionSymbols() {
            const select = document.getElementById('detect-symbol');

            try {
                const response = await fetch('/data/api/v1/managed-symbols');
                if (!response.ok) throw new Error('Failed to load symbols');

                const data = await response.json();

                // Filter active symbols with data
                const symbols = data
                    .filter(s => s.has_timescaledb_data && s.status === 'active')
                    .sort((a, b) => a.symbol.localeCompare(b.symbol));

                select.innerHTML = '';

                // Add default option
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = 'Symbol w√§hlen...';
                select.appendChild(defaultOption);

                // Add symbols
                symbols.forEach(s => {
                    const option = document.createElement('option');
                    option.value = s.symbol;
                    option.textContent = s.display_name || s.symbol;
                    select.appendChild(option);
                });

                // Select first symbol if available
                if (symbols.length > 0) {
                    select.value = symbols[0].symbol;
                }

            } catch (error) {
                console.error('Error loading detection symbols:', error);
                // Fallback
                select.innerHTML = `
                    <option value="BTCUSD">BTCUSD</option>
                    <option value="ETHUSD">ETHUSD</option>
                    <option value="EURUSD">EURUSD</option>
                    <option value="XAUUSD">XAUUSD</option>
                `;
            }
        }

        // Scan cancellation flag
        let scanCancelled = false;

        // Cancel ongoing scan
        function cancelScan() {
            scanCancelled = true;
            showToast('Scan wird abgebrochen...', 'warning');
        }

        // Update scan progress UI
        function updateScanProgress(current, total, symbol, timeframe, patternsFound) {
            const percent = Math.round((current / total) * 100);
            document.getElementById('scan-progress-bar').style.width = `${percent}%`;
            document.getElementById('scan-progress-percent').textContent = `${percent}%`;
            document.getElementById('scan-progress-text').textContent = `Scanne ${current}/${total}...`;
            document.getElementById('scan-current-symbol').textContent = symbol || '-';
            document.getElementById('scan-current-tf').textContent = timeframe || '-';
            document.getElementById('scan-patterns-found').textContent = patternsFound;
        }

        // Scan All Symbols and Save to History (with progress)
        async function scanAllAndSave() {
            const btn = document.getElementById('btn-scan-all');
            const cancelBtn = document.getElementById('btn-cancel-scan');
            const progressDiv = document.getElementById('scan-progress');
            const resultsDiv = document.getElementById('scan-results');

            // Reset state
            scanCancelled = false;
            btn.style.display = 'none';
            cancelBtn.style.display = 'inline-flex';
            progressDiv.style.display = 'block';
            resultsDiv.innerHTML = '';

            let totalPatternsFound = 0;
            let totalPatternsAdded = 0;
            let scannedCount = 0;

            try {
                // Get available symbols
                const symbolsResponse = await fetch('/data/api/v1/symbols');
                let symbols = [];
                if (symbolsResponse.ok) {
                    const symbolsData = await symbolsResponse.json();
                    symbols = symbolsData.symbols || symbolsData || [];
                    if (symbols.length > 0 && typeof symbols[0] === 'object') {
                        symbols = symbols.map(s => s.symbol || s.name || s);
                    }
                }

                if (symbols.length === 0) {
                    // Fallback to default symbols
                    symbols = ['BTCUSD', 'ETHUSD', 'EURUSD', 'GBPUSD', 'XAUUSD', 'USDJPY'];
                }

                updateScanProgress(0, symbols.length, '-', '-', 0);

                // Scan each symbol (all timeframes at once via API)
                for (const symbol of symbols) {
                    if (scanCancelled) break;

                    scannedCount++;
                    const allTimeframes = '5m,15m,30m,1h,4h,1d';
                    updateScanProgress(scannedCount, symbols.length, symbol, allTimeframes, totalPatternsFound);

                    try {
                        // Use history/scan endpoint with symbol parameter
                        const response = await fetch(
                            `${API_BASE}/history/scan?symbol=${symbol}&timeframes=${allTimeframes}&threshold=0.5`,
                            { method: 'POST' }
                        );

                        if (response.ok) {
                            const result = await response.json();
                            totalPatternsFound += result.patterns_found || 0;
                            totalPatternsAdded += result.patterns_added || 0;
                            updateScanProgress(scannedCount, symbols.length, symbol, allTimeframes, totalPatternsFound);
                        }
                    } catch (e) {
                        console.warn(`Scan failed for ${symbol}:`, e);
                    }
                }

                // Show results
                if (scanCancelled) {
                    resultsDiv.innerHTML = `
                        <div class="info-box" style="background: rgba(255,152,0,0.1); border-color: rgba(255,152,0,0.3); color: #ffb74d; margin-top: 0.5rem;">
                            <strong>Scan abgebrochen</strong><br>
                            ${scannedCount}/${symbols.length} Symbole gescannt, ${totalPatternsFound} Patterns gefunden, ${totalPatternsAdded} neu
                        </div>
                    `;
                    showToast('Scan abgebrochen', 'warning');
                } else {
                    resultsDiv.innerHTML = `
                        <div class="info-box" style="background: rgba(76,175,80,0.1); border-color: rgba(76,175,80,0.3); color: #81c784; margin-top: 0.5rem;">
                            <strong>Scan abgeschlossen</strong><br>
                            ${symbols.length} Symbole gescannt (M5-D1), ${totalPatternsFound} Patterns gefunden, ${totalPatternsAdded} neu gespeichert
                        </div>
                    `;
                    showToast(`Scan: ${totalPatternsFound} Patterns gefunden`);
                }

                // Refresh pattern history and stats
                loadPatternHistory();
                loadAutoScanStatus();

            } catch (error) {
                showToast('Fehler beim Scan', 'error');
                console.error(error);
                resultsDiv.innerHTML = `
                    <div class="info-box" style="background: rgba(244,67,54,0.1); border-color: rgba(244,67,54,0.3); color: #e57373; margin-top: 0.5rem;">
                        <strong>Fehler</strong><br>
                        ${error.message}
                    </div>
                `;
            } finally {
                btn.style.display = 'inline-flex';
                cancelBtn.style.display = 'none';
                progressDiv.style.display = 'none';
            }
        }

        // Legacy function for backwards compatibility
        async function scanAll() {
            return scanAllAndSave();
        }

        // Format duration from start time
        function formatDuration(startTimeISO) {
            if (!startTimeISO) return '-';
            const start = new Date(startTimeISO);
            const now = new Date();
            const diffMs = now - start;
            const diffSecs = Math.floor(diffMs / 1000);
            const mins = Math.floor(diffSecs / 60);
            const secs = diffSecs % 60;
            const hours = Math.floor(mins / 60);
            if (hours > 0) return `${hours}h ${mins % 60}m ${secs}s`;
            if (mins > 0) return `${mins}m ${secs}s`;
            return `${secs}s`;
        }

        // Load Training Status
        async function loadTrainingStatus() {
            try {
                const response = await fetch(`${TRAIN_API_BASE}/train/status`);
                if (!response.ok) throw new Error('Failed to load training status');

                const data = await response.json();
                const container = document.getElementById('training-status');
                const progressSection = document.getElementById('training-progress-section');

                const isTraining = data.status === 'training' || data.status === 'preparing';

                if (isTraining) {
                    // Show progress section when training is active
                    progressSection.style.display = 'block';
                    document.getElementById('btn-train').disabled = true;
                    document.getElementById('btn-stop-train').disabled = false;

                    const progressPercent = data.progress ? (data.progress * 100).toFixed(1) : 0;
                    const duration = formatDuration(data.started_at);

                    container.innerHTML = `
                        <div style="background: linear-gradient(135deg, rgba(76,175,80,0.15), rgba(76,175,80,0.05)); border: 1px solid rgba(76,175,80,0.3); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                                <span style="color: #4caf50; font-weight: 600; display: flex; align-items: center; gap: 0.5rem;">
                                    <span class="spinner" style="width: 16px; height: 16px; border-width: 2px;"></span>
                                    Training l√§uft...
                                </span>
                                <span style="background: #4caf50; color: #000; padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.8rem; font-weight: 600;">
                                    ${progressPercent}%
                                </span>
                            </div>
                            <div class="progress-bar" style="height: 8px; margin-bottom: 0.75rem;">
                                <div class="progress-fill" style="width: ${progressPercent}%; background: linear-gradient(90deg, #4caf50, #81c784);"></div>
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem; font-size: 0.85rem;">
                                <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 4px;">
                                    <div style="color: #888;">Epoche</div>
                                    <div style="color: #fff; font-weight: 600;">${data.current_epoch || 0} / ${data.total_epochs || '-'}</div>
                                </div>
                                <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 4px;">
                                    <div style="color: #888;">Laufzeit</div>
                                    <div style="color: #fff; font-weight: 600;">${duration}</div>
                                </div>
                                <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 4px;">
                                    <div style="color: #888;">Samples</div>
                                    <div style="color: #fff; font-weight: 600;">${data.samples_count?.toLocaleString() || '-'}</div>
                                </div>
                                <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 4px;">
                                    <div style="color: #888;">Best Loss</div>
                                    <div style="color: #fff; font-weight: 600;">${data.best_loss?.toFixed(4) || '-'}</div>
                                </div>
                            </div>
                            ${data.job_id ? `<div style="margin-top: 0.75rem; color: #666; font-size: 0.75rem;">Job: ${data.job_id}</div>` : ''}
                        </div>
                    `;
                } else {
                    // Hide progress section when no training
                    progressSection.style.display = 'none';
                    document.getElementById('btn-train').disabled = false;
                    document.getElementById('btn-stop-train').disabled = true;
                    container.innerHTML = '';
                }
            } catch (error) {
                console.error(error);
            }
        }

        // Start Training
        async function startTraining() {
            const btn = document.getElementById('btn-train');
            btn.classList.add('btn-loading');
            btn.disabled = true;

            try {
                // Get selected symbols
                const symbolSelect = document.getElementById('train-symbols');
                const symbols = Array.from(symbolSelect.selectedOptions).map(o => o.value);
                if (symbols.length === 0) {
                    showToast('Bitte mindestens ein Symbol auswahlen', 'error');
                    btn.classList.remove('btn-loading');
                    btn.disabled = false;
                    return;
                }

                const timeframe = document.getElementById('train-timeframe').value;
                const lookbackDays = parseInt(document.getElementById('train-lookback').value);
                const epochs = parseInt(document.getElementById('train-epochs').value);
                const batchSize = parseInt(document.getElementById('train-batch').value);
                const learningRate = parseFloat(document.getElementById('train-lr').value);

                const response = await fetch(`${TRAIN_API_BASE}/train`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        symbols,
                        timeframe,
                        lookback_days: lookbackDays,
                        epochs,
                        batch_size: batchSize,
                        learning_rate: learningRate
                    })
                });

                if (!response.ok) {
                    const errData = await response.json();
                    throw new Error(errData.detail || 'Failed to start training');
                }

                showToast('Training gestartet');
                document.getElementById('btn-stop-train').disabled = false;

                // Show progress section immediately
                document.getElementById('training-progress-section').style.display = 'block';

                // Load status immediately, then start polling
                await loadTrainingStatus();
                trainingInterval = setInterval(loadTrainingStatus, 2000);

            } catch (error) {
                showToast('Fehler beim Starten des Trainings', 'error');
                console.error(error);
                btn.disabled = false;
            } finally {
                btn.classList.remove('btn-loading');
            }
        }

        // Stop Training
        async function stopTraining() {
            try {
                const response = await fetch(`${TRAIN_API_BASE}/train/stop`, { method: 'POST' });
                if (!response.ok) throw new Error('Failed to stop training');

                showToast('Training gestoppt');
                if (trainingInterval) {
                    clearInterval(trainingInterval);
                    trainingInterval = null;
                }
                loadTrainingStatus();
            } catch (error) {
                showToast('Fehler beim Stoppen des Trainings', 'error');
                console.error(error);
            }
        }

        // Load Training History
        async function loadTrainingHistory() {
            try {
                const response = await fetch(`${TRAIN_API_BASE}/train/history`);
                if (!response.ok) throw new Error('Failed to load history');

                const data = await response.json();
                const container = document.getElementById('training-history');

                if (data.history && data.history.length > 0) {
                    // Sort by date (newest first)
                    const sortedHistory = [...data.history].sort((a, b) =>
                        new Date(b.started_at) - new Date(a.started_at)
                    );

                    container.innerHTML = `
                        <table class="data-table">
                            <tr>
                                <th>Datum</th>
                                <th>Status</th>
                                <th>Epochen</th>
                                <th>Samples</th>
                                <th>Best Loss</th>
                                <th>Dauer</th>
                            </tr>
                            ${sortedHistory.map(h => {
                                // Calculate duration from started_at and completed_at
                                let duration = '-';
                                if (h.started_at && h.completed_at) {
                                    const startDate = parseUTCTimestamp(h.started_at);
                                    const endDate = parseUTCTimestamp(h.completed_at);
                                    if (startDate && endDate) {
                                        const durationSecs = Math.floor((endDate - startDate) / 1000);
                                        duration = formatUptime(durationSecs);
                                    }
                                }
                                const statusColor = h.status === 'completed' ? '#4caf50' : h.status === 'failed' ? '#f44336' : '#ffc107';
                                return `
                                <tr>
                                    <td>${formatLocalDateTime(h.started_at)}</td>
                                    <td><span style="color: ${statusColor};">${h.status}</span></td>
                                    <td>${h.current_epoch || 0}/${h.total_epochs || '-'}</td>
                                    <td>${h.samples_count?.toLocaleString() || '-'}</td>
                                    <td>${h.best_loss?.toFixed(4) || '-'}</td>
                                    <td>${duration}</td>
                                </tr>
                            `}).join('')}
                        </table>
                    `;
                } else {
                    container.innerHTML = '<div class="info-box">Noch keine Trainings durchgef√ºhrt.</div>';
                }
            } catch (error) {
                console.error(error);
            }
        }

        // Load Available Models
        async function loadModels() {
            const container = document.getElementById('models-list');

            try {
                const response = await fetch(`${TRAIN_API_BASE}/models`);
                if (!response.ok) throw new Error('Failed to load models');

                const data = await response.json();

                if (data.models && data.models.length > 0) {
                    // Sort by creation date (newest first)
                    const sortedModels = data.models.sort((a, b) =>
                        new Date(b.created) - new Date(a.created)
                    );

                    container.innerHTML = `
                        <div style="margin-bottom: 0.5rem; color: #888; font-size: 0.85rem;">
                            ${data.count} Modell${data.count !== 1 ? 'e' : ''} verf√ºgbar
                        </div>
                        ${sortedModels.map((m, idx) => `
                            <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; background: ${idx === 0 ? 'rgba(76,175,80,0.1)' : 'rgba(255,255,255,0.03)'}; border: 1px solid ${idx === 0 ? 'rgba(76,175,80,0.3)' : 'rgba(255,255,255,0.05)'}; border-radius: 6px; margin-bottom: 0.5rem;">
                                <div style="flex: 1;">
                                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                                        <span style="font-weight: 600; color: #fff;">${m.name}</span>
                                        ${idx === 0 ? '<span style="background: #4caf50; color: #000; padding: 0.1rem 0.4rem; border-radius: 3px; font-size: 0.7rem; font-weight: 600;">AKTUELL</span>' : ''}
                                    </div>
                                    <div style="display: flex; gap: 1rem; margin-top: 0.3rem; font-size: 0.8rem; color: #888;">
                                        <span>&#128197; ${formatLocalDateTime(m.created, { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' })}</span>
                                        <span>&#128190; ${m.size_mb} MB</span>
                                    </div>
                                </div>
                                <button class="btn btn-secondary btn-sm" onclick="loadModel('${m.name}')" ${idx === 0 ? 'disabled' : ''}>
                                    ${idx === 0 ? '&#10004; Geladen' : '&#128194; Laden'}
                                </button>
                            </div>
                        `).join('')}
                    `;
                } else {
                    container.innerHTML = `
                        <div class="info-box" style="text-align: center;">
                            <div style="font-size: 2rem; margin-bottom: 0.5rem;">&#128230;</div>
                            <div>Keine trainierten Modelle vorhanden</div>
                            <div style="font-size: 0.85rem; color: #666; margin-top: 0.5rem;">
                                Starten Sie ein Training um ein Modell zu erstellen
                            </div>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('Error loading models:', error);
                container.innerHTML = '<div class="info-box" style="color: #e57373;">Fehler beim Laden der Modelle</div>';
            }
        }

        // Load specific model (reload model in inference service)
        async function loadModel(modelName) {
            try {
                // Notify inference service to reload the model
                const response = await fetch(`${API_BASE}/model/reload`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ model_path: `data/models/tcn/${modelName}` })
                });

                if (!response.ok) {
                    const errData = await response.json();
                    throw new Error(errData.detail || 'Failed to load model');
                }

                showToast(`Modell ${modelName} geladen`);
                loadModels(); // Refresh list
                loadInfo();   // Refresh service info
            } catch (error) {
                showToast('Fehler beim Laden des Modells', 'error');
                console.error(error);
            }
        }

        // Load Pattern History Statistics
        async function loadHistoryStats() {
            try {
                const response = await fetch(`${API_BASE}/history/statistics`);
                if (!response.ok) throw new Error('Failed to load history stats');

                const stats = await response.json();

                // Pattern types (top 5)
                const typeHtml = Object.entries(stats.by_pattern_type || {}).slice(0, 5)
                    .map(([type, count]) => `<div style="display: flex; justify-content: space-between; padding: 0.25rem 0;"><span>${type.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ')}</span><span style="color: #64c8ff;">${count}</span></div>`)
                    .join('');
                document.getElementById('stats-by-type').innerHTML = typeHtml || '<span style="color: #888;">Keine Daten</span>';

                // Categories
                const catHtml = Object.entries(stats.by_category || {})
                    .map(([cat, count]) => `<div style="display: flex; justify-content: space-between; padding: 0.25rem 0;"><span>${cat}</span><span style="color: #a78bfa;">${count}</span></div>`)
                    .join('');
                document.getElementById('stats-by-category').innerHTML = catHtml || '<span style="color: #888;">Keine Daten</span>';

                // Timeframes
                const tfHtml = Object.entries(stats.by_timeframe || {})
                    .map(([tf, count]) => `<div style="display: flex; justify-content: space-between; padding: 0.25rem 0;"><span>${tf}</span><span style="color: #ffc107;">${count}</span></div>`)
                    .join('');
                document.getElementById('stats-by-timeframe').innerHTML = tfHtml || '<span style="color: #888;">Keine Daten</span>';

            } catch (error) {
                console.error('Error loading history stats:', error);
            }
        }

        // Pattern Filter Storage Key
        const PATTERN_FILTERS_KEY = 'tcn_pattern_filters';

        // Save pattern filters to localStorage
        function savePatternFilters() {
            const filters = {
                symbol: document.getElementById('history-symbol-filter').value,
                pattern: document.getElementById('history-pattern-filter').value,
                timeframe: document.getElementById('history-timeframe-filter').value,
                category: document.getElementById('history-category-filter').value,
                direction: document.getElementById('history-direction-filter').value,
                confidence: document.getElementById('history-confidence-filter').value
            };
            localStorage.setItem(PATTERN_FILTERS_KEY, JSON.stringify(filters));
            updateResetButtonVisibility();
        }

        // Load pattern filters from localStorage
        function loadPatternFilters() {
            try {
                const saved = localStorage.getItem(PATTERN_FILTERS_KEY);
                if (saved) {
                    const filters = JSON.parse(saved);
                    if (filters.symbol) document.getElementById('history-symbol-filter').value = filters.symbol;
                    if (filters.pattern) document.getElementById('history-pattern-filter').value = filters.pattern;
                    if (filters.timeframe) document.getElementById('history-timeframe-filter').value = filters.timeframe;
                    if (filters.category) document.getElementById('history-category-filter').value = filters.category;
                    if (filters.direction) document.getElementById('history-direction-filter').value = filters.direction;
                    if (filters.confidence) document.getElementById('history-confidence-filter').value = filters.confidence;
                }
            } catch (e) {
                console.error('Error loading filters:', e);
            }
            updateResetButtonVisibility();
        }

        // Reset all pattern filters
        function resetPatternFilters() {
            document.getElementById('history-symbol-filter').value = '';
            document.getElementById('history-pattern-filter').value = '';
            document.getElementById('history-timeframe-filter').value = '';
            document.getElementById('history-category-filter').value = '';
            document.getElementById('history-direction-filter').value = '';
            document.getElementById('history-confidence-filter').value = '';
            localStorage.removeItem(PATTERN_FILTERS_KEY);
            updateResetButtonVisibility();
            loadPatternHistory();
        }

        // Show/hide reset button based on active filters
        function updateResetButtonVisibility() {
            const hasFilters =
                document.getElementById('history-symbol-filter').value ||
                document.getElementById('history-pattern-filter').value ||
                document.getElementById('history-timeframe-filter').value ||
                document.getElementById('history-category-filter').value ||
                document.getElementById('history-direction-filter').value ||
                document.getElementById('history-confidence-filter').value;

            const btn = document.getElementById('btn-reset-filters');
            if (btn) {
                btn.style.display = hasFilters ? 'inline-block' : 'none';
            }
        }

        // Load Pattern History Table
        async function loadPatternHistory() {
            const symbol = document.getElementById('history-symbol-filter').value;
            const patternType = document.getElementById('history-pattern-filter').value;
            const timeframe = document.getElementById('history-timeframe-filter').value;
            const category = document.getElementById('history-category-filter').value;
            const direction = document.getElementById('history-direction-filter').value;
            const minConfidence = document.getElementById('history-confidence-filter').value;

            // Save filters to localStorage
            savePatternFilters();

            let url = `${API_BASE}/history?limit=50`;
            if (symbol) url += `&symbol=${symbol}`;
            if (patternType) url += `&pattern_type=${patternType}`;
            if (timeframe) url += `&timeframe=${timeframe}`;
            if (category) url += `&category=${category}`;
            if (direction) url += `&direction=${direction}`;
            if (minConfidence) url += `&min_confidence=${minConfidence}`;

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error('Failed to load pattern history');

                const data = await response.json();
                const tbody = document.getElementById('pattern-history-body');

                if (!data.patterns || data.patterns.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; padding: 2rem; color: #888;">Keine Patterns gefunden</td></tr>';
                    document.getElementById('history-count').textContent = '0 Patterns';
                    return;
                }

                // Sort by pattern_end_time (newest pattern end dates first)
                const sortedPatterns = [...data.patterns].sort((a, b) => {
                    const timeA = a.pattern_end_time || a.detected_at || '';
                    const timeB = b.pattern_end_time || b.detected_at || '';
                    return timeB.localeCompare(timeA);
                });

                // Store full pattern data for click handlers and navigation
                window.patternHistoryData = {};
                sortedPatterns.forEach((p, idx) => {
                    window.patternHistoryData[`pattern_${idx}`] = p;
                });

                // Store pattern list for navigation
                tcnPatternList = sortedPatterns;

                tbody.innerHTML = sortedPatterns.map((p, idx) => `
                    <tr class="clickable-row" onclick="showPatternChart('${p.symbol}', '${p.timeframe}', '${p.detected_at}', '${p.pattern_type}', '${p.direction}', window.patternHistoryData['pattern_${idx}'], ${idx})">
                        <td style="font-weight: 500;">${p.symbol}</td>
                        <td><span class="pattern-badge ${p.direction}">${p.pattern_type.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ')}</span></td>
                        <td><span class="pattern-badge ${p.direction}">${p.direction}</span></td>
                        <td style="color: ${p.confidence >= 0.7 ? '#4caf50' : p.confidence >= 0.5 ? '#ffc107' : '#f44336'};">${(p.confidence * 100).toFixed(1)}%</td>
                        <td>${p.timeframe}</td>
                        <td style="color: #888; font-size: 0.85rem;">${formatPatternTimeRange(p.pattern_start_time, p.pattern_end_time)}</td>
                        <td style="font-family: monospace;">${p.price_at_detection ? p.price_at_detection.toLocaleString('de-CH', {maximumFractionDigits: 2}) : '-'}</td>
                        <td style="text-align: center;">
                            <button type="button" class="btn-chart" onclick="event.stopPropagation(); showPatternChart('${p.symbol}', '${p.timeframe}', '${p.detected_at}', '${p.pattern_type}', '${p.direction}', window.patternHistoryData['pattern_${idx}'], ${idx})" title="Chart anzeigen">
                                &#128200;
                            </button>
                        </td>
                    </tr>
                `).join('');

                document.getElementById('history-count').textContent = `${data.count} Patterns angezeigt`;

                // Update symbol filter
                await updateHistorySymbolFilter();

            } catch (error) {
                console.error('Error loading pattern history:', error);
                document.getElementById('pattern-history-body').innerHTML =
                    '<tr><td colspan="8" style="text-align: center; padding: 2rem; color: #f44336;">Fehler beim Laden</td></tr>';
            }
        }

        // Update symbol filter dropdown
        async function updateHistorySymbolFilter() {
            try {
                const response = await fetch(`${API_BASE}/history-by-symbol?limit_per_symbol=1`);
                if (!response.ok) return;

                const data = await response.json();
                const select = document.getElementById('history-symbol-filter');
                const currentValue = select.value;

                // Keep first option
                while (select.options.length > 1) {
                    select.remove(1);
                }

                Object.keys(data.by_symbol || {}).sort().forEach(symbol => {
                    const option = document.createElement('option');
                    option.value = symbol;
                    option.textContent = symbol;
                    select.appendChild(option);
                });

                select.value = currentValue;
            } catch (error) {
                console.error('Error updating symbol filter:', error);
            }
        }

        // Trigger manual pattern scan
        async function triggerManualScan() {
            try {
                showToast('Scan gestartet...');
                const response = await fetch(`${API_BASE}/history/scan`, { method: 'POST' });
                if (!response.ok) throw new Error('Scan failed');

                const result = await response.json();
                showToast(`Scan abgeschlossen: ${result.patterns_found} Patterns gefunden, ${result.patterns_added} neu`);

                loadPatternHistory();
                loadHistoryStats();
            } catch (error) {
                showToast('Fehler beim Scan', 'error');
                console.error(error);
            }
        }

        // Load Available Symbols from Data Service
        async function loadAvailableSymbols() {
            const select = document.getElementById('train-symbols');
            const countSpan = document.getElementById('symbols-count');

            try {
                // managed-symbols liefert Array mit {symbol, category, has_timescaledb_data, ...}
                const response = await fetch('/data/api/v1/managed-symbols');
                if (!response.ok) throw new Error('Failed to load symbols');

                const data = await response.json();

                // Nur Symbole mit Daten, sortiert nach Kategorie und Name
                const symbols = data
                    .filter(s => s.has_timescaledb_data && s.status === 'active')
                    .sort((a, b) => {
                        // Erst nach Kategorie, dann alphabetisch
                        if (a.category !== b.category) return a.category.localeCompare(b.category);
                        return a.symbol.localeCompare(b.symbol);
                    });

                select.innerHTML = '';
                let currentCategory = '';

                symbols.forEach(s => {
                    // Optgroup f√ºr Kategorien
                    if (s.category !== currentCategory) {
                        currentCategory = s.category;
                        const optgroup = document.createElement('optgroup');
                        optgroup.label = currentCategory.toUpperCase();
                        select.appendChild(optgroup);
                    }

                    const option = document.createElement('option');
                    option.value = s.symbol;
                    option.textContent = s.display_name || s.symbol;
                    option.selected = true; // Alle standardm√§ssig ausgew√§hlt
                    select.lastElementChild.appendChild(option);
                });

                countSpan.textContent = `(${symbols.length} verf√ºgbar)`;

            } catch (error) {
                console.error('Error loading symbols:', error);
                // Fallback auf einige Standard-Symbole
                select.innerHTML = `
                    <option value="BTCUSD" selected>BTCUSD</option>
                    <option value="ETHUSD" selected>ETHUSD</option>
                    <option value="EURUSD" selected>EURUSD</option>
                    <option value="XAUUSD" selected>XAUUSD</option>
                `;
                countSpan.textContent = '(Fallback)';
            }
        }

        // Select All Symbols
        function selectAllSymbols() {
            const select = document.getElementById('train-symbols');
            Array.from(select.options).forEach(o => o.selected = true);
        }

        // Select No Symbols
        function selectNoSymbols() {
            const select = document.getElementById('train-symbols');
            Array.from(select.options).forEach(o => o.selected = false);
        }

        // =============================================================================
        // Auto-Training Functions
        // =============================================================================

        // Load Auto-Training Status
        async function loadAutoTrainingStatus() {
            const container = document.getElementById('auto-training-status');

            try {
                const response = await fetch(`${TRAIN_API_BASE}/auto-training/status`);
                if (!response.ok) throw new Error('Failed to load auto-training status');

                const data = await response.json();

                // Update interval dropdown
                document.getElementById('auto-interval').value = data.interval || 'weekly';

                // Update scheduled time inputs
                document.getElementById('auto-scheduled-hour').value = data.scheduled_hour ?? 2;
                document.getElementById('auto-scheduled-minute').value = data.scheduled_minute ?? 0;

                // Update timeframe checkboxes
                const timeframes = data.timeframes || ['1h', '4h', '1d'];
                document.getElementById('auto-tf-5m').checked = timeframes.includes('5m');
                document.getElementById('auto-tf-15m').checked = timeframes.includes('15m');
                document.getElementById('auto-tf-30m').checked = timeframes.includes('30m');
                document.getElementById('auto-tf-1h').checked = timeframes.includes('1h');
                document.getElementById('auto-tf-4h').checked = timeframes.includes('4h');
                document.getElementById('auto-tf-1d').checked = timeframes.includes('1d');

                // Update buttons
                document.getElementById('btn-enable-auto').disabled = data.enabled;
                document.getElementById('btn-disable-auto').disabled = !data.enabled;

                // Update AUTO badge in header
                const autoBadge = document.getElementById('auto-training-badge');
                if (autoBadge) {
                    autoBadge.style.display = data.enabled ? 'inline-block' : 'none';
                }

                // Format dates
                const lastRun = data.last_run ? formatLocalDateTime(data.last_run, { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' }) : 'Noch nie';
                const nextRun = data.next_run ? formatLocalDateTime(data.next_run, { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' }) : '-';

                const intervalLabels = {
                    'daily': 'Taglich',
                    'weekly': 'Wochentlich',
                    'monthly': 'Monatlich',
                    'manual': 'Manuell'
                };

                const scheduledTime = data.scheduled_time || `${String(data.scheduled_hour ?? 2).padStart(2, '0')}:${String(data.scheduled_minute ?? 0).padStart(2, '0')}`;

                container.innerHTML = `
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; font-size: 0.85rem;">
                        <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 4px;">
                            <div style="color: #888;">Status</div>
                            <div style="color: ${data.enabled ? '#4caf50' : '#888'}; font-weight: 600;">
                                ${data.enabled ? '&#10004; Aktiv' : '&#10008; Inaktiv'}
                            </div>
                        </div>
                        <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 4px;">
                            <div style="color: #888;">Intervall</div>
                            <div style="color: #fff; font-weight: 600;">${intervalLabels[data.interval] || data.interval}</div>
                        </div>
                        <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 4px;">
                            <div style="color: #888;">Startzeit</div>
                            <div style="color: #64c8ff; font-weight: 600;">${scheduledTime} Uhr</div>
                        </div>
                        <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 4px;">
                            <div style="color: #888;">Letzter Lauf</div>
                            <div style="color: #fff; font-weight: 600;">${lastRun}</div>
                        </div>
                        <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 4px; grid-column: span 2;">
                            <div style="color: #888;">N√§chster Lauf</div>
                            <div style="color: #fff; font-weight: 600;">${nextRun}</div>
                        </div>
                    </div>
                    ${data.current_training ? `
                        <div style="margin-top: 0.75rem; padding: 0.5rem; background: rgba(100,200,255,0.1); border: 1px solid rgba(100,200,255,0.3); border-radius: 4px;">
                            <div style="color: #64c8ff; font-weight: 600;">Training lauft...</div>
                            <div style="font-size: 0.8rem; color: #888; margin-top: 0.25rem;">
                                ${data.current_training.symbols?.length || 0} Symbole,
                                ${data.current_training.completed_timeframes?.length || 0}/${data.current_training.timeframes?.length || 0} Timeframes
                            </div>
                        </div>
                    ` : ''}
                `;

            } catch (error) {
                console.error('Error loading auto-training status:', error);
                container.innerHTML = '<div class="info-box" style="color: #e57373;">Fehler beim Laden des Auto-Training Status</div>';
            }
        }

        // Toggle Auto-Training
        async function toggleAutoTraining(enable) {
            try {
                const endpoint = enable ? 'enable' : 'disable';
                const response = await fetch(`${TRAIN_API_BASE}/auto-training/${endpoint}`, {
                    method: 'POST'
                });

                if (!response.ok) throw new Error('Failed to toggle auto-training');

                showToast(enable ? 'Auto-Training aktiviert' : 'Auto-Training deaktiviert');
                loadAutoTrainingStatus();

            } catch (error) {
                showToast('Fehler beim Andern des Auto-Training Status', 'error');
                console.error(error);
            }
        }

        // Update Auto-Training Config
        async function updateAutoTrainingConfig() {
            const interval = document.getElementById('auto-interval').value;
            const scheduled_hour = parseInt(document.getElementById('auto-scheduled-hour').value) || 2;
            const scheduled_minute = parseInt(document.getElementById('auto-scheduled-minute').value) || 0;
            const timeframes = [];
            if (document.getElementById('auto-tf-5m').checked) timeframes.push('5m');
            if (document.getElementById('auto-tf-15m').checked) timeframes.push('15m');
            if (document.getElementById('auto-tf-30m').checked) timeframes.push('30m');
            if (document.getElementById('auto-tf-1h').checked) timeframes.push('1h');
            if (document.getElementById('auto-tf-4h').checked) timeframes.push('4h');
            if (document.getElementById('auto-tf-1d').checked) timeframes.push('1d');

            try {
                const response = await fetch(`${TRAIN_API_BASE}/auto-training/config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ interval, timeframes, scheduled_hour, scheduled_minute })
                });

                if (!response.ok) throw new Error('Failed to update config');

                showToast('Auto-Training Konfiguration aktualisiert');
                loadAutoTrainingStatus();

            } catch (error) {
                showToast('Fehler beim Speichern der Konfiguration', 'error');
                console.error(error);
            }
        }

        // Run Auto-Training Now
        async function runAutoTrainingNow() {
            const btn = document.getElementById('btn-run-now');
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner" style="width: 14px; height: 14px; border-width: 2px;"></span> Startet...';

            try {
                // Get selected timeframes
                const timeframes = [];
                if (document.getElementById('auto-tf-5m').checked) timeframes.push('5m');
                if (document.getElementById('auto-tf-15m').checked) timeframes.push('15m');
                if (document.getElementById('auto-tf-30m').checked) timeframes.push('30m');
                if (document.getElementById('auto-tf-1h').checked) timeframes.push('1h');
                if (document.getElementById('auto-tf-4h').checked) timeframes.push('4h');
                if (document.getElementById('auto-tf-1d').checked) timeframes.push('1d');

                const response = await fetch(`${TRAIN_API_BASE}/auto-training/run`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ timeframes })
                });

                if (!response.ok) {
                    const errData = await response.json();
                    throw new Error(errData.detail || 'Failed to start auto-training');
                }

                showToast('Auto-Training f√ºr alle Symbole gestartet');
                loadAutoTrainingStatus();
                loadTrainingStatus();

            } catch (error) {
                showToast('Fehler beim Starten des Auto-Trainings', 'error');
                console.error(error);
            } finally {
                btn.disabled = false;
                btn.innerHTML = '&#9889; Jetzt starten';
            }
        }

        // Add event listeners for config changes
        document.getElementById('auto-interval')?.addEventListener('change', updateAutoTrainingConfig);
        document.getElementById('auto-scheduled-hour')?.addEventListener('change', updateAutoTrainingConfig);
        document.getElementById('auto-scheduled-minute')?.addEventListener('change', updateAutoTrainingConfig);
        document.getElementById('auto-tf-5m')?.addEventListener('change', updateAutoTrainingConfig);
        document.getElementById('auto-tf-15m')?.addEventListener('change', updateAutoTrainingConfig);
        document.getElementById('auto-tf-30m')?.addEventListener('change', updateAutoTrainingConfig);
        document.getElementById('auto-tf-1h')?.addEventListener('change', updateAutoTrainingConfig);
        document.getElementById('auto-tf-4h')?.addEventListener('change', updateAutoTrainingConfig);
        document.getElementById('auto-tf-1d')?.addEventListener('change', updateAutoTrainingConfig);

        // Add event listeners for pattern history filters (apply on change)
        document.getElementById('history-symbol-filter')?.addEventListener('change', loadPatternHistory);
        document.getElementById('history-pattern-filter')?.addEventListener('change', loadPatternHistory);
        document.getElementById('history-timeframe-filter')?.addEventListener('change', loadPatternHistory);
        document.getElementById('history-category-filter')?.addEventListener('change', loadPatternHistory);
        document.getElementById('history-direction-filter')?.addEventListener('change', loadPatternHistory);
        document.getElementById('history-confidence-filter')?.addEventListener('change', loadPatternHistory);

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize Pattern Card Click Handlers for Pattern Detail Modal
            initPatternCardClickHandlers();

            // Load saved pattern filters before loading history
            loadPatternFilters();

            // Load Status Tab data (default tab)
            refreshStatusTab();

            loadInfo();
            loadAvailableSymbols();
            loadDetectionSymbols();
            loadAutoScanStatus();
            loadTrainingStatus();
            loadTrainingHistory();
            loadModels();
            loadAutoTrainingStatus();
            loadHistoryStats();
            loadPatternHistory();

            // Auto-refresh every 30 seconds
            setInterval(loadInfo, 30000);

            // Auto-refresh training status every 3 seconds
            setInterval(loadTrainingStatus, 3000);

            // Auto-refresh auto-training status every 10 seconds
            setInterval(loadAutoTrainingStatus, 10000);

            // Auto-refresh auto-scan status every 15 seconds
            setInterval(loadAutoScanStatus, 15000);

            // Auto-refresh pattern history every 60 seconds
            setInterval(() => {
                loadHistoryStats();
                loadPatternHistory();
            }, 60000);

            // Setup chart modal
            setupChartModal();
        });

        // =============================================================================
        // Pattern Modal Functions
        // =============================================================================

        // TCN Pattern SVG visualizations
        const tcnPatternSvgs = {
            'head_and_shoulders': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 70 L40 50 L55 70 L80 20 L105 70 L120 50 L150 70" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="10" y1="70" x2="150" y2="70" stroke="#ffc107" stroke-width="1" stroke-dasharray="4"/>
                <path d="M150 70 L180 85 L210 90" stroke="#ef5350" stroke-width="2" fill="none"/>
                <text x="80" y="15" fill="#64c8ff" font-size="8">Kopf</text>
                <text x="40" y="45" fill="#81c784" font-size="7">L.Schulter</text>
                <text x="105" y="45" fill="#81c784" font-size="7">R.Schulter</text>
                <text x="155" y="65" fill="#ffc107" font-size="7">Neckline</text>
            </svg>`,
            'inverse_head_and_shoulders': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 30 L40 50 L55 30 L80 80 L105 30 L120 50 L150 30" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="10" y1="30" x2="150" y2="30" stroke="#ffc107" stroke-width="1" stroke-dasharray="4"/>
                <path d="M150 30 L180 15 L210 10" stroke="#81c784" stroke-width="2" fill="none"/>
                <text x="80" y="90" fill="#64c8ff" font-size="8">Kopf</text>
                <text x="40" y="58" fill="#81c784" font-size="7">L.Schulter</text>
                <text x="105" y="58" fill="#81c784" font-size="7">R.Schulter</text>
            </svg>`,
            'double_top': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 70 L50 20 L90 55 L130 20 L170 55" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="50" y1="20" x2="130" y2="20" stroke="#ef5350" stroke-width="1" stroke-dasharray="3"/>
                <line x1="10" y1="55" x2="170" y2="55" stroke="#ffc107" stroke-width="1" stroke-dasharray="4"/>
                <path d="M170 55 L200 75 L230 85" stroke="#ef5350" stroke-width="2" fill="none"/>
                <text x="50" y="15" fill="#ef5350" font-size="8">Top 1</text>
                <text x="130" y="15" fill="#ef5350" font-size="8">Top 2</text>
                <text x="175" y="50" fill="#ffc107" font-size="7">Support</text>
            </svg>`,
            'double_bottom': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 30 L50 80 L90 45 L130 80 L170 45" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="50" y1="80" x2="130" y2="80" stroke="#81c784" stroke-width="1" stroke-dasharray="3"/>
                <line x1="10" y1="45" x2="170" y2="45" stroke="#ffc107" stroke-width="1" stroke-dasharray="4"/>
                <path d="M170 45 L200 25 L230 15" stroke="#81c784" stroke-width="2" fill="none"/>
                <text x="50" y="90" fill="#81c784" font-size="8">Bot 1</text>
                <text x="130" y="90" fill="#81c784" font-size="8">Bot 2</text>
                <text x="175" y="50" fill="#ffc107" font-size="7">Resistance</text>
            </svg>`,
            'triple_top': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 70 L35 20 L60 55 L90 20 L120 55 L150 20 L180 55" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="35" y1="20" x2="150" y2="20" stroke="#ef5350" stroke-width="1" stroke-dasharray="3"/>
                <line x1="10" y1="55" x2="180" y2="55" stroke="#ffc107" stroke-width="1" stroke-dasharray="4"/>
                <path d="M180 55 L210 75 L240 85" stroke="#ef5350" stroke-width="2" fill="none"/>
                <text x="90" y="15" fill="#ef5350" font-size="8">3x Widerstand</text>
            </svg>`,
            'triple_bottom': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 30 L35 80 L60 45 L90 80 L120 45 L150 80 L180 45" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="35" y1="80" x2="150" y2="80" stroke="#81c784" stroke-width="1" stroke-dasharray="3"/>
                <line x1="10" y1="45" x2="180" y2="45" stroke="#ffc107" stroke-width="1" stroke-dasharray="4"/>
                <path d="M180 45 L210 25 L240 15" stroke="#81c784" stroke-width="2" fill="none"/>
                <text x="90" y="92" fill="#81c784" font-size="8">3x Support</text>
            </svg>`,
            'ascending_triangle': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 80 L40 30 L60 70 L90 30 L110 60 L140 30 L160 50" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="40" y1="30" x2="160" y2="30" stroke="#ffc107" stroke-width="1.5"/>
                <line x1="10" y1="80" x2="160" y2="50" stroke="#81c784" stroke-width="1.5"/>
                <path d="M160 30 L190 15 L220 10" stroke="#81c784" stroke-width="2" fill="none"/>
                <text x="165" y="27" fill="#ffc107" font-size="7">Flat Resistance</text>
                <text x="85" y="75" fill="#81c784" font-size="7">Rising Support</text>
            </svg>`,
            'descending_triangle': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 20 L40 70 L60 30 L90 70 L110 40 L140 70 L160 50" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="40" y1="70" x2="160" y2="70" stroke="#ffc107" stroke-width="1.5"/>
                <line x1="10" y1="20" x2="160" y2="50" stroke="#ef5350" stroke-width="1.5"/>
                <path d="M160 70 L190 85 L220 90" stroke="#ef5350" stroke-width="2" fill="none"/>
                <text x="165" y="73" fill="#ffc107" font-size="7">Flat Support</text>
                <text x="85" y="25" fill="#ef5350" font-size="7">Falling Resistance</text>
            </svg>`,
            'symmetrical_triangle': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 50 L30 20 L50 70 L80 30 L100 60 L130 40 L150 55" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="30" y1="20" x2="150" y2="47" stroke="#a78bfa" stroke-width="1.5"/>
                <line x1="50" y1="70" x2="150" y2="53" stroke="#a78bfa" stroke-width="1.5"/>
                <path d="M150 47 L180 25 L210 15" stroke="#81c784" stroke-width="2" stroke-dasharray="4" fill="none"/>
                <path d="M150 53 L180 75 L210 85" stroke="#ef5350" stroke-width="2" stroke-dasharray="4" fill="none"/>
                <text x="155" y="20" fill="#81c784" font-size="7">Bullish?</text>
                <text x="155" y="88" fill="#ef5350" font-size="7">Bearish?</text>
            </svg>`,
            'rising_wedge': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 85 L40 60 L55 75 L90 40 L105 55 L140 25 L155 40" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="10" y1="85" x2="155" y2="40" stroke="#81c784" stroke-width="1.5"/>
                <line x1="40" y1="60" x2="155" y2="25" stroke="#ef5350" stroke-width="1.5"/>
                <path d="M155 40 L185 60 L215 75" stroke="#ef5350" stroke-width="2" fill="none"/>
                <text x="80" y="18" fill="#ef5350" font-size="8">Konvergierend</text>
            </svg>`,
            'falling_wedge': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 15 L40 40 L55 25 L90 60 L105 45 L140 75 L155 60" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="10" y1="15" x2="155" y2="60" stroke="#ef5350" stroke-width="1.5"/>
                <line x1="40" y1="40" x2="155" y2="75" stroke="#81c784" stroke-width="1.5"/>
                <path d="M155 60 L185 40 L215 25" stroke="#81c784" stroke-width="2" fill="none"/>
                <text x="80" y="88" fill="#81c784" font-size="8">Konvergierend</text>
            </svg>`,
            'bull_flag': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 90 L50 30" stroke="#81c784" stroke-width="3" fill="none"/>
                <path d="M50 30 L70 40 L85 35 L100 45 L115 40 L130 50" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="50" y1="30" x2="130" y2="50" stroke="#ffc107" stroke-width="1" stroke-dasharray="3"/>
                <line x1="70" y1="40" x2="130" y2="55" stroke="#ffc107" stroke-width="1" stroke-dasharray="3"/>
                <path d="M130 45 L170 15 L200 5" stroke="#81c784" stroke-width="2" fill="none"/>
                <text x="15" y="60" fill="#81c784" font-size="8">Flagpole</text>
                <text x="85" y="60" fill="#ffc107" font-size="7">Flag</text>
            </svg>`,
            'bear_flag': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 10 L50 70" stroke="#ef5350" stroke-width="3" fill="none"/>
                <path d="M50 70 L70 60 L85 65 L100 55 L115 60 L130 50" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="50" y1="70" x2="130" y2="50" stroke="#ffc107" stroke-width="1" stroke-dasharray="3"/>
                <line x1="70" y1="60" x2="130" y2="45" stroke="#ffc107" stroke-width="1" stroke-dasharray="3"/>
                <path d="M130 55 L170 85 L200 95" stroke="#ef5350" stroke-width="2" fill="none"/>
                <text x="15" y="40" fill="#ef5350" font-size="8">Flagpole</text>
                <text x="85" y="42" fill="#ffc107" font-size="7">Flag</text>
            </svg>`,
            'cup_and_handle': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 25 Q 20 25, 30 35 Q 60 85, 100 85 Q 140 85, 160 35 Q 170 25, 180 25" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <path d="M180 25 L190 35 L200 30 L210 38 L220 32" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="10" y1="25" x2="220" y2="25" stroke="#ffc107" stroke-width="1" stroke-dasharray="4"/>
                <path d="M220 28 L250 10" stroke="#81c784" stroke-width="2" fill="none"/>
                <text x="85" y="75" fill="#64c8ff" font-size="8">Cup</text>
                <text x="195" y="45" fill="#64c8ff" font-size="7">Handle</text>
            </svg>`,
            'channel_up': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 80 L40 60 L70 75 L100 55 L130 70 L160 50 L190 65 L220 45" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="10" y1="80" x2="220" y2="45" stroke="#81c784" stroke-width="1.5"/>
                <line x1="40" y1="55" x2="220" y2="25" stroke="#81c784" stroke-width="1.5"/>
                <path d="M220 45 L250 30" stroke="#81c784" stroke-width="2" fill="none"/>
                <text x="120" y="20" fill="#81c784" font-size="8">Aufw√§rtskanal</text>
            </svg>`,
            'channel_down': `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M10 20 L40 40 L70 25 L100 45 L130 30 L160 50 L190 35 L220 55" stroke="#64c8ff" stroke-width="2" fill="none"/>
                <line x1="10" y1="20" x2="220" y2="55" stroke="#ef5350" stroke-width="1.5"/>
                <line x1="40" y1="45" x2="220" y2="75" stroke="#ef5350" stroke-width="1.5"/>
                <path d="M220 55 L250 70" stroke="#ef5350" stroke-width="2" fill="none"/>
                <text x="120" y="85" fill="#ef5350" font-size="8">Abw√§rtskanal</text>
            </svg>`
        };

        // Get SVG for pattern type with fallback
        function getPatternSvg(patternType) {
            return tcnPatternSvgs[patternType] || `<svg viewBox="0 0 280 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <text x="140" y="50" fill="#888" font-size="10" text-anchor="middle">Pattern: ${patternType.replace(/_/g, ' ')}</text>
                <text x="140" y="65" fill="#666" font-size="8" text-anchor="middle">Keine Visualisierung verf√ºgbar</text>
            </svg>`;
        }

        // TCN Pattern descriptions
        const tcnPatternDescriptions = {
            'head_and_shoulders': {
                name: 'Head and Shoulders',
                description: 'Drei Gipfel, wobei der mittlere (Kopf) h√∂her ist als die beiden √§usseren (Schultern). Signalisiert das Ende eines Aufw√§rtstrends.',
                implication: 'Starkes b√§risches Umkehrsignal. Preisziel entspricht der Distanz vom Kopf zur Nackenlinie.'
            },
            'inverse_head_and_shoulders': {
                name: 'Inverse Head and Shoulders',
                description: 'Drei Tiefpunkte, wobei der mittlere tiefer ist als die beiden √§usseren. Signalisiert das Ende eines Abw√§rtstrends.',
                implication: 'Starkes bullisches Umkehrsignal. Preisziel entspricht der Distanz vom Kopf zur Nackenlinie.'
            },
            'double_top': {
                name: 'Double Top',
                description: 'Zwei aufeinanderfolgende Hochs auf √§hnlichem Preisniveau, getrennt durch ein Tal.',
                implication: 'B√§risches Umkehrsignal. Break unter die Unterst√ºtzung best√§tigt das Muster.'
            },
            'double_bottom': {
                name: 'Double Bottom',
                description: 'Zwei aufeinanderfolgende Tiefs auf √§hnlichem Preisniveau, getrennt durch einen Gipfel.',
                implication: 'Bullisches Umkehrsignal. Break √ºber den Widerstand best√§tigt das Muster.'
            },
            'triple_top': {
                name: 'Triple Top',
                description: 'Drei aufeinanderfolgende Hochs auf √§hnlichem Preisniveau.',
                implication: 'Starkes b√§risches Umkehrsignal, st√§rker als Double Top.'
            },
            'triple_bottom': {
                name: 'Triple Bottom',
                description: 'Drei aufeinanderfolgende Tiefs auf √§hnlichem Preisniveau.',
                implication: 'Starkes bullisches Umkehrsignal, st√§rker als Double Bottom.'
            },
            'ascending_triangle': {
                name: 'Ascending Triangle',
                description: 'Horizontale Widerstandslinie mit aufsteigender Unterst√ºtzungslinie. H√∂here Tiefs zeigen zunehmenden Kaufdruck.',
                implication: 'Bullisches Fortsetzungsmuster. Ausbruch nach oben wahrscheinlich.'
            },
            'descending_triangle': {
                name: 'Descending Triangle',
                description: 'Horizontale Unterst√ºtzungslinie mit absteigender Widerstandslinie. Tiefere Hochs zeigen zunehmenden Verkaufsdruck.',
                implication: 'B√§risches Fortsetzungsmuster. Ausbruch nach unten wahrscheinlich.'
            },
            'symmetrical_triangle': {
                name: 'Symmetrical Triangle',
                description: 'Konvergierende Trend-Linien mit tieferen Hochs und h√∂heren Tiefs. Zeigt Konsolidierung.',
                implication: 'Neutrales Muster. Ausbruchsrichtung bestimmt den Trend.'
            },
            'bull_flag': {
                name: 'Bull Flag',
                description: 'Starke Aufw√§rtsbewegung gefolgt von paralleler Konsolidierung nach unten.',
                implication: 'Bullisches Fortsetzungsmuster. Erwarteter Ausbruch nach oben.'
            },
            'bear_flag': {
                name: 'Bear Flag',
                description: 'Starke Abw√§rtsbewegung gefolgt von paralleler Konsolidierung nach oben.',
                implication: 'B√§risches Fortsetzungsmuster. Erwarteter Ausbruch nach unten.'
            },
            'cup_and_handle': {
                name: 'Cup and Handle',
                description: 'U-f√∂rmige Rundung (Tasse) gefolgt von kleiner Abw√§rtskonsolidierung (Henkel).',
                implication: 'Bullisches Fortsetzungsmuster. Ausbruch √ºber den Henkel-Widerstand erwartet.'
            },
            'falling_wedge': {
                name: 'Falling Wedge',
                description: 'Konvergierende Trendlinien, beide nach unten gerichtet. Preis macht tiefere Hochs und tiefere Tiefs.',
                implication: 'Bullisches Umkehrmuster (im Abw√§rtstrend) oder Fortsetzung (im Aufw√§rtstrend).'
            },
            'rising_wedge': {
                name: 'Rising Wedge',
                description: 'Konvergierende Trendlinien, beide nach oben gerichtet. Preis macht h√∂here Hochs und h√∂here Tiefs.',
                implication: 'B√§risches Umkehrmuster (im Aufw√§rtstrend) oder Fortsetzung (im Abw√§rtstrend).'
            },
            'channel_up': {
                name: 'Channel Up',
                description: 'Parallele aufsteigende Trendlinien. Preis bewegt sich zwischen Unterst√ºtzung und Widerstand.',
                implication: 'Bullischer Trend. Long bei Unterst√ºtzung, Vorsicht bei Widerstand.'
            },
            'channel_down': {
                name: 'Channel Down',
                description: 'Parallele absteigende Trendlinien. Preis bewegt sich zwischen Unterst√ºtzung und Widerstand.',
                implication: 'B√§rischer Trend. Short bei Widerstand, Vorsicht bei Unterst√ºtzung.'
            }
        };

        // Get pattern info with fallback
        function getTcnPatternInfo(patternType) {
            return tcnPatternDescriptions[patternType] || {
                name: patternType.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' '),
                description: 'TCN-erkanntes Chart-Muster.',
                implication: 'Richtung und St√§rke beachten f√ºr Trading-Entscheidung.'
            };
        }

        // Format price for display
        function formatPrice(price) {
            if (price >= 1000) return price.toFixed(0);
            if (price >= 1) return price.toFixed(2);
            return price.toFixed(5);
        }

        // Draw candlestick chart using Canvas
        function drawCandlestickChart(canvasId, candles, patternIndex) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const container = canvas.parentElement;

            // Set canvas size
            canvas.width = container.clientWidth - 20;
            canvas.height = container.clientHeight - 20;

            const width = canvas.width;
            const height = canvas.height;
            const padding = { top: 20, right: 60, bottom: 30, left: 10 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            if (!candles || candles.length === 0) {
                ctx.fillStyle = '#888';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Keine Daten verf√ºgbar', width / 2, height / 2);
                return;
            }

            // Calculate price range
            const prices = candles.flatMap(c => [c.high, c.low]);
            const minPrice = Math.min(...prices);
            const maxPrice = Math.max(...prices);
            const priceRange = maxPrice - minPrice || 1;
            const pricePadding = priceRange * 0.1;

            const scaledMinPrice = minPrice - pricePadding;
            const scaledMaxPrice = maxPrice + pricePadding;
            const scaledRange = scaledMaxPrice - scaledMinPrice;

            // Calculate candle dimensions
            const candleWidth = Math.max(4, Math.min(20, (chartWidth / candles.length) * 0.7));
            const candleSpacing = chartWidth / candles.length;

            // Helper to convert price to Y coordinate
            const priceToY = (price) => {
                return padding.top + chartHeight - ((price - scaledMinPrice) / scaledRange * chartHeight);
            };

            // Draw grid lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            const gridLines = 5;
            for (let i = 0; i <= gridLines; i++) {
                const y = padding.top + (chartHeight / gridLines) * i;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(width - padding.right, y);
                ctx.stroke();

                // Price labels
                const price = scaledMaxPrice - (scaledRange / gridLines) * i;
                ctx.fillStyle = '#888';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(formatPrice(price), width - padding.right + 5, y + 3);
            }

            // Draw candles
            candles.forEach((candle, i) => {
                const x = padding.left + (i + 0.5) * candleSpacing;
                const isPattern = i === patternIndex;

                const openY = priceToY(candle.open);
                const closeY = priceToY(candle.close);
                const highY = priceToY(candle.high);
                const lowY = priceToY(candle.low);

                const isBullish = candle.close >= candle.open;
                const bodyTop = Math.min(openY, closeY);
                const bodyHeight = Math.max(1, Math.abs(closeY - openY));

                // Highlight pattern candle background
                if (isPattern) {
                    ctx.fillStyle = 'rgba(255, 193, 7, 0.15)';
                    ctx.fillRect(x - candleSpacing / 2, padding.top, candleSpacing, chartHeight);
                }

                // Draw wick
                ctx.strokeStyle = isBullish ? '#81c784' : '#e57373';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, highY);
                ctx.lineTo(x, lowY);
                ctx.stroke();

                // Draw body
                ctx.fillStyle = isBullish ? '#81c784' : '#e57373';
                ctx.fillRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);

                // Draw body outline
                ctx.strokeStyle = isBullish ? '#4caf50' : '#f44336';
                ctx.lineWidth = 1;
                ctx.strokeRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);

                // Pattern marker
                if (isPattern) {
                    ctx.strokeStyle = '#ffc107';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 2]);
                    ctx.strokeRect(x - candleWidth / 2 - 3, highY - 5, candleWidth + 6, lowY - highY + 10);
                    ctx.setLineDash([]);

                    // Arrow pointing to pattern
                    ctx.fillStyle = '#ffc107';
                    ctx.font = 'bold 12px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('‚ñº', x, padding.top - 5);
                }

                // Time labels (show every few candles)
                if (i === 0 || i === candles.length - 1 || i === patternIndex) {
                    const time = new Date(candle.timestamp);
                    const timeStr = time.toLocaleTimeString('de-CH', { hour: '2-digit', minute: '2-digit' });
                    ctx.fillStyle = i === patternIndex ? '#ffc107' : '#666';
                    ctx.font = '9px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(timeStr, x, height - 5);
                }
            });

            // Draw legend
            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Pattern-Kerze markiert (gelb)', padding.left, height - 5);
        }

        // Store current pattern data for navigation and feedback
        let currentTcnPatternIndex = 0;
        let tcnPatternList = [];
        let currentTcnPatternData = null;
        let currentPatternOhlcData = null; // Store OHLC data for zoom modal

        // Show pattern modal with real chart and pattern overlay
        async function showPatternChart(symbol, timeframe, timestamp, patternType, direction, patternData, patternIndex = -1) {
            const modal = document.getElementById('chartModal');
            const chartContainer = document.getElementById('patternChartContainer');
            const svgContainer = document.getElementById('patternSvgContainer');
            const loadingEl = document.getElementById('chartLoading');
            const referenceContainer = document.getElementById('referencePatternContainer');

            // Store current pattern data for feedback
            currentTcnPatternData = {
                symbol, timeframe, timestamp, patternType, direction, patternData
            };

            // Update navigation index
            if (patternIndex >= 0) {
                currentTcnPatternIndex = patternIndex;
            }

            // Extract pattern_points from full pattern data (backward compatible)
            let patternPoints = patternData && patternData.pattern_points ? patternData.pattern_points : patternData;
            // Pattern history uses pattern_start_time/pattern_end_time, detection API uses start_time/end_time
            const startTime = patternData && (patternData.pattern_start_time || patternData.start_time) ? (patternData.pattern_start_time || patternData.start_time) : null;
            const endTime = patternData && (patternData.pattern_end_time || patternData.end_time) ? (patternData.pattern_end_time || patternData.end_time) : null;
            const confidence = patternData && patternData.confidence ? patternData.confidence : 0;

            // Get pattern info
            const info = getTcnPatternInfo(patternType);

            // Generate Pattern-ID
            const patternId = `${symbol}_${timeframe}_${patternType}_${timestamp}`;
            document.getElementById('chartPatternId').textContent = patternId;

            // Set title and badges
            document.getElementById('chartModalTitle').textContent = info.name;
            document.getElementById('chartModalBadges').innerHTML = `
                <span class="pattern-badge ${direction}">${direction === 'bullish' ? 'BULLISH' : direction === 'bearish' ? 'BEARISH' : 'NEUTRAL'}</span>
            `;

            // Set description with implication
            document.getElementById('chartPatternDescription').innerHTML = `
                ${info.description}<br><br>
                <strong style="color: ${direction === 'bullish' ? '#81c784' : direction === 'bearish' ? '#ef5350' : '#ffc107'};">Trading-Implikation:</strong> ${info.implication}
            `;

            // Update info grid
            document.getElementById('chartSymbol').textContent = symbol;
            document.getElementById('chartTimeframe').textContent = timeframe;
            // Show pattern time range (start - end) instead of single timestamp
            if (startTime && endTime) {
                const startFormatted = formatLocalDateTime(startTime, { day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit' });
                const endFormatted = formatLocalDateTime(endTime, { day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit' });
                document.getElementById('chartPatternTime').textContent = `${startFormatted} - ${endFormatted}`;
            } else {
                document.getElementById('chartPatternTime').textContent = formatLocalDateTime(timestamp, { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' });
            }
            document.getElementById('chartConfidence').textContent = `${(confidence * 100).toFixed(0)}%`;

            // Hidden fields for backward compatibility
            document.getElementById('chartPatternType').textContent = info.name;
            document.getElementById('chartPatternStart').textContent = startTime ? formatLocalDateTime(startTime, { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' }) : '-';
            document.getElementById('chartPatternEnd').textContent = endTime ? formatLocalDateTime(endTime, { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' }) : '-';

            // Show reference SVG pattern
            const svg = getPatternSvg(patternType);
            referenceContainer.innerHTML = `
                <div style="text-align: center; width: 100%;">
                    <div style="max-width: 280px; margin: 0 auto;">${svg}</div>
                    <div style="font-size: 0.75rem; color: #888; margin-top: 0.5rem;">${info.name}</div>
                </div>
            `;

            // Update navigation counter
            updateTcnNavigationCounter();

            // Reset feedback result
            document.getElementById('tcnFeedbackResult').style.display = 'none';
            document.getElementById('claudeValidationResult').style.display = 'none';

            // Show loading state
            if (loadingEl) loadingEl.style.display = 'flex';
            chartContainer.style.display = 'none';
            svgContainer.style.display = 'none';

            // Show modal
            modal.classList.add('show');

            try {
                let allCandles = [];
                let dataSource = 'unknown';

                // Check if OHLCV data is stored with pattern history (retrospective analysis)
                if (patternData && patternData.ohlcv_data && patternData.ohlcv_data.length > 0) {
                    console.log(`[TCN Chart] Using stored OHLCV data (${patternData.ohlcv_data.length} candles)`);
                    const originalLength = patternData.ohlcv_data.length;
                    allCandles = patternData.ohlcv_data.map(c => ({
                        timestamp: c.timestamp,
                        open: parseFloat(c.open),
                        high: parseFloat(c.high),
                        low: parseFloat(c.low),
                        close: parseFloat(c.close),
                        volume: c.volume ? parseFloat(c.volume) : 0
                    })).filter(c => c.open > 0 && c.high > 0 && c.low > 0 && c.close > 0);

                    // Check if data is stored newest-first (need to reverse)
                    const isNewestFirst = allCandles.length > 1 &&
                        new Date(allCandles[0].timestamp) > new Date(allCandles[allCandles.length - 1].timestamp);

                    if (isNewestFirst) {
                        console.log(`[TCN Chart] Data is newest-first, reversing to chronological order`);
                        allCandles.reverse();

                        // Also need to transform pattern_points indices since they refer to newest-first order
                        // Index i in newest-first = Index (originalLength - 1 - i) in oldest-first
                        if (patternPoints && patternPoints.length > 0) {
                            patternPoints = patternPoints.map(p => ({
                                ...p,
                                index: originalLength - 1 - p.index
                            }));
                            console.log(`[TCN Chart] Transformed pattern points:`, patternPoints.map(p => p.index));
                        }
                    }

                    dataSource = 'Stored (Pattern History)';
                } else {
                    // No stored OHLCV data - fetch from API
                    console.log(`[TCN Chart] No stored OHLCV data, fetching from API...`);

                    // Convert timeframe to TwelveData interval format (H1 -> 1h, M5 -> 5min, D1 -> 1day)
                    const intervalMap = {
                        'M1': '1min', 'M5': '5min', 'M15': '15min', 'M30': '30min',
                        'H1': '1h', 'H2': '2h', 'H4': '4h',
                        'D1': '1day', 'W1': '1week', 'MN': '1month',
                        '5m': '5min', '15m': '15min', '30m': '30min',
                        '1h': '1h', '4h': '4h', '1d': '1day'
                    };
                    const interval = intervalMap[timeframe] || '1h';

                    // Calculate how many hours/days per candle based on timeframe
                    const timeframeHours = {
                        '1min': 1/60, '5min': 5/60, '15min': 15/60, '30min': 30/60,
                        '1h': 1, '2h': 2, '4h': 4,
                        '1day': 24, '1week': 168, '1month': 720
                    };
                    const hoursPerCandle = timeframeHours[interval] || 1;

                    // Use pattern_start_time and pattern_end_time if available (historical patterns)
                    // Otherwise fall back to timestamp (detection time)
                    const candlesBefore = 5;  // Context before pattern
                    const candlesAfter = 5;   // Context after pattern

                    let startDate, endDate;
                    console.log(`[TCN Chart] patternData:`, patternData);
                    console.log(`[TCN Chart] startTime=${startTime}, endTime=${endTime}`);

                    if (startTime && endTime) {
                        // Historical pattern with defined time range
                        const patternStartDate = new Date(startTime);
                        const patternEndDate = new Date(endTime);
                        // Add buffer before start and after end
                        startDate = new Date(patternStartDate.getTime() - candlesBefore * hoursPerCandle * 60 * 60 * 1000);
                        endDate = new Date(patternEndDate.getTime() + candlesAfter * hoursPerCandle * 60 * 60 * 1000);
                        console.log(`[TCN Chart] Using pattern time range: ${startTime} to ${endTime}`);
                    } else {
                        // Fallback: use detection timestamp
                        const patternDate = new Date(timestamp);
                        startDate = new Date(patternDate.getTime() - 25 * hoursPerCandle * 60 * 60 * 1000);
                        endDate = new Date(patternDate.getTime() + candlesAfter * hoursPerCandle * 60 * 60 * 1000);
                        console.log(`[TCN Chart] Using detection timestamp: ${timestamp}`);
                    }

                    // Format dates as YYYY-MM-DD HH:mm:ss for TwelveData
                    const formatDate = (d) => {
                        const year = d.getUTCFullYear();
                        const month = String(d.getUTCMonth() + 1).padStart(2, '0');
                        const day = String(d.getUTCDate()).padStart(2, '0');
                        const hours = String(d.getUTCHours()).padStart(2, '0');
                        const mins = String(d.getUTCMinutes()).padStart(2, '0');
                        return `${year}-${month}-${day} ${hours}:${mins}:00`;
                    };

                    const startDateStr = formatDate(startDate);
                    const endDateStr = formatDate(endDate);

                    console.log(`Fetching OHLC for ${symbol} from ${startDateStr} to ${endDateStr} (pattern at ${timestamp})`);

                    // Try TwelveData first
                    try {
                        const ohlcResponse = await fetch(`/data/api/v1/twelvedata/time_series/${symbol}?interval=${interval}&start_date=${encodeURIComponent(startDateStr)}&end_date=${encodeURIComponent(endDateStr)}&outputsize=100`);

                        if (ohlcResponse.ok) {
                            const ohlcData = await ohlcResponse.json();

                            // Check for unsupported symbol or error
                            if (!ohlcData.unsupported && !ohlcData.error && !ohlcData.detail && ohlcData.status !== 'error') {
                                const rawCandles = ohlcData.values || ohlcData.candles || ohlcData.data || ohlcData;
                                if (rawCandles && rawCandles.length > 0) {
                                    allCandles = rawCandles.map(c => ({
                                        timestamp: c.datetime,
                                        open: parseFloat(c.open),
                                        high: parseFloat(c.high),
                                        low: parseFloat(c.low),
                                        close: parseFloat(c.close),
                                        volume: c.volume ? parseFloat(c.volume) : 0
                                    })).reverse();
                                    dataSource = 'TwelveData';
                                }
                            }
                        }
                    } catch (e) {
                        console.log('TwelveData failed, trying EasyInsight fallback...', e.message);
                    }

                    // Fallback to EasyInsight if TwelveData failed or returned no data
                    if (allCandles.length === 0) {
                        console.log(`TwelveData unavailable for ${symbol}, trying EasyInsight...`);

                        // Map interval to EasyInsight format
                        const easyInsightIntervalMap = {
                            '1min': 'm1', '5min': 'm5', '15min': 'm15', '30min': 'm30',
                            '1h': 'h1', '2h': 'h2', '4h': 'h4',
                            '1day': 'd1', '1week': 'w1', '1month': 'mn'
                        };
                        const eiInterval = easyInsightIntervalMap[interval] || 'h1';

                        try {
                            const eiResponse = await fetch(`/data/api/v1/easyinsight/ohlcv/${symbol}?interval=${eiInterval}&limit=100`);
                            if (eiResponse.ok) {
                                const eiData = await eiResponse.json();
                                const eiCandles = eiData.data || eiData.values || [];

                                if (eiCandles && eiCandles.length > 0) {
                                    // EasyInsight format has h1_open, h1_high, etc. - extract based on timeframe
                                    const tfPrefix = eiInterval.toLowerCase();
                                    allCandles = eiCandles.map(c => {
                                        // Try timeframe-specific fields first, then generic
                                        const open = c[`${tfPrefix}_open`] || c.open || c.h1_open || 0;
                                        const high = c[`${tfPrefix}_high`] || c.high || c.h1_high || 0;
                                        const low = c[`${tfPrefix}_low`] || c.low || c.h1_low || 0;
                                        const close = c[`${tfPrefix}_close`] || c.close || c.h1_close || 0;
                                        const timestamp = c.import_time || c.datetime || c.timestamp || new Date().toISOString();
                                        return {
                                            timestamp: timestamp,
                                            open: parseFloat(open),
                                            high: parseFloat(high),
                                            low: parseFloat(low),
                                            close: parseFloat(close),
                                            volume: c.volume || 0
                                        };
                                    }).filter(c => c.open > 0 && c.high > 0 && c.low > 0 && c.close > 0);

                                    // EasyInsight might return newest first, reverse if needed
                                    if (allCandles.length > 1) {
                                        const first = new Date(allCandles[0].timestamp);
                                        const last = new Date(allCandles[allCandles.length - 1].timestamp);
                                        if (first > last) {
                                            allCandles.reverse();
                                        }
                                    }
                                    dataSource = 'EasyInsight';
                                }
                            }
                        } catch (e) {
                            console.error('EasyInsight fallback also failed:', e.message);
                        }
                    }
                }

                if (allCandles.length === 0) {
                    throw new Error('Keine Candlestick-Daten verf√ºgbar (Symbol nicht unterst√ºtzt)');
                }

                console.log(`Loaded ${allCandles.length} candles from ${dataSource}`);

                // For historical patterns, we've loaded exactly the right time range
                // Use all loaded candles (they already have context before/after)
                const candles = allCandles;

                console.log(`[TCN Chart] Using all ${candles.length} candles (pattern time range already applied)`);

                // Store OHLC data for zoom modal
                currentPatternOhlcData = candles;

                // Hide loading, show chart
                if (loadingEl) loadingEl.style.display = 'none';
                chartContainer.style.display = 'block';

                // Draw the chart with pattern overlay
                drawCandlestickChartWithPattern('patternCanvas', candles, patternType, patternPoints, timestamp);

            } catch (error) {
                console.error('[TCN Chart] Fehler beim Laden des Charts:', error);
                console.error('[TCN Chart] Error stack:', error.stack);
                // Clear OHLC data on error
                currentPatternOhlcData = null;
                // Fall back to SVG visualization with error message
                if (loadingEl) loadingEl.style.display = 'none';
                chartContainer.style.display = 'none';
                svgContainer.style.display = 'flex';
                svgContainer.innerHTML = `
                    <div style="text-align: center; width: 100%;">
                        ${getPatternSvg(patternType)}
                        <p style="color: #888; font-size: 11px; margin-top: 10px;">
                            Historische Chart-Daten nicht verf√ºgbar<br>
                            <span style="color: #666;">(${error.message})</span>
                        </p>
                    </div>
                `;
            }
        }

        // Update navigation counter
        function updateTcnNavigationCounter() {
            const counter = document.getElementById('modalNavCounter');
            const prevBtn = document.getElementById('modalPrevBtn');
            const nextBtn = document.getElementById('modalNextBtn');

            if (tcnPatternList.length > 0) {
                counter.textContent = `${currentTcnPatternIndex + 1} / ${tcnPatternList.length}`;
                prevBtn.disabled = currentTcnPatternIndex === 0;
                nextBtn.disabled = currentTcnPatternIndex >= tcnPatternList.length - 1;
            } else {
                counter.textContent = '1 / 1';
                prevBtn.disabled = true;
                nextBtn.disabled = true;
            }
        }

        // Navigate between patterns
        function navigateTcnPattern(delta) {
            const newIndex = currentTcnPatternIndex + delta;
            if (newIndex >= 0 && newIndex < tcnPatternList.length) {
                const p = tcnPatternList[newIndex];
                showPatternChart(p.symbol, p.timeframe, p.detected_at || p.timestamp, p.pattern_type || p.type, p.direction, p, newIndex);
            }
        }

        // Copy Pattern ID to clipboard
        function copyPatternId() {
            const patternId = document.getElementById('chartPatternId').textContent;
            if (navigator.clipboard) {
                navigator.clipboard.writeText(patternId).then(() => {
                    showToast('Pattern-ID kopiert: ' + patternId.slice(-20));
                }).catch(() => {
                    fallbackCopyToClipboard(patternId);
                });
            } else {
                fallbackCopyToClipboard(patternId);
            }
        }

        function fallbackCopyToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            showToast('Pattern-ID kopiert');
        }

        function showToast(message) {
            const toast = document.createElement('div');
            toast.textContent = message;
            toast.style.cssText = 'position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: #333; color: #fff; padding: 0.75rem 1.5rem; border-radius: 8px; z-index: 10001; font-size: 0.9rem;';
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
        }

        // Feedback functions
        function confirmTcnPattern() {
            showTcnFeedback('success', '‚úì Pattern als korrekt markiert');
            // TODO: Send feedback to backend when TCN feedback API is available
        }

        function rejectTcnPattern() {
            showTcnFeedback('warning', '‚úó Pattern als falsch markiert');
            // TODO: Send feedback to backend when TCN feedback API is available
        }

        function markNoPattern() {
            showTcnFeedback('info', '‚úó Kein Pattern erkennbar markiert');
            // TODO: Send feedback to backend when TCN feedback API is available
        }

        function showTcnFeedback(type, message) {
            const resultEl = document.getElementById('tcnFeedbackResult');
            const colors = {
                success: '#81c784',
                warning: '#ffb74d',
                info: '#64b5f6'
            };
            resultEl.style.color = colors[type] || '#fff';
            resultEl.textContent = message;
            resultEl.style.display = 'block';
        }

        // Claude Vision Validation
        async function validateWithClaude() {
            const resultEl = document.getElementById('claudeValidationResult');
            const btn = document.getElementById('btnClaudeValidate');

            if (!currentTcnPatternData || !currentTcnPatternData.patternData) {
                showClaudeValidationResult('error', '‚ùå Keine Pattern-Daten verf√ºgbar');
                return;
            }

            const patternData = currentTcnPatternData.patternData;
            const patternId = patternData.id;

            if (!patternId) {
                showClaudeValidationResult('error', '‚ùå Keine Pattern-ID gefunden');
                return;
            }

            // Check if OHLCV data is available
            if (!patternData.ohlcv_data || patternData.ohlcv_data.length === 0) {
                showClaudeValidationResult('warning', '‚ö†Ô∏è Keine OHLCV-Daten gespeichert. Claude-Validierung nur f√ºr Pattern mit gespeicherten OHLC-Daten verf√ºgbar.');
                return;
            }

            // Show loading state
            btn.disabled = true;
            btn.innerHTML = '‚è≥ Validiere...';
            resultEl.style.display = 'block';
            resultEl.innerHTML = '<span style="color: #a855f7;">‚è≥ Claude analysiert das Pattern...</span>';

            try {
                const response = await fetch(`${API_BASE}/claude/validate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        pattern_id: patternId,
                        force: false
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.detail || `HTTP ${response.status}`);
                }

                const data = await response.json();
                const validation = data.validation;

                if (validation.status === 'skipped') {
                    showClaudeValidationResult('warning', `‚ö†Ô∏è ${validation.claude_reasoning}`);
                } else if (validation.status === 'error') {
                    showClaudeValidationResult('error', `‚ùå Fehler: ${validation.error_message || validation.claude_reasoning}`);
                } else {
                    // Show validation result
                    const agrees = validation.claude_agrees;
                    const confidence = (validation.claude_confidence * 100).toFixed(0);
                    const visualQuality = (validation.visual_quality_score * 100).toFixed(0);
                    const reasoning = validation.claude_reasoning;

                    const color = agrees ? '#81c784' : '#ef5350';
                    const icon = agrees ? '‚úì' : '‚úó';
                    const status = agrees ? 'BEST√ÑTIGT' : 'ABGELEHNT';

                    resultEl.innerHTML = `
                        <div style="padding: 0.75rem; background: rgba(${agrees ? '129, 199, 132' : '239, 83, 80'}, 0.1); border: 1px solid ${color}; border-radius: 8px;">
                            <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                <span style="font-size: 1.2rem; color: ${color};">${icon}</span>
                                <strong style="color: ${color};">Claude ${status}</strong>
                                <span style="color: #888; font-size: 0.8rem;">(Konfidenz: ${confidence}%)</span>
                            </div>
                            <div style="font-size: 0.85rem; color: #ccc; margin-bottom: 0.5rem;">
                                ${reasoning}
                            </div>
                            <div style="display: flex; gap: 1rem; font-size: 0.75rem; color: #888;">
                                <span>Visuelle Qualit√§t: ${visualQuality}%</span>
                                <span>Marktkontext: ${(validation.market_context_score * 100).toFixed(0)}%</span>
                            </div>
                        </div>
                    `;
                    resultEl.style.display = 'block';
                }

            } catch (error) {
                console.error('Claude validation error:', error);
                showClaudeValidationResult('error', `‚ùå Validierung fehlgeschlagen: ${error.message}`);
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'ü§ñ Claude pr√ºfen';
            }
        }

        function showClaudeValidationResult(type, message) {
            const resultEl = document.getElementById('claudeValidationResult');
            const colors = {
                success: '#81c784',
                warning: '#ffb74d',
                error: '#ef5350',
                info: '#64b5f6'
            };
            resultEl.style.color = colors[type] || '#fff';
            resultEl.innerHTML = message;
            resultEl.style.display = 'block';
        }

        // Get interval in minutes
        function getIntervalMinutes(timeframe) {
            const mapping = {
                'M1': 1, 'M5': 5, 'M15': 15, 'M30': 30,
                'H1': 60, 'H4': 240, 'D1': 1440, 'W1': 10080
            };
            return mapping[timeframe] || 60;
        }

        // Draw candlestick chart with pattern overlay
        function drawCandlestickChartWithPattern(canvasId, candles, patternType, patternPoints, patternTimestamp) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const container = canvas.parentElement;

            // Set canvas size
            canvas.width = container.clientWidth - 20;
            canvas.height = 320;

            const width = canvas.width;
            const height = canvas.height;
            const padding = { top: 30, right: 70, bottom: 45, left: 20 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            if (!candles || candles.length === 0) {
                ctx.fillStyle = '#888';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Keine Daten verf√ºgbar', width / 2, height / 2);
                return;
            }

            // Calculate price range - include pattern points in the range for proper scaling
            const candlePrices = candles.flatMap(c => [c.high, c.low]);
            const patternPrices = (patternPoints && patternPoints.length > 0)
                ? patternPoints.map(p => p.price)
                : [];
            const allPrices = [...candlePrices, ...patternPrices];

            const minPrice = Math.min(...allPrices);
            const maxPrice = Math.max(...allPrices);
            const priceRange = maxPrice - minPrice || 1;
            const pricePadding = priceRange * 0.1;

            const scaledMinPrice = minPrice - pricePadding;
            const scaledMaxPrice = maxPrice + pricePadding;
            const scaledRange = scaledMaxPrice - scaledMinPrice;

            // Calculate candle dimensions
            const candleWidth = Math.max(3, Math.min(15, (chartWidth / candles.length) * 0.65));
            const candleSpacing = chartWidth / candles.length;

            // Helper to convert price to Y coordinate
            const priceToY = (price) => {
                return padding.top + chartHeight - ((price - scaledMinPrice) / scaledRange * chartHeight);
            };

            // Helper to convert index to X coordinate
            const indexToX = (idx) => {
                return padding.left + (idx + 0.5) * candleSpacing;
            };

            // Determine pattern range from pattern_points indices
            // The indices in pattern_points refer to the original 200-candle array (oldest=0, newest=199)
            let patternStartIdx = 0;
            let patternEndIdx = candles.length - 1;

            if (patternPoints && patternPoints.length > 0) {
                // Get min and max index from pattern points
                const pointIndices = patternPoints.map(p => p.index).filter(i => typeof i === 'number');
                if (pointIndices.length > 0) {
                    patternStartIdx = Math.min(...pointIndices);
                    patternEndIdx = Math.max(...pointIndices);
                }
            }

            // Ensure bounds are valid for the displayed candles
            patternStartIdx = Math.max(0, Math.min(patternStartIdx, candles.length - 1));
            patternEndIdx = Math.max(patternStartIdx, Math.min(patternEndIdx, candles.length - 1));

            console.log(`[TCN Chart] Pattern zone: candles ${patternStartIdx} to ${patternEndIdx} of ${candles.length}`);

            // Draw pattern zone background (highlighting pattern formation period)
            if (patternPoints && patternPoints.length > 0) {
                const startX = indexToX(patternStartIdx) - candleSpacing / 2;
                const endX = indexToX(patternEndIdx) + candleSpacing / 2;

                // Pattern zone fill - more visible
                ctx.fillStyle = 'rgba(255, 193, 7, 0.15)';
                ctx.fillRect(startX, padding.top, endX - startX, chartHeight);

                // Pattern zone border - solid lines
                ctx.strokeStyle = '#ffc107';
                ctx.lineWidth = 2;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(startX, padding.top);
                ctx.lineTo(startX, padding.top + chartHeight);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(endX, padding.top);
                ctx.lineTo(endX, padding.top + chartHeight);
                ctx.stroke();

                // Pattern zone label at top with background
                const labelText = 'Pattern-Formation';
                ctx.font = 'bold 10px sans-serif';
                const labelX = (startX + endX) / 2;
                const labelWidth = ctx.measureText(labelText).width + 10;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(labelX - labelWidth / 2, padding.top + 3, labelWidth, 16);
                ctx.fillStyle = '#ffc107';
                ctx.textAlign = 'center';
                ctx.fillText(labelText, labelX, padding.top + 15);

                // Start/End markers with arrows
                ctx.font = 'bold 9px sans-serif';
                ctx.fillStyle = '#ffc107';
                ctx.textAlign = 'center';
                // Start arrow and label
                ctx.fillText('‚ñº', startX, padding.top + 32);
                ctx.fillText('Start', startX, padding.top + 44);
                // End arrow and label
                ctx.fillText('‚ñº', endX, padding.top + 32);
                ctx.fillText('Ende', endX, padding.top + 44);
            }

            // Draw grid lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
            ctx.lineWidth = 1;
            const gridLines = 5;
            for (let i = 0; i <= gridLines; i++) {
                const y = padding.top + (chartHeight / gridLines) * i;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(width - padding.right, y);
                ctx.stroke();

                // Price labels on Y-axis
                const price = scaledMaxPrice - (scaledRange / gridLines) * i;
                ctx.fillStyle = '#aaa';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(formatPrice(price), width - padding.right + 5, y + 3);
            }

            // Y-axis label (Preis)
            ctx.save();
            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.translate(width - 8, padding.top + chartHeight / 2);
            ctx.rotate(Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText('Preis', 0, 0);
            ctx.restore();

            // Draw candles
            candles.forEach((candle, i) => {
                const x = indexToX(i);
                const openY = priceToY(candle.open);
                const closeY = priceToY(candle.close);
                const highY = priceToY(candle.high);
                const lowY = priceToY(candle.low);

                const isBullish = candle.close >= candle.open;
                const bodyTop = Math.min(openY, closeY);
                const bodyHeight = Math.max(1, Math.abs(closeY - openY));

                // Draw wick
                ctx.strokeStyle = isBullish ? '#4caf50' : '#f44336';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, highY);
                ctx.lineTo(x, lowY);
                ctx.stroke();

                // Draw body
                ctx.fillStyle = isBullish ? '#81c784' : '#e57373';
                ctx.fillRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);

                // Draw body outline
                ctx.strokeStyle = isBullish ? '#4caf50' : '#f44336';
                ctx.lineWidth = 1;
                ctx.strokeRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
            });

            // Draw pattern overlay lines based on pattern_points
            if (patternPoints && patternPoints.length > 0) {
                drawPatternOverlay(ctx, candles, patternPoints, patternType, indexToX, priceToY, padding, chartHeight);
            }

            // X-axis with time labels
            const numTimeLabels = Math.min(6, candles.length);
            const labelStep = Math.floor(candles.length / (numTimeLabels - 1));

            for (let i = 0; i < candles.length; i += labelStep) {
                if (i >= candles.length) break;
                const candle = candles[i];
                const x = indexToX(i);
                const time = new Date(candle.timestamp);

                // Tick mark
                ctx.strokeStyle = '#555';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, padding.top + chartHeight);
                ctx.lineTo(x, padding.top + chartHeight + 4);
                ctx.stroke();

                // Date and time
                const dateStr = time.toLocaleDateString('de-CH', { day: '2-digit', month: '2-digit' });
                const timeStr = time.toLocaleTimeString('de-CH', { hour: '2-digit', minute: '2-digit' });
                ctx.fillStyle = '#888';
                ctx.font = '9px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(dateStr, x, height - 22);
                ctx.fillText(timeStr, x, height - 11);
            }

            // Also show last candle time if not already shown
            const lastIdx = candles.length - 1;
            if (lastIdx % labelStep !== 0) {
                const candle = candles[lastIdx];
                const x = indexToX(lastIdx);
                const time = new Date(candle.timestamp);
                const dateStr = time.toLocaleDateString('de-CH', { day: '2-digit', month: '2-digit' });
                const timeStr = time.toLocaleTimeString('de-CH', { hour: '2-digit', minute: '2-digit' });
                ctx.fillStyle = '#ffc107';
                ctx.font = '9px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(dateStr, x, height - 22);
                ctx.fillText(timeStr, x, height - 11);
            }

            // X-axis label (Zeit)
            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Zeit', padding.left + chartWidth / 2, height - 1);

            // Draw pattern title and info
            const info = getTcnPatternInfo(patternType);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(info.name, padding.left + 5, padding.top - 12);

            // Pattern duration info
            if (patternPoints && patternPoints.length > 0 && patternStartIdx < patternEndIdx) {
                const startCandle = candles[patternStartIdx];
                const endCandle = candles[patternEndIdx];
                if (startCandle && endCandle) {
                    const startTime = new Date(startCandle.timestamp);
                    const endTime = new Date(endCandle.timestamp);
                    const durationMs = endTime - startTime;
                    const durationHours = Math.round(durationMs / (1000 * 60 * 60));
                    const durationText = durationHours >= 24
                        ? `${Math.round(durationHours / 24)}d`
                        : `${durationHours}h`;

                    ctx.fillStyle = '#888';
                    ctx.font = '9px sans-serif';
                    ctx.textAlign = 'right';
                    ctx.fillText(`Dauer: ~${durationText} (${patternEndIdx - patternStartIdx + 1} Kerzen)`, width - padding.right, padding.top - 12);
                }
            }
        }

        // Draw pattern overlay based on pattern points
        function drawPatternOverlay(ctx, candles, patternPoints, patternType, indexToX, priceToY, padding, chartHeight) {
            if (!patternPoints || patternPoints.length === 0) return;

            // Determine if point is a high point (peaks/shoulders) or low point (troughs/valleys)
            const highPointTypes = ['left_shoulder', 'head', 'right_shoulder', 'first_peak', 'second_peak',
                'peak', 'peak1', 'peak2', 'peak3', 'top_1', 'top_2', 'pivot_high',
                'resistance_start', 'resistance_end', 'upper_start', 'upper_end',
                'pole_start', 'pole_end', 'flag_start', 'flag_end', 'left_rim', 'right_rim', 'handle_start', 'handle_end'];
            const lowPointTypes = ['first_trough', 'second_trough', 'valley', 'trough1', 'trough2', 'trough3',
                'bottom_1', 'bottom_2', 'pivot_low', 'support_start', 'support_end',
                'lower_start', 'lower_end', 'cup_bottom', 'neckline_left', 'neckline_right'];

            const isHighPoint = (pointType) => highPointTypes.includes(pointType || '');
            const isLowPoint = (pointType) => lowPointTypes.includes(pointType || '');

            // Find the best matching candle for a pattern point based on price proximity
            // minSearchIdx ensures temporal order is preserved (later points must be >= earlier points)
            const findBestCandleForPoint = (point, minSearchIdx = 0) => {
                const targetPrice = point.price;
                const pointType = point.point_type || '';
                const isHigh = isHighPoint(pointType);
                const isLow = isLowPoint(pointType);

                // Search within the pattern formation area, respecting minimum index for temporal order
                // Now that we load the correct time range, search the full candle array
                const searchStart = Math.max(minSearchIdx, 0);
                let bestIdx = searchStart;
                let bestScore = Infinity;

                for (let i = searchStart; i < candles.length; i++) {
                    const candle = candles[i];
                    let priceDiff;

                    if (isHigh) {
                        // For high points, find candle where high is closest to target price
                        priceDiff = Math.abs(candle.high - targetPrice);
                    } else if (isLow) {
                        // For low points, find candle where low is closest to target price
                        priceDiff = Math.abs(candle.low - targetPrice);
                    } else {
                        // Unknown type - use closest of high or low
                        priceDiff = Math.min(
                            Math.abs(candle.high - targetPrice),
                            Math.abs(candle.low - targetPrice)
                        );
                    }

                    if (priceDiff < bestScore) {
                        bestScore = priceDiff;
                        bestIdx = i;
                    }
                }

                return bestIdx;
            };

            // Sort pattern points by their original index to establish temporal order
            // Use index if available, otherwise fall back to 0
            const sortedByOriginalIndex = [...patternPoints].sort((a, b) => (a.index ?? 0) - (b.index ?? 0));

            // Pre-calculate best candle index for each pattern point, preserving temporal order
            const pointToCandleMap = new Map();
            let lastMappedIdx = 0;  // Start from beginning since we load the correct time range

            sortedByOriginalIndex.forEach(p => {
                const mappedIdx = findBestCandleForPoint(p, lastMappedIdx);
                pointToCandleMap.set(p, mappedIdx);
                lastMappedIdx = mappedIdx;  // Next point must be at or after this one
            });

            // Sort pattern points by their mapped candle index to maintain time order
            const sortedPoints = [...patternPoints].sort((a, b) => {
                return pointToCandleMap.get(a) - pointToCandleMap.get(b);
            });

            // Map pattern point to candle index
            const mapIndex = (pointOrIndex) => {
                if (typeof pointOrIndex === 'object' && pointOrIndex !== null) {
                    return pointToCandleMap.get(pointOrIndex) || candles.length - 1;
                }
                // For raw index, fall back to last candle
                return candles.length - 1;
            };

            // Get actual price from candle at mapped index
            const getActualPrice = (point) => {
                const candleIdx = mapIndex(point);
                const candle = candles[candleIdx];
                if (!candle) return point.price;

                const pointType = point.point_type || '';

                if (isHighPoint(pointType)) {
                    return candle.high;
                } else if (isLowPoint(pointType)) {
                    return candle.low;
                } else {
                    // Unknown type - use the one closest to stored price
                    const storedPrice = point.price;
                    return Math.abs(candle.high - storedPrice) < Math.abs(candle.low - storedPrice)
                        ? candle.high : candle.low;
                }
            };

            // Categorize points by type
            const headShoulderTypes = ['left_shoulder', 'head', 'right_shoulder', 'neckline_left', 'neckline_right'];
            const doubleTypes = ['first_peak', 'second_peak', 'valley', 'first_trough', 'second_trough', 'peak'];
            const tripleTypes = ['peak1', 'peak2', 'peak3', 'trough1', 'trough2', 'trough3'];
            const triangleTypes = ['upper_start', 'upper_end', 'lower_start', 'lower_end', 'apex'];
            const channelTypes = ['upper_start', 'upper_end', 'lower_start', 'lower_end'];
            const flagTypes = ['pole_start', 'pole_end', 'flag_start', 'flag_end'];
            const cupTypes = ['left_rim', 'cup_bottom', 'right_rim', 'handle_start', 'handle_end'];
            const wedgeTypes = ['upper_start', 'upper_end', 'lower_start', 'lower_end'];

            // Also support generic pivot types
            const pivotHighs = patternPoints.filter(p => p.point_type === 'pivot_high');
            const pivotLows = patternPoints.filter(p => p.point_type === 'pivot_low');

            ctx.save();

            // Pattern line color based on type
            const direction = getPatternDirection(patternType);
            const colors = {
                bullish: { line: '#4caf50', point: '#81c784', secondary: '#2196f3' },
                bearish: { line: '#f44336', point: '#e57373', secondary: '#ff9800' },
                neutral: { line: '#ffc107', point: '#ffeb3b', secondary: '#9c27b0' }
            }[direction] || { line: '#ffc107', point: '#ffeb3b', secondary: '#9c27b0' };

            // Draw pattern-specific overlays based on pattern type
            if (patternType.includes('head_and_shoulders') || patternType.includes('inverse_head')) {
                drawHeadAndShoulders(ctx, patternPoints, mapIndex, getActualPrice, indexToX, priceToY, colors);
            } else if (patternType.includes('double_top') || patternType.includes('double_bottom')) {
                drawDoublePattern(ctx, patternPoints, mapIndex, getActualPrice, indexToX, priceToY, colors);
            } else if (patternType.includes('triple_top') || patternType.includes('triple_bottom')) {
                drawTriplePattern(ctx, patternPoints, mapIndex, getActualPrice, indexToX, priceToY, colors);
            } else if (patternType.includes('triangle') || patternType.includes('wedge')) {
                drawTriangleWedge(ctx, patternPoints, mapIndex, getActualPrice, indexToX, priceToY, colors);
            } else if (patternType.includes('channel')) {
                drawChannel(ctx, patternPoints, mapIndex, getActualPrice, indexToX, priceToY, colors);
            } else if (patternType.includes('flag')) {
                drawFlag(ctx, patternPoints, mapIndex, getActualPrice, indexToX, priceToY, colors);
            } else if (patternType.includes('cup_and_handle')) {
                drawCupAndHandle(ctx, patternPoints, mapIndex, getActualPrice, indexToX, priceToY, colors);
            } else {
                // Generic pivot point drawing
                drawGenericPivots(ctx, patternPoints, mapIndex, getActualPrice, indexToX, priceToY, colors);
            }

            ctx.restore();
        }

        // Draw Head and Shoulders pattern
        function drawHeadAndShoulders(ctx, points, mapIndex, getActualPrice, indexToX, priceToY, colors) {
            const byType = {};
            points.forEach(p => byType[p.point_type] = p);

            // Get the three main points
            const ls = byType['left_shoulder'];
            const head = byType['head'];
            const rs = byType['right_shoulder'];

            // Collect points and sort by their mapped candle index (time order)
            const mainPoints = [ls, head, rs].filter(p => p);
            if (mainPoints.length >= 2) {
                // Sort by mapped index to ensure correct time order (left to right)
                const sortedPoints = mainPoints
                    .map(p => ({ point: p, mappedIdx: mapIndex(p) }))
                    .sort((a, b) => a.mappedIdx - b.mappedIdx)
                    .map(item => item.point);

                // Draw pattern line through points in time order
                ctx.strokeStyle = colors.line;
                ctx.lineWidth = 2.5;
                ctx.setLineDash([]);
                ctx.beginPath();
                sortedPoints.forEach((p, i) => {
                    const x = indexToX(mapIndex(p));
                    const y = priceToY(getActualPrice(p));
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();

                // Draw circles with correct labels based on point type
                sortedPoints.forEach((p) => {
                    const x = indexToX(mapIndex(p));
                    const y = priceToY(getActualPrice(p));
                    const isHead = p.point_type === 'head';
                    const radius = isHead ? 8 : 6;

                    // Fill circle
                    ctx.fillStyle = isHead ? colors.secondary : colors.point;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();

                    // Label based on actual point type
                    const labelMap = { 'left_shoulder': 'LS', 'head': 'H', 'right_shoulder': 'RS' };
                    const label = labelMap[p.point_type] || '?';
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 9px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(label, x, y - radius - 4);
                });
            }

            // Draw neckline
            const nl1 = byType['neckline_left'];
            const nl2 = byType['neckline_right'];
            if (nl1 && nl2) {
                ctx.strokeStyle = '#9c27b0';
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 3]);
                ctx.beginPath();
                ctx.moveTo(indexToX(mapIndex(nl1)), priceToY(getActualPrice(nl1)));
                ctx.lineTo(indexToX(mapIndex(nl2)), priceToY(getActualPrice(nl2)));
                ctx.stroke();
                ctx.setLineDash([]);

                // Neckline label
                const nlMidX = (indexToX(mapIndex(nl1)) + indexToX(mapIndex(nl2))) / 2;
                const nlMidY = (priceToY(getActualPrice(nl1)) + priceToY(getActualPrice(nl2))) / 2;
                ctx.fillStyle = '#9c27b0';
                ctx.font = 'bold 9px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Neckline', nlMidX, nlMidY - 8);
            }
        }

        // Draw Double Top/Bottom pattern
        function drawDoublePattern(ctx, points, mapIndex, getActualPrice, indexToX, priceToY, colors) {
            const byType = {};
            points.forEach(p => byType[p.point_type] = p);

            // Support both naming conventions:
            // Backend uses: top_1, valley, top_2 / bottom_1, peak, bottom_2
            // Also support: first_peak, valley, second_peak / first_trough, peak, second_trough
            let orderedPoints = [];

            // Double Top patterns
            if (byType['top_1'] || byType['first_peak']) {
                const p1 = byType['top_1'] || byType['first_peak'];
                const mid = byType['valley'];
                const p2 = byType['top_2'] || byType['second_peak'];
                orderedPoints = [p1, mid, p2].filter(p => p);
            }
            // Double Bottom patterns
            else if (byType['bottom_1'] || byType['first_trough']) {
                const p1 = byType['bottom_1'] || byType['first_trough'];
                const mid = byType['peak'];
                const p2 = byType['bottom_2'] || byType['second_trough'];
                orderedPoints = [p1, mid, p2].filter(p => p);
            }

            if (orderedPoints.length >= 2) {
                ctx.strokeStyle = colors.line;
                ctx.lineWidth = 2.5;
                ctx.setLineDash([]);
                ctx.beginPath();
                orderedPoints.forEach((p, i) => {
                    const x = indexToX(mapIndex(p));
                    const y = priceToY(getActualPrice(p));
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();

                // Draw circles with labels
                orderedPoints.forEach((p, i) => {
                    const x = indexToX(mapIndex(p));
                    const y = priceToY(getActualPrice(p));
                    const isMiddle = i === 1;
                    const radius = isMiddle ? 5 : 7;

                    // Fill circle
                    ctx.fillStyle = isMiddle ? colors.secondary : colors.point;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();

                    // Label for tops/bottoms
                    if (!isMiddle) {
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 10px sans-serif';
                        ctx.textAlign = 'center';
                        const label = i === 0 ? '1' : '2';
                        ctx.fillText(label, x, y - radius - 5);
                    }
                });

                // Draw horizontal resistance/support line connecting the two peaks/troughs
                if (orderedPoints.length >= 3) {
                    const p1 = orderedPoints[0];
                    const p2 = orderedPoints[2];
                    const avgPrice = (getActualPrice(p1) + getActualPrice(p2)) / 2;

                    ctx.strokeStyle = colors.line;
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([5, 3]);
                    ctx.beginPath();
                    ctx.moveTo(indexToX(mapIndex(p1)), priceToY(avgPrice));
                    ctx.lineTo(indexToX(mapIndex(p2)), priceToY(avgPrice));
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }

        // Draw Triple Top/Bottom pattern
        function drawTriplePattern(ctx, points, mapIndex, getActualPrice, indexToX, priceToY, colors) {
            const byType = {};
            points.forEach(p => byType[p.point_type] = p);

            // Identify peaks and troughs
            const peaks = points.filter(p =>
                p.point_type.includes('peak') || p.point_type.includes('top') ||
                p.point_type.includes('high') || p.point_type.includes('resistance')
            ).sort((a, b) => a.index - b.index);

            const troughs = points.filter(p =>
                p.point_type.includes('trough') || p.point_type.includes('bottom') ||
                p.point_type.includes('low') || p.point_type.includes('support')
            ).sort((a, b) => a.index - b.index);

            // Determine if triple top or triple bottom
            const isTripleTop = peaks.length >= troughs.length;
            const mainPoints = isTripleTop ? peaks : troughs;
            const secondaryPoints = isTripleTop ? troughs : peaks;

            // Sort all points by index for line drawing
            const allPoints = [...points].sort((a, b) => a.index - b.index);

            if (allPoints.length >= 2) {
                // Draw connecting line
                ctx.strokeStyle = colors.line;
                ctx.lineWidth = 2.5;
                ctx.setLineDash([]);
                ctx.beginPath();
                allPoints.forEach((p, i) => {
                    const x = indexToX(mapIndex(p));
                    const y = priceToY(getActualPrice(p));
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();

                // Draw horizontal resistance/support line through main points
                if (mainPoints.length >= 2) {
                    const avgPrice = mainPoints.reduce((sum, p) => sum + getActualPrice(p), 0) / mainPoints.length;
                    const minIdx = Math.min(...mainPoints.map(p => p.index));
                    const maxIdx = Math.max(...mainPoints.map(p => p.index));

                    ctx.strokeStyle = colors.line;
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([5, 3]);
                    ctx.beginPath();
                    ctx.moveTo(indexToX(mapIndex(minIdx)), priceToY(avgPrice));
                    ctx.lineTo(indexToX(mapIndex(maxIdx)), priceToY(avgPrice));
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // Draw circles with numbers
                let peakNum = 1, troughNum = 1;
                allPoints.forEach(p => {
                    const x = indexToX(mapIndex(p));
                    const y = priceToY(getActualPrice(p));
                    const isPeak = peaks.includes(p);
                    const radius = 6;

                    // Fill circle
                    ctx.fillStyle = isPeak ? colors.point : colors.secondary;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();

                    // Label
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 9px sans-serif';
                    ctx.textAlign = 'center';
                    const label = isPeak ? (peakNum++).toString() : '';
                    if (label) ctx.fillText(label, x, y - radius - 4);
                });
            }
        }

        // Draw Triangle/Wedge pattern
        function drawTriangleWedge(ctx, points, mapIndex, getActualPrice, indexToX, priceToY, colors) {
            const byType = {};
            points.forEach(p => byType[p.point_type] = p);

            // Support both naming conventions:
            // Backend may use: upper_start/upper_end OR resistance_start/resistance_end
            // Backend may use: lower_start/lower_end OR support_start/support_end
            const us = byType['upper_start'] || byType['resistance_start'];
            const ue = byType['upper_end'] || byType['resistance_end'];
            const ls = byType['lower_start'] || byType['support_start'];
            const le = byType['lower_end'] || byType['support_end'];

            // Upper trendline (Resistance)
            if (us && ue) {
                ctx.strokeStyle = colors.line;
                ctx.lineWidth = 2.5;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(indexToX(mapIndex(us)), priceToY(getActualPrice(us)));
                ctx.lineTo(indexToX(mapIndex(ue)), priceToY(getActualPrice(ue)));
                ctx.stroke();

                // Label for upper trendline
                const midX = (indexToX(mapIndex(us)) + indexToX(mapIndex(ue))) / 2;
                const midY = (priceToY(getActualPrice(us)) + priceToY(getActualPrice(ue))) / 2;
                ctx.fillStyle = colors.line;
                ctx.font = 'bold 9px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('R', midX, midY - 8);
            }

            // Lower trendline (Support)
            if (ls && le) {
                ctx.strokeStyle = colors.secondary;
                ctx.lineWidth = 2.5;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(indexToX(mapIndex(ls)), priceToY(getActualPrice(ls)));
                ctx.lineTo(indexToX(mapIndex(le)), priceToY(getActualPrice(le)));
                ctx.stroke();

                // Label for lower trendline
                const midX = (indexToX(mapIndex(ls)) + indexToX(mapIndex(le))) / 2;
                const midY = (priceToY(getActualPrice(ls)) + priceToY(getActualPrice(le))) / 2;
                ctx.fillStyle = colors.secondary;
                ctx.font = 'bold 9px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('S', midX, midY + 14);
            }

            // Draw apex if exists (convergence point)
            const apex = byType['apex'];
            if (apex) {
                const x = indexToX(mapIndex(apex));
                const y = priceToY(getActualPrice(apex));
                ctx.fillStyle = '#ffeb3b';
                ctx.beginPath();
                ctx.arc(x, y, 7, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // Apex label
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 9px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Apex', x, y - 10);
            }

            // Draw corner points with circles
            [us, ue, ls, le].filter(p => p).forEach((p, i) => {
                const x = indexToX(mapIndex(p));
                const y = priceToY(getActualPrice(p));
                const isUpper = p === us || p === ue;

                ctx.fillStyle = isUpper ? colors.point : colors.secondary;
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.stroke();
            });
        }

        // Draw Channel pattern (parallel trendlines)
        function drawChannel(ctx, points, mapIndex, getActualPrice, indexToX, priceToY, colors) {
            const byType = {};
            points.forEach(p => byType[p.point_type] = p);

            // Support both naming conventions
            const us = byType['upper_start'] || byType['resistance_start'];
            const ue = byType['upper_end'] || byType['resistance_end'];
            const ls = byType['lower_start'] || byType['support_start'];
            const le = byType['lower_end'] || byType['support_end'];

            // Upper channel line (Resistance)
            if (us && ue) {
                ctx.strokeStyle = colors.line;
                ctx.lineWidth = 2.5;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(indexToX(mapIndex(us)), priceToY(getActualPrice(us)));
                ctx.lineTo(indexToX(mapIndex(ue)), priceToY(getActualPrice(ue)));
                ctx.stroke();

                // Upper channel label
                const midX = (indexToX(mapIndex(us)) + indexToX(mapIndex(ue))) / 2;
                const midY = (priceToY(getActualPrice(us)) + priceToY(getActualPrice(ue))) / 2;
                ctx.fillStyle = colors.line;
                ctx.font = 'bold 9px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Upper', midX, midY - 8);
            }

            // Lower channel line (Support)
            if (ls && le) {
                ctx.strokeStyle = colors.secondary;
                ctx.lineWidth = 2.5;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(indexToX(mapIndex(ls)), priceToY(getActualPrice(ls)));
                ctx.lineTo(indexToX(mapIndex(le)), priceToY(getActualPrice(le)));
                ctx.stroke();

                // Lower channel label
                const midX = (indexToX(mapIndex(ls)) + indexToX(mapIndex(le))) / 2;
                const midY = (priceToY(getActualPrice(ls)) + priceToY(getActualPrice(le))) / 2;
                ctx.fillStyle = colors.secondary;
                ctx.font = 'bold 9px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Lower', midX, midY + 14);
            }

            // Draw corner points with labels
            const allPoints = [
                { point: us, label: 'H1', isUpper: true },
                { point: ue, label: 'H2', isUpper: true },
                { point: ls, label: 'L1', isUpper: false },
                { point: le, label: 'L2', isUpper: false }
            ].filter(item => item.point);

            allPoints.forEach(({ point, label, isUpper }) => {
                const x = indexToX(mapIndex(point));
                const y = priceToY(getActualPrice(point));

                ctx.fillStyle = isUpper ? colors.point : colors.secondary;
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Point label
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 8px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(label, x, isUpper ? y - 8 : y + 14);
            });
        }

        // Draw Flag pattern (Bull Flag / Bear Flag)
        function drawFlag(ctx, points, mapIndex, getActualPrice, indexToX, priceToY, colors) {
            const byType = {};
            points.forEach(p => byType[p.point_type] = p);

            // Pole (the initial strong move)
            const ps = byType['pole_start'];
            const pe = byType['pole_end'];
            if (ps && pe) {
                ctx.strokeStyle = colors.line;
                ctx.lineWidth = 3;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(indexToX(mapIndex(ps)), priceToY(getActualPrice(ps)));
                ctx.lineTo(indexToX(mapIndex(pe)), priceToY(getActualPrice(pe)));
                ctx.stroke();

                // Pole start/end points
                [ps, pe].forEach((p, i) => {
                    const x = indexToX(mapIndex(p));
                    const y = priceToY(getActualPrice(p));
                    ctx.fillStyle = colors.point;
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                });

                // Pole label
                const midX = (indexToX(mapIndex(ps)) + indexToX(mapIndex(pe))) / 2;
                const midY = (priceToY(getActualPrice(ps)) + priceToY(getActualPrice(pe))) / 2;
                ctx.fillStyle = colors.line;
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Pole', midX - 20, midY);
            }

            // Flag (the consolidation pattern)
            const fs = byType['flag_start'] || pe;  // flag_start often equals pole_end
            const fe = byType['flag_end'];
            if (fs && fe) {
                // Draw flag rectangle/channel area
                ctx.strokeStyle = colors.secondary;
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 2]);
                ctx.beginPath();
                ctx.moveTo(indexToX(mapIndex(fs)), priceToY(getActualPrice(fs)));
                ctx.lineTo(indexToX(mapIndex(fe)), priceToY(getActualPrice(fe)));
                ctx.stroke();
                ctx.setLineDash([]);

                // Flag endpoint
                const x = indexToX(mapIndex(fe));
                const y = priceToY(getActualPrice(fe));
                ctx.fillStyle = colors.secondary;
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Flag label
                const flagMidX = (indexToX(mapIndex(fs)) + indexToX(mapIndex(fe))) / 2;
                const flagMidY = (priceToY(getActualPrice(fs)) + priceToY(getActualPrice(fe))) / 2;
                ctx.fillStyle = colors.secondary;
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Flag', flagMidX + 20, flagMidY);
            }
        }

        // Draw Cup and Handle pattern
        function drawCupAndHandle(ctx, points, mapIndex, getActualPrice, indexToX, priceToY, colors) {
            const byType = {};
            points.forEach(p => byType[p.point_type] = p);

            // Cup curve (simplified as line through points)
            const cupPoints = ['left_rim', 'cup_bottom', 'right_rim'].filter(t => byType[t]).map(t => byType[t]);
            const cupLabels = ['LR', 'Bottom', 'RR'];  // Left Rim, Bottom, Right Rim

            if (cupPoints.length >= 2) {
                ctx.strokeStyle = colors.line;
                ctx.lineWidth = 2.5;
                ctx.setLineDash([]);

                // Draw as curve
                ctx.beginPath();
                if (cupPoints.length === 3) {
                    const [left, bottom, right] = cupPoints;
                    ctx.moveTo(indexToX(mapIndex(left)), priceToY(getActualPrice(left)));
                    ctx.quadraticCurveTo(
                        indexToX(mapIndex(bottom)), priceToY(getActualPrice(bottom)),
                        indexToX(mapIndex(right)), priceToY(getActualPrice(right))
                    );
                } else {
                    cupPoints.forEach((p, i) => {
                        const x = indexToX(mapIndex(p));
                        const y = priceToY(getActualPrice(p));
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    });
                }
                ctx.stroke();

                // Draw cup points with labels
                cupPoints.forEach((p, i) => {
                    const x = indexToX(mapIndex(p));
                    const y = priceToY(getActualPrice(p));
                    const isBottom = i === 1;
                    const radius = isBottom ? 7 : 5;

                    ctx.fillStyle = isBottom ? colors.secondary : colors.point;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    // Label
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 8px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(cupLabels[i], x, isBottom ? y + radius + 12 : y - radius - 5);
                });

                // Add "Cup" label in the middle
                if (cupPoints.length >= 2) {
                    const firstPoint = cupPoints[0];
                    const lastPoint = cupPoints[cupPoints.length - 1];
                    const cupMidX = (indexToX(mapIndex(firstPoint.index)) + indexToX(mapIndex(lastPoint.index))) / 2;
                    const cupMidY = cupPoints.length === 3
                        ? priceToY(getActualPrice(cupPoints[1]))
                        : (priceToY(getActualPrice(firstPoint)) + priceToY(getActualPrice(lastPoint))) / 2;

                    ctx.fillStyle = colors.line;
                    ctx.font = 'bold 10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('Cup', cupMidX, cupMidY + 25);
                }
            }

            // Handle
            const hs = byType['handle_start'];
            const he = byType['handle_end'];
            if (hs && he) {
                ctx.strokeStyle = colors.secondary;
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 2]);
                ctx.beginPath();
                ctx.moveTo(indexToX(mapIndex(hs)), priceToY(getActualPrice(hs)));
                ctx.lineTo(indexToX(mapIndex(he)), priceToY(getActualPrice(he)));
                ctx.stroke();
                ctx.setLineDash([]);

                // Handle endpoints
                [hs, he].forEach((p, i) => {
                    const x = indexToX(mapIndex(p));
                    const y = priceToY(getActualPrice(p));
                    ctx.fillStyle = colors.secondary;
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                });

                // Handle label
                const handleMidX = (indexToX(mapIndex(hs)) + indexToX(mapIndex(he))) / 2;
                const handleMidY = (priceToY(getActualPrice(hs)) + priceToY(getActualPrice(he))) / 2;
                ctx.fillStyle = colors.secondary;
                ctx.font = 'bold 9px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Handle', handleMidX, handleMidY - 10);
            }
        }

        // Draw generic pivot points (fallback for unrecognized patterns)
        function drawGenericPivots(ctx, points, mapIndex, getActualPrice, indexToX, priceToY, colors) {
            const sorted = [...points].sort((a, b) => a.index - b.index);

            if (sorted.length >= 2) {
                // Draw connecting line
                ctx.strokeStyle = colors.line;
                ctx.lineWidth = 2.5;
                ctx.setLineDash([]);
                ctx.beginPath();
                sorted.forEach((p, i) => {
                    const x = indexToX(mapIndex(p));
                    const y = priceToY(getActualPrice(p));
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();

                // Draw numbered points
                let highNum = 1, lowNum = 1;
                sorted.forEach((p, idx) => {
                    const x = indexToX(mapIndex(p));
                    const y = priceToY(getActualPrice(p));
                    const isHigh = p.point_type.includes('high') || p.point_type.includes('peak') ||
                                   p.point_type.includes('shoulder') || p.point_type.includes('head') ||
                                   p.point_type.includes('top') || p.point_type.includes('resistance');

                    // Circle
                    ctx.fillStyle = isHigh ? colors.point : colors.secondary;
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();

                    // Label with H1, H2... for highs and L1, L2... for lows
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 8px sans-serif';
                    ctx.textAlign = 'center';
                    const label = isHigh ? `H${highNum++}` : `L${lowNum++}`;
                    ctx.fillText(label, x, isHigh ? y - 10 : y + 14);
                });
            } else if (sorted.length === 1) {
                // Single point
                const p = sorted[0];
                const x = indexToX(mapIndex(p));
                const y = priceToY(getActualPrice(p));

                ctx.fillStyle = colors.point;
                ctx.beginPath();
                ctx.arc(x, y, 7, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 9px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('P', x, y - 10);
            }
        }

        // Get pattern direction
        function getPatternDirection(patternType) {
            const bullishPatterns = ['inverse_head_and_shoulders', 'double_bottom', 'triple_bottom',
                                     'ascending_triangle', 'bull_flag', 'cup_and_handle', 'falling_wedge', 'channel_up'];
            const bearishPatterns = ['head_and_shoulders', 'double_top', 'triple_top',
                                     'descending_triangle', 'bear_flag', 'rising_wedge', 'channel_down'];

            if (bullishPatterns.includes(patternType)) return 'bullish';
            if (bearishPatterns.includes(patternType)) return 'bearish';
            return 'neutral';
        }

        // Close chart modal
        function closeChartModal() {
            document.getElementById('chartModal').classList.remove('show');
        }

        // Setup chart modal events
        function setupChartModal() {
            const modal = document.getElementById('chartModal');
            if (!modal) return;

            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    closeChartModal();
                }
            });

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && modal.classList.contains('show')) {
                    closeChartModal();
                }
                // ESC closes zoom modal too
                if (e.key === 'Escape' && document.getElementById('zoomModal').style.display === 'flex') {
                    closeZoomModal();
                }
            });
        }

        // Zoom Modal Functions
        let zoomChartInstance = null;

        function openZoomModal() {
            console.log('openZoomModal called, OHLC data:', currentPatternOhlcData ? currentPatternOhlcData.length + ' candles' : 'null');

            const zoomModal = document.getElementById('zoomModal');
            const zoomCanvas = document.getElementById('zoomCanvas');
            const zoomSvgContainer = document.getElementById('zoomSvgContainer');
            const zoomPatternInfo = document.getElementById('zoomPatternInfo');
            const zoomTimestamp = document.getElementById('zoomTimestamp');

            if (!zoomModal) {
                console.error('Zoom modal not found');
                return;
            }

            // Get current pattern info
            const patternName = document.getElementById('chartPatternName')?.textContent || '-';
            const symbol = document.getElementById('chartSymbol')?.textContent || '-';
            const timeframe = document.getElementById('chartTimeframe')?.textContent || '-';
            const timestamp = document.getElementById('chartPatternTime')?.textContent || '-';
            const confidence = document.getElementById('chartConfidence')?.textContent || '-';

            // Set info text
            zoomPatternInfo.innerHTML = `<strong>${patternName}</strong> ¬∑ ${symbol} ¬∑ ${timeframe} ¬∑ Konfidenz: ${confidence}`;
            zoomTimestamp.textContent = timestamp;

            // Show modal
            zoomModal.style.display = 'flex';

            // Check if we have real OHLC data or need to show SVG fallback
            if (currentPatternOhlcData && currentPatternOhlcData.length > 0) {
                // Show canvas, hide SVG container
                zoomCanvas.style.display = 'block';
                zoomSvgContainer.style.display = 'none';

                // Set canvas size
                const containerWidth = Math.min(window.innerWidth * 0.9, 1400);
                const containerHeight = Math.min(window.innerHeight * 0.7, 700);
                zoomCanvas.width = containerWidth;
                zoomCanvas.height = containerHeight;
                zoomCanvas.style.width = containerWidth + 'px';
                zoomCanvas.style.height = containerHeight + 'px';

                console.log('Rendering zoom chart with', currentPatternOhlcData.length, 'candles');
                setTimeout(() => renderZoomChart(zoomCanvas, currentPatternOhlcData), 50);
            } else {
                // Show SVG fallback, hide canvas
                zoomCanvas.style.display = 'none';
                zoomSvgContainer.style.display = 'flex';

                // Get current pattern type and show enlarged SVG
                const patternType = currentTcnPatternData?.patternType || 'head_and_shoulders';
                const svgContent = getPatternSvg(patternType);
                zoomSvgContainer.innerHTML = `
                    <div style="text-align: center;">
                        <div style="transform: scale(2.5); transform-origin: center; margin: 60px auto;">
                            ${svgContent}
                        </div>
                        <p style="color: #888; font-size: 1rem; margin-top: 80px;">
                            Schematische Darstellung (keine Live-Daten verf√ºgbar)
                        </p>
                    </div>
                `;
            }
        }

        function closeZoomModal() {
            const zoomModal = document.getElementById('zoomModal');
            zoomModal.style.display = 'none';

            // Destroy zoom chart instance
            if (zoomChartInstance) {
                zoomChartInstance.destroy();
                zoomChartInstance = null;
            }
        }

        function renderZoomChart(canvas, ohlcData) {
            const ctx = canvas.getContext('2d');

            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.fillStyle = 'rgba(10, 10, 26, 1)';
            ctx.fillRect(0, 0, width, height);

            if (!ohlcData || ohlcData.length === 0) {
                ctx.fillStyle = '#888';
                ctx.font = '18px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText('Keine Daten verf√ºgbar', width / 2, height / 2);
                return;
            }

            // Get pattern data
            const patternType = currentTcnPatternData?.patternType || '';
            const patternPoints = currentTcnPatternData?.patternData?.pattern_points || [];

            console.log('renderZoomChart: canvas', width, 'x', height, ', candles:', ohlcData.length, ', patternType:', patternType, ', points:', patternPoints.length);

            // Calculate price range - include pattern points for proper scaling
            const candlePrices = ohlcData.flatMap(c => [c.high, c.low]);
            const patternPrices = (patternPoints && patternPoints.length > 0)
                ? patternPoints.map(p => p.price)
                : [];
            const allPrices = [...candlePrices, ...patternPrices];

            let minPrice = Math.min(...allPrices);
            let maxPrice = Math.max(...allPrices);
            const priceRange = maxPrice - minPrice || 1;
            const pricePadding = priceRange * 0.1;
            minPrice -= pricePadding;
            maxPrice += pricePadding;

            // Chart dimensions
            const chartPadding = { top: 50, right: 80, bottom: 50, left: 20 };
            const chartWidth = width - chartPadding.left - chartPadding.right;
            const chartHeight = height - chartPadding.top - chartPadding.bottom;

            // Candlestick dimensions
            const candleWidth = Math.max(8, Math.min(25, (chartWidth / ohlcData.length) * 0.7));
            const candleSpacing = chartWidth / ohlcData.length;

            // Helper functions for coordinate conversion
            const priceToY = (price) => {
                return chartPadding.top + chartHeight - ((price - minPrice) / (maxPrice - minPrice) * chartHeight);
            };
            const indexToX = (idx) => {
                return chartPadding.left + (idx + 0.5) * candleSpacing;
            };

            // Draw grid lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = chartPadding.top + (chartHeight / 5) * i;
                ctx.beginPath();
                ctx.moveTo(chartPadding.left, y);
                ctx.lineTo(width - chartPadding.right, y);
                ctx.stroke();

                // Price labels
                const price = maxPrice - ((maxPrice - minPrice) / 5) * i;
                ctx.fillStyle = '#888';
                ctx.font = '12px Segoe UI';
                ctx.textAlign = 'left';
                ctx.fillText(price.toFixed(price > 100 ? 2 : 5), width - chartPadding.right + 8, y + 4);
            }

            // Draw pattern zone background BEFORE candles (so it's behind)
            if (patternPoints && patternPoints.length > 0) {
                // Use same mapping logic as drawPatternOverlay
                const highPointTypes = ['left_shoulder', 'head', 'right_shoulder', 'first_peak', 'second_peak',
                    'peak', 'peak1', 'peak2', 'peak3', 'top_1', 'top_2', 'pivot_high',
                    'resistance_start', 'resistance_end', 'upper_start', 'upper_end',
                    'pole_start', 'pole_end', 'flag_start', 'flag_end', 'left_rim', 'right_rim', 'handle_start', 'handle_end'];
                const lowPointTypes = ['first_trough', 'second_trough', 'valley', 'trough1', 'trough2', 'trough3',
                    'bottom_1', 'bottom_2', 'pivot_low', 'support_start', 'support_end',
                    'lower_start', 'lower_end', 'cup_bottom', 'neckline_left', 'neckline_right'];

                const isHighPoint = (pointType) => highPointTypes.includes(pointType || '');
                const isLowPoint = (pointType) => lowPointTypes.includes(pointType || '');

                const findBestCandleForZone = (point, minSearchIdx = 0) => {
                    const targetPrice = point.price;
                    const pointType = point.point_type || '';
                    const isHigh = isHighPoint(pointType);
                    const isLow = isLowPoint(pointType);

                    const searchStart = Math.max(minSearchIdx, ohlcData.length - 100);
                    let bestIdx = searchStart;
                    let bestScore = Infinity;

                    for (let i = searchStart; i < ohlcData.length; i++) {
                        const candle = ohlcData[i];
                        let priceDiff;

                        if (isHigh) {
                            priceDiff = Math.abs(candle.high - targetPrice);
                        } else if (isLow) {
                            priceDiff = Math.abs(candle.low - targetPrice);
                        } else {
                            priceDiff = Math.min(
                                Math.abs(candle.high - targetPrice),
                                Math.abs(candle.low - targetPrice)
                            );
                        }

                        if (priceDiff < bestScore) {
                            bestScore = priceDiff;
                            bestIdx = i;
                        }
                    }
                    return bestIdx;
                };

                const sortedForZone = [...patternPoints].sort((a, b) => (a.index ?? 0) - (b.index ?? 0));
                const mappedIndices = [];
                let lastIdx = Math.max(0, ohlcData.length - 100);
                sortedForZone.forEach(p => {
                    const idx = findBestCandleForZone(p, lastIdx);
                    mappedIndices.push(idx);
                    lastIdx = idx;
                });

                let patternStartIdx = 0;
                let patternEndIdx = ohlcData.length - 1;
                if (mappedIndices.length > 0) {
                    patternStartIdx = Math.max(0, Math.min(...mappedIndices) - 2);
                    patternEndIdx = Math.min(ohlcData.length - 1, Math.max(...mappedIndices) + 2);
                }

                const startX = indexToX(patternStartIdx) - candleSpacing / 2;
                const endX = indexToX(patternEndIdx) + candleSpacing / 2;

                // Pattern zone fill
                ctx.fillStyle = 'rgba(255, 193, 7, 0.15)';
                ctx.fillRect(startX, chartPadding.top, endX - startX, chartHeight);

                // Pattern zone border
                ctx.strokeStyle = '#ffc107';
                ctx.lineWidth = 2;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(startX, chartPadding.top);
                ctx.lineTo(startX, chartPadding.top + chartHeight);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(endX, chartPadding.top);
                ctx.lineTo(endX, chartPadding.top + chartHeight);
                ctx.stroke();

                // Pattern zone label
                const labelText = 'Pattern-Formation';
                ctx.font = 'bold 12px Segoe UI';
                const labelX = (startX + endX) / 2;
                const labelWidth = ctx.measureText(labelText).width + 12;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(labelX - labelWidth / 2, chartPadding.top + 5, labelWidth, 20);
                ctx.fillStyle = '#ffc107';
                ctx.textAlign = 'center';
                ctx.fillText(labelText, labelX, chartPadding.top + 19);

                // Start/End markers
                ctx.font = 'bold 10px Segoe UI';
                ctx.fillStyle = '#ffc107';
                ctx.fillText('‚ñº', startX, chartPadding.top + 38);
                ctx.fillText('Start', startX, chartPadding.top + 52);
                ctx.fillText('‚ñº', endX, chartPadding.top + 38);
                ctx.fillText('Ende', endX, chartPadding.top + 52);
            }

            // Draw candlesticks
            ohlcData.forEach((candle, index) => {
                const x = indexToX(index);

                const openY = priceToY(candle.open);
                const closeY = priceToY(candle.close);
                const highY = priceToY(candle.high);
                const lowY = priceToY(candle.low);

                const isBullish = candle.close >= candle.open;
                const color = isBullish ? '#4caf50' : '#f44336';

                // Draw wick
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, highY);
                ctx.lineTo(x, lowY);
                ctx.stroke();

                // Draw body
                const bodyTop = Math.min(openY, closeY);
                const bodyHeight = Math.max(2, Math.abs(closeY - openY));

                ctx.fillStyle = isBullish ? 'rgba(76, 175, 80, 0.9)' : 'rgba(244, 67, 54, 0.9)';
                ctx.fillRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
                ctx.strokeStyle = color;
                ctx.lineWidth = 1;
                ctx.strokeRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
            });

            // Draw pattern overlay lines AFTER candles (so it's on top)
            if (patternPoints && patternPoints.length > 0) {
                drawPatternOverlay(ctx, ohlcData, patternPoints, patternType, indexToX, priceToY, chartPadding, chartHeight);
            }

            // Draw time labels
            ctx.fillStyle = '#888';
            ctx.font = '11px Segoe UI';
            ctx.textAlign = 'center';
            const labelStep = Math.ceil(ohlcData.length / 8);
            ohlcData.forEach((candle, index) => {
                if (index % labelStep === 0 || index === ohlcData.length - 1) {
                    const x = indexToX(index);
                    const date = new Date(candle.timestamp);
                    const timeStr = date.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
                    const dateStr = date.toLocaleDateString('de-DE', { day: '2-digit', month: '2-digit' });
                    ctx.fillText(dateStr, x, height - chartPadding.bottom + 18);
                    ctx.fillText(timeStr, x, height - chartPadding.bottom + 32);
                }
            });
        }
    </script>

    <!-- Pattern Detail Modal (Candlestick-Style) -->
    <div class="modal-overlay" id="chartModal" onclick="if(event.target===this)closeChartModal()">
        <div class="modal" onclick="event.stopPropagation()" style="max-width: 850px;">
            <div class="modal-header" style="align-items: flex-start;">
                <div class="modal-title" style="flex-direction: column; align-items: flex-start;">
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <span id="chartModalTitle">Pattern</span>
                        <span id="chartModalBadges"></span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.7rem; color: #888; font-family: monospace; margin-top: 0.25rem;">
                        <span id="chartPatternId">-</span>
                        <button class="btn btn-secondary" style="padding: 0.15rem 0.35rem; font-size: 0.6rem;" onclick="copyPatternId()" title="Pattern-ID kopieren">üìã</button>
                    </div>
                </div>
                <button type="button" class="modal-close" onclick="closeChartModal()">&times;</button>
            </div>
            <div class="modal-body">
                <!-- Chart Comparison (Two Columns: 2/3 + 1/3) -->
                <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                    <div>
                        <div style="font-size: 0.8rem; color: #888; margin-bottom: 0.5rem; text-align: center;">Erkanntes Pattern <span style="font-size: 0.7rem; opacity: 0.7;">(Klick zum Vergr√∂√üern)</span></div>
                        <!-- Loading indicator -->
                        <div id="chartLoading" style="display: flex; justify-content: center; align-items: center; padding: 2rem; color: #888; min-height: 200px; background: rgba(0,0,0,0.2); border-radius: 8px;">
                            <span style="margin-right: 0.5rem;">‚è≥</span> Chart wird geladen...
                        </div>
                        <!-- Real candlestick chart with pattern overlay -->
                        <div class="chart-container" id="patternChartContainer" onclick="openZoomModal()" style="display: none; height: 200px; padding: 0.5rem; background: rgba(0,0,0,0.2); border-radius: 8px; cursor: zoom-in; transition: transform 0.2s, box-shadow 0.2s;" onmouseover="this.style.boxShadow='0 0 15px rgba(100,200,255,0.3)'" onmouseout="this.style.boxShadow='none'">
                            <canvas id="patternCanvas" style="width: 100%; height: 100%;"></canvas>
                        </div>
                        <!-- Fallback SVG visualization -->
                        <div class="chart-container" id="patternSvgContainer" onclick="openZoomModal()" style="display: none; justify-content: center; align-items: center; padding: 1rem; min-height: 200px; background: rgba(0,0,0,0.2); border-radius: 8px; cursor: zoom-in; transition: box-shadow 0.2s;" onmouseover="this.style.boxShadow='0 0 15px rgba(100,200,255,0.3)'" onmouseout="this.style.boxShadow='none'">
                            <!-- SVG wird dynamisch eingef√ºgt -->
                        </div>
                    </div>
                    <div>
                        <div style="font-size: 0.8rem; color: #888; margin-bottom: 0.5rem; text-align: center;">Referenz-Beispiel</div>
                        <div id="referencePatternContainer" style="display: flex; justify-content: center; align-items: center; min-height: 200px; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 1rem;">
                            <!-- SVG wird dynamisch eingef√ºgt -->
                        </div>
                    </div>
                </div>

                <!-- Info Grid -->
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; margin-bottom: 1rem;">
                    <div style="background: rgba(255,255,255,0.03); padding: 0.75rem; border-radius: 8px;">
                        <div style="font-size: 0.75rem; color: #888; margin-bottom: 0.25rem;">Symbol</div>
                        <div style="font-size: 1rem; font-weight: 600;" id="chartSymbol">-</div>
                    </div>
                    <div style="background: rgba(255,255,255,0.03); padding: 0.75rem; border-radius: 8px;">
                        <div style="font-size: 0.75rem; color: #888; margin-bottom: 0.25rem;">Timeframe</div>
                        <div style="font-size: 1rem; font-weight: 600;" id="chartTimeframe">-</div>
                    </div>
                    <div style="background: rgba(255,255,255,0.03); padding: 0.75rem; border-radius: 8px;">
                        <div style="font-size: 0.75rem; color: #888; margin-bottom: 0.25rem;">Zeitraum</div>
                        <div style="font-size: 0.9rem; font-weight: 600;" id="chartPatternTime">-</div>
                    </div>
                    <div style="background: rgba(255,255,255,0.03); padding: 0.75rem; border-radius: 8px;">
                        <div style="font-size: 0.75rem; color: #888; margin-bottom: 0.25rem;">Konfidenz</div>
                        <div style="font-size: 1rem; font-weight: 600;" id="chartConfidence">-</div>
                    </div>
                </div>

                <!-- Hidden fields for backward compatibility -->
                <div style="display: none;">
                    <span id="chartPatternType">-</span>
                    <span id="chartPatternStart">-</span>
                    <span id="chartPatternEnd">-</span>
                </div>

                <!-- Description -->
                <div class="modal-description" id="chartPatternDescription" style="margin-bottom: 1rem; padding: 0.75rem; background: rgba(255,255,255,0.03); border-radius: 8px; font-size: 0.9rem; line-height: 1.5;">
                    Pattern-Beschreibung wird geladen...
                </div>

                <!-- Feedback Buttons -->
                <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.1);">
                    <div style="display: flex; gap: 0.75rem; align-items: center; flex-wrap: wrap;">
                        <button class="btn btn-success" onclick="confirmTcnPattern()" style="padding: 0.5rem 1rem;" title="Pattern best√§tigen">
                            ‚úì Korrekt
                        </button>
                        <button class="btn btn-warning" onclick="rejectTcnPattern()" style="padding: 0.5rem 1rem;" title="Pattern ablehnen">
                            ‚úó Falsches Pattern
                        </button>
                        <button class="btn btn-secondary" onclick="markNoPattern()" style="padding: 0.5rem 1rem;" title="Kein Pattern erkennbar">
                            ‚úó Kein Pattern
                        </button>
                        <div style="border-left: 1px solid rgba(255,255,255,0.2); height: 24px; margin: 0 0.5rem;"></div>
                        <button class="btn" id="btnClaudeValidate" onclick="validateWithClaude()" style="padding: 0.5rem 1rem; background: linear-gradient(135deg, #7c3aed 0%, #a855f7 100%); border: none;" title="Mit Claude Vision validieren">
                            ü§ñ Claude pr√ºfen
                        </button>
                    </div>
                    <div id="tcnFeedbackResult" style="margin-top: 0.75rem; font-size: 0.85rem; display: none;"></div>
                    <div id="claudeValidationResult" style="margin-top: 0.75rem; font-size: 0.85rem; display: none;"></div>
                </div>
            </div>
            <!-- Navigation Footer -->
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 1rem; border-top: 1px solid rgba(255,255,255,0.1); background: rgba(0,0,0,0.2);">
                <button class="btn btn-secondary" id="modalPrevBtn" onclick="navigateTcnPattern(-1)" title="Vorheriges Pattern (‚Üê)" style="padding: 0.5rem 1rem;">
                    ‚Äπ Zur√ºck
                </button>
                <span id="modalNavCounter" style="color: #888; font-size: 0.9rem;">1 / 100</span>
                <button class="btn btn-primary" id="modalNextBtn" onclick="navigateTcnPattern(1)" title="N√§chstes Pattern (‚Üí)" style="padding: 0.5rem 1rem;">
                    Weiter ‚Ä∫
                </button>
            </div>
        </div>
    </div>

    <!-- Pattern Detail Modal (Dokumentation) -->
    <div class="modal-overlay pattern-detail-modal" id="patternDetailModal" onclick="if(event.target===this)closePatternDetailModal()">
        <div class="modal" onclick="event.stopPropagation()">
            <div class="modal-header">
                <div style="display: flex; align-items: center; gap: 1rem;">
                    <span class="modal-title" id="patternDetailTitle">Head & Shoulders</span>
                    <div class="pattern-detail-badges" id="patternDetailBadges">
                        <span class="pattern-overview-badge bearish">Bearish</span>
                        <span class="pattern-overview-badge" style="background: rgba(156, 39, 176, 0.2); color: #ce93d8;">Umkehr</span>
                    </div>
                </div>
                <button class="modal-close" onclick="closePatternDetailModal()">&times;</button>
            </div>
            <div class="modal-body">

                <!-- Top Section: SVG + Kurzbeschreibung -->
                <div class="pattern-detail-grid">
                    <div class="pattern-detail-svg-container" id="patternDetailSvg">
                        <!-- SVG wird dynamisch eingef√ºgt -->
                    </div>
                    <div>
                        <h4 style="color: #888; font-size: 0.75rem; text-transform: uppercase; margin-bottom: 0.5rem;">Kurzbeschreibung</h4>
                        <p class="pattern-detail-description" id="patternDetailDescription">
                            <!-- Beschreibung wird dynamisch eingef√ºgt -->
                        </p>
                    </div>
                </div>

                <!-- Aufbau der Formation -->
                <div class="pattern-detail-section">
                    <div class="pattern-detail-section-title">
                        üìã Aufbau der Formation
                    </div>
                    <div class="pattern-components" id="patternDetailComponents">
                        <!-- Komponenten werden dynamisch eingef√ºgt -->
                    </div>
                    <div class="pattern-neckline-info" id="patternDetailNeckline">
                        <!-- Neckline/Support/Resistance Info -->
                    </div>
                </div>

                <!-- Bedeutung -->
                <div class="pattern-detail-section">
                    <div class="pattern-detail-section-title">
                        üìà Bedeutung
                    </div>
                    <ul class="pattern-meaning-list" id="patternDetailMeaning">
                        <!-- Bedeutungspunkte werden dynamisch eingef√ºgt -->
                    </ul>
                </div>

                <!-- Trading Strategie -->
                <div class="pattern-detail-section">
                    <div class="pattern-detail-section-title">
                        üíπ Trading Strategie
                    </div>
                    <div class="pattern-trading-grid">
                        <div class="pattern-trading-card entry">
                            <div class="pattern-trading-label">‚ñº Einstieg</div>
                            <div class="pattern-trading-value" id="patternDetailEntry">-</div>
                        </div>
                        <div class="pattern-trading-card target">
                            <div class="pattern-trading-label">üéØ Preisziel</div>
                            <div class="pattern-trading-value" id="patternDetailTarget">-</div>
                        </div>
                        <div class="pattern-trading-card stoploss">
                            <div class="pattern-trading-label">üõë Stop Loss</div>
                            <div class="pattern-trading-value" id="patternDetailStopLoss">-</div>
                        </div>
                        <div class="pattern-trading-card invalidation">
                            <div class="pattern-trading-label">‚ö†Ô∏è Falscher Alarm</div>
                            <div class="pattern-trading-value" id="patternDetailInvalidation">-</div>
                        </div>
                    </div>
                </div>

                <!-- Quick Facts -->
                <div class="pattern-detail-section">
                    <div class="pattern-detail-section-title">
                        üìä Quick Facts
                    </div>
                    <div class="pattern-facts-grid">
                        <div class="pattern-fact-item">
                            <div class="pattern-fact-label">Pattern-Typ</div>
                            <div class="pattern-fact-value" id="patternDetailType">-</div>
                        </div>
                        <div class="pattern-fact-item">
                            <div class="pattern-fact-label">Zuverl√§ssigkeit</div>
                            <div class="pattern-fact-value reliability-stars" id="patternDetailReliability">-</div>
                        </div>
                        <div class="pattern-fact-item">
                            <div class="pattern-fact-label">St√§rke</div>
                            <div class="pattern-fact-value" id="patternDetailStrength">-</div>
                        </div>
                        <div class="pattern-fact-item">
                            <div class="pattern-fact-label">Kontext</div>
                            <div class="pattern-fact-value" id="patternDetailContext">-</div>
                        </div>
                    </div>
                </div>

                <!-- Verwandte Patterns -->
                <div class="pattern-detail-section">
                    <div class="pattern-detail-section-title">
                        üîó Verwandte Patterns
                    </div>
                    <div class="related-patterns" id="patternDetailRelated">
                        <!-- Verwandte Patterns werden dynamisch eingef√ºgt -->
                    </div>
                </div>

                <!-- Action Button -->
                <div style="text-align: center; margin-top: 1.5rem;">
                    <button class="btn btn-primary" onclick="goToPatternDetectionFromDetail()">
                        üîç In Pattern-Erkennung testen ‚Üí
                    </button>
                </div>

            </div>
        </div>
    </div>

    <!-- Zoom Modal f√ºr vergr√∂√üerte Chart-Ansicht -->
    <div id="zoomModal" onclick="closeZoomModal()" style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.95); z-index: 10000; cursor: zoom-out; justify-content: center; align-items: center; flex-direction: column;">
        <div style="position: absolute; top: 1rem; right: 1rem; display: flex; gap: 1rem; align-items: center;">
            <span style="color: #888; font-size: 0.85rem;">ESC oder Klick zum Schlie√üen</span>
            <button onclick="closeZoomModal()" style="background: rgba(255,255,255,0.1); border: none; color: #fff; font-size: 2rem; width: 50px; height: 50px; border-radius: 50%; cursor: pointer; display: flex; justify-content: center; align-items: center;">&times;</button>
        </div>
        <div id="zoomPatternInfo" style="color: #64c8ff; font-size: 1.2rem; margin-bottom: 1rem; text-align: center;"></div>
        <div id="zoomChartContainer" onclick="event.stopPropagation()" style="max-width: 95vw; max-height: 80vh; background: rgba(10,10,26,0.9); border-radius: 12px; padding: 1rem; border: 1px solid rgba(100,200,255,0.3);">
            <canvas id="zoomCanvas" style="max-width: 100%; max-height: 100%;"></canvas>
            <!-- SVG Container f√ºr Fallback wenn keine OHLC-Daten -->
            <div id="zoomSvgContainer" style="display: none; justify-content: center; align-items: center; min-width: 600px; min-height: 400px;"></div>
        </div>
        <div style="color: #888; font-size: 0.85rem; margin-top: 1rem; text-align: center;">
            <span id="zoomTimestamp"></span>
        </div>
    </div>
</body>
</html>
