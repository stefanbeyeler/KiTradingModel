<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NHITS Service - Konfiguration</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e8e8e8;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1.5rem;
        }

        header {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1rem 0;
            margin-bottom: 1.5rem;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        header .container {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #64c8ff;
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .back-link:hover {
            color: #fff;
        }

        .header-title {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .service-badge {
            background: rgba(76, 175, 80, 0.2);
            color: #81c784;
            padding: 0.3rem 0.8rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .service-badge.offline {
            background: rgba(244, 67, 54, 0.2);
            color: #e57373;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 0.5rem;
        }

        .tab-btn {
            padding: 0.75rem 1.5rem;
            background: transparent;
            border: none;
            color: #a0a0a0;
            font-size: 1rem;
            cursor: pointer;
            border-radius: 8px 8px 0 0;
            transition: all 0.2s;
        }

        .tab-btn:hover {
            background: rgba(255, 255, 255, 0.05);
            color: #e8e8e8;
        }

        .tab-btn.active {
            background: rgba(100, 200, 255, 0.15);
            color: #64c8ff;
            border-bottom: 2px solid #64c8ff;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Card */
        .card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 1.5rem;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .card-title {
            font-size: 1.2rem;
            color: #64c8ff;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Stats Bar */
        .stats-bar {
            display: flex;
            gap: 2rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 600;
            color: #64c8ff;
        }

        .stat-label {
            font-size: 0.8rem;
            opacity: 0.7;
        }

        /* Buttons */
        .btn {
            padding: 0.6rem 1.2rem;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
        }

        .btn-primary {
            background: rgba(100, 200, 255, 0.2);
            color: #64c8ff;
            border: 1px solid rgba(100, 200, 255, 0.3);
        }

        .btn-primary:hover {
            background: rgba(100, 200, 255, 0.3);
        }

        .btn-success {
            background: rgba(76, 175, 80, 0.2);
            color: #81c784;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .btn-success:hover {
            background: rgba(76, 175, 80, 0.3);
        }

        .btn-danger {
            background: rgba(244, 67, 54, 0.2);
            color: #e57373;
            border: 1px solid rgba(244, 67, 54, 0.3);
        }

        .btn-danger:hover {
            background: rgba(244, 67, 54, 0.3);
        }

        .btn-warning {
            background: rgba(255, 152, 0, 0.2);
            color: #ffb74d;
            border: 1px solid rgba(255, 152, 0, 0.3);
        }

        .btn-warning:hover {
            background: rgba(255, 152, 0, 0.3);
        }

        .btn-purple {
            background: rgba(167, 139, 250, 0.2);
            color: #a78bfa;
            border: 1px solid rgba(167, 139, 250, 0.3);
        }

        .btn-purple:hover {
            background: rgba(167, 139, 250, 0.3);
        }

        .btn-loading {
            position: relative;
            pointer-events: none;
            opacity: 0.8;
        }

        .btn-loading::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 12px;
            top: 50%;
            right: 8px;
            margin-top: -6px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .btn-sm {
            padding: 0.4rem 0.8rem;
            font-size: 0.8rem;
        }

        /* Grid Layout */
        .grid-2 {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 1.5rem;
        }

        .grid-2-equal {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
        }

        @media (max-width: 900px) {
            .grid-2, .grid-2-equal {
                grid-template-columns: 1fr;
            }
        }

        /* Training Status */
        .training-status {
            font-size: 0.9rem;
        }

        .training-status .training-active {
            color: #4ade80;
            font-weight: 600;
            animation: blink 1s ease-in-out infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .progress-bar {
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            overflow: hidden;
            margin: 0.75rem 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #64c8ff, #a78bfa);
            border-radius: 6px;
            transition: width 0.3s;
        }

        .progress-fill.active {
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .training-info {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-top: 1rem;
        }

        .training-timing {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-top: 1rem;
        }

        .timing-stat {
            text-align: center;
            padding: 0.8rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        .timing-stat .value {
            font-size: 1.2rem;
            font-weight: 600;
            color: #a78bfa;
        }

        .timing-stat .label {
            font-size: 0.75rem;
            opacity: 0.6;
            margin-top: 0.3rem;
        }

        .training-stat {
            text-align: center;
            padding: 0.8rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        .training-stat .value {
            font-size: 1.5rem;
            font-weight: 600;
            color: #64c8ff;
        }

        .training-stat .label {
            font-size: 0.75rem;
            opacity: 0.6;
            margin-top: 0.3rem;
        }

        .timeframe-breakdown {
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Quick Actions */
        .quick-actions {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .quick-actions .btn {
            width: 100%;
            justify-content: center;
            padding: 0.9rem;
        }

        /* Cache Stats */
        .cache-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-top: 1rem;
        }

        .cache-stat {
            background: rgba(0, 0, 0, 0.2);
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
        }

        .cache-stat .value {
            font-size: 1.3rem;
            font-weight: 600;
            color: #64c8ff;
        }

        .cache-stat .label {
            font-size: 0.75rem;
            opacity: 0.6;
            margin-top: 0.3rem;
        }

        /* Models Table */
        .table-container {
            overflow-x: auto;
            max-height: 400px;
            overflow-y: auto;
        }

        /* Dynamic height for models table - uses available viewport height */
        #tab-models .table-container {
            max-height: calc(100vh - 280px);
            min-height: 300px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        th {
            background: rgba(22, 33, 62, 0.98);
            position: sticky;
            top: 0;
            z-index: 10;
            font-weight: 500;
            color: #a0a0a0;
            font-size: 0.85rem;
            text-transform: uppercase;
        }

        /* Legend styling */
        .legend {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            font-size: 0.8rem;
            opacity: 0.8;
        }
        .legend span {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            white-space: nowrap;
        }

        tr:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        /* Badges */
        .badge {
            padding: 0.25rem 0.6rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .badge-m15 { background: rgba(244, 67, 54, 0.2); color: #e57373; }
        .badge-h1 { background: rgba(33, 150, 243, 0.2); color: #64b5f6; }
        .badge-d1 { background: rgba(76, 175, 80, 0.2); color: #81c784; }
        .badge-success { background: rgba(76, 175, 80, 0.2); color: #81c784; }
        .badge-failed { background: rgba(244, 67, 54, 0.2); color: #e57373; }

        /* Toolbar */
        .toolbar {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            align-items: center;
        }

        .search-box {
            flex: 1;
            min-width: 200px;
            padding: 0.6rem 1rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.2);
            color: #e8e8e8;
            font-size: 0.9rem;
        }

        .search-box::placeholder {
            color: #888;
        }

        .filter-select {
            padding: 0.6rem 1rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.2);
            color: #e8e8e8;
            font-size: 0.9rem;
            cursor: pointer;
        }

        .filter-select option {
            background: #1a1a2e;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            padding: 1rem 1.5rem;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 8px;
            border-left: 4px solid #64c8ff;
            display: none;
            z-index: 1000;
        }

        .toast.show {
            display: block;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .modal-overlay.show {
            display: flex;
            animation: fadeIn 0.2s ease;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .modal {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 12px;
            padding: 1.5rem;
            min-width: 400px;
            max-width: 500px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .modal-title {
            font-size: 1.2rem;
            color: #64c8ff;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .modal-close {
            background: none;
            border: none;
            color: #a0a0a0;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem;
            line-height: 1;
        }
        .modal-close:hover {
            color: #fff;
        }
        .modal-body {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .modal-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        .modal-row:last-child {
            border-bottom: none;
        }
        .modal-label {
            color: #a0a0a0;
            font-size: 0.9rem;
        }
        .modal-value {
            font-weight: 500;
            text-align: right;
        }
        .modal-value.up { color: #4ade80; }
        .modal-value.down { color: #f87171; }
        .modal-value.pending { color: #fbbf24; }

        /* Clickable forecast cell */
        .forecast-cell {
            cursor: pointer;
            transition: background 0.2s;
        }
        .forecast-cell:hover {
            background: rgba(100, 200, 255, 0.1);
        }

        /* Failed Models List */
        .failed-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .failed-item {
            padding: 0.75rem;
            background: rgba(244, 67, 54, 0.1);
            border-radius: 8px;
            margin-bottom: 0.5rem;
            border-left: 3px solid #e57373;
        }

        .failed-item .symbol {
            font-weight: 600;
            color: #e57373;
        }

        .failed-item .error {
            font-size: 0.8rem;
            opacity: 0.8;
            margin-top: 0.3rem;
        }

        /* Forecast Form */
        .forecast-form .form-group {
            margin-bottom: 1rem;
        }

        .forecast-form label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .forecast-form .filter-select {
            width: 100%;
            padding: 0.8rem 1rem;
        }

        /* Forecast Summary */
        .forecast-summary-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }

        .summary-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
        }

        .summary-item .value {
            font-size: 1.3rem;
            font-weight: 600;
            color: #64c8ff;
        }

        .summary-item .value.up {
            color: #4ade80;
        }

        .summary-item .value.down {
            color: #f87171;
        }

        .summary-item .label {
            font-size: 0.75rem;
            opacity: 0.6;
            margin-top: 0.3rem;
        }

        .trend-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            margin-top: 1rem;
        }

        .trend-indicator.bullish {
            border-left: 4px solid #4ade80;
        }

        .trend-indicator.bearish {
            border-left: 4px solid #f87171;
        }

        .trend-indicator .arrow {
            font-size: 1.5rem;
        }

        .trend-indicator .text {
            font-size: 1rem;
            font-weight: 500;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <header>
        <div class="container" style="flex-direction: column; gap: 0.5rem;">
            <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                <a href="/" class="back-link">‚Üê Dashboard</a>
                <h1 class="header-title">üìà NHITS Service</h1>
                <span class="service-badge" id="service-status">Laden...</span>
            </div>
            <!-- Compact Header Status Bar -->
            <div style="display: flex; gap: 1.5rem; align-items: center; flex-wrap: wrap; font-size: 0.85rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.1);">
                <div style="display: flex; align-items: center; gap: 0.4rem;" title="Service-Status">
                    <span>‚è≥</span>
                    <span style="color: #888;">Status:</span>
                    <strong id="headerStatus" style="color: #4caf50;">L√§dt...</strong>
                </div>
                <div style="display: flex; align-items: center; gap: 0.4rem;" title="Service-Version">
                    <span>üì¶</span>
                    <span style="color: #888;">Version:</span>
                    <strong id="headerVersion" style="color: #64c8ff;">-</strong>
                </div>
                <div style="display: flex; align-items: center; gap: 0.4rem;" title="CPU oder CUDA GPU">
                    <span>üñ•Ô∏è</span>
                    <span style="color: #888;">Device:</span>
                    <strong id="headerDevice" style="color: #64c8ff;">-</strong>
                </div>
                <div style="display: flex; align-items: center; gap: 0.4rem;" title="Anzahl trainierter Modelle">
                    <span>üß†</span>
                    <span style="color: #888;">Modelle:</span>
                    <strong id="headerModels" style="color: #64c8ff;">-</strong>
                </div>
                <div style="display: flex; align-items: center; gap: 0.4rem;" title="Training-Status">
                    <span>üèãÔ∏è</span>
                    <span style="color: #888;">Training:</span>
                    <strong id="headerTraining" style="color: #64c8ff;">-</strong>
                </div>
                <div style="display: flex; align-items: center; gap: 0.4rem;" title="Zeit seit Service-Start">
                    <span>üïê</span>
                    <span style="color: #888;">Uptime:</span>
                    <strong id="headerUptime" style="color: #64c8ff;">-</strong>
                </div>
                <button class="btn btn-primary" onclick="updateHeaderStatus()" style="margin-left: auto; padding: 0.3rem 0.6rem; font-size: 0.8rem;">‚Üª</button>
            </div>
        </div>
    </header>

    <div class="container">
        <!-- Tabs -->
        <div class="tabs">
            <button class="tab-btn active" onclick="switchTab('overview')">üìä √úbersicht</button>
            <button class="tab-btn" onclick="switchTab('training')">Training</button>
            <button class="tab-btn" onclick="switchTab('models')">Modelle</button>
            <button class="tab-btn" onclick="switchTab('forecast')">Prognose</button>
            <button class="tab-btn" onclick="switchTab('performance')">Performance</button>
            <button class="tab-btn" onclick="switchTab('selflearning')">ü§ñ Self-Learning</button>
            <button class="tab-btn" onclick="switchTab('backup')">Backup / Restore</button>
        </div>

        <!-- √úbersicht Tab -->
        <div id="tab-overview" class="tab-content active">
            <!-- Lernfortschritt Chart -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üìà Lernfortschritt</h2>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <select class="filter-select" id="overview-symbol-filter" style="padding: 0.4rem; font-size: 0.85rem; min-width: 150px;" onchange="loadLearningProgress()">
                            <option value="all">Alle Symbole</option>
                        </select>
                        <button class="btn btn-primary btn-sm" onclick="loadLearningProgress()">üîÑ</button>
                    </div>
                </div>
                <div style="position: relative; height: 220px; padding: 0.5rem;">
                    <canvas id="learning-progress-chart"></canvas>
                </div>
                <div id="learning-progress-summary" style="padding: 0.75rem 1rem; font-size: 0.85rem; color: #888; border-top: 1px solid rgba(255,255,255,0.05);">
                    Lade Metriken...
                </div>
            </div>

            <!-- KPI Stats Cards -->
            <div class="stats-bar" style="margin-bottom: 1rem;">
                <div class="stat-item">
                    <div class="stat-value" style="color: #4ade80;" id="overview-accuracy">-</div>
                    <div class="stat-label">√ò Richtung</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" style="color: #64c8ff;" id="overview-error">-</div>
                    <div class="stat-label">√ò Fehler</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="overview-evaluated">0</div>
                    <div class="stat-label">Evaluiert</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="overview-pending">0</div>
                    <div class="stat-label">Ausstehend</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" style="color: #a78bfa;" id="overview-retrains">0</div>
                    <div class="stat-label">Re-Trainings</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="overview-models">0</div>
                    <div class="stat-label">Modelle</div>
                </div>
            </div>

            <!-- Performance by Symbol -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üéØ Performance nach Symbol</h2>
                    <button class="btn btn-sm btn-primary" onclick="loadOverviewPerformance()">Aktualisieren</button>
                </div>
                <div style="position: relative; height: 180px; padding: 0.5rem;">
                    <canvas id="symbol-performance-chart"></canvas>
                </div>
            </div>

            <!-- Recent Predictions & System Status Grid -->
            <div class="grid-2">
                <!-- Recent Predictions -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">üïê Letzte Prognosen</h2>
                    </div>
                    <div class="table-container" style="max-height: 250px;">
                        <table id="overview-recent-table">
                            <thead>
                                <tr>
                                    <th>Symbol</th>
                                    <th>Trend</th>
                                    <th>Horizont</th>
                                    <th>Zeit</th>
                                </tr>
                            </thead>
                            <tbody id="overview-recent-tbody">
                                <tr><td colspan="4" style="text-align: center; color: #666; padding: 1rem;">Lade...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- System Status -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">‚öôÔ∏è System Status</h2>
                    </div>
                    <div id="overview-system-status" style="padding: 0.5rem;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                            <div style="padding: 0.75rem; background: rgba(0,0,0,0.2); border-radius: 8px;">
                                <div style="font-size: 0.8rem; color: #888; margin-bottom: 0.3rem;">Auto-Evaluation</div>
                                <div id="overview-auto-eval-status" style="font-size: 1rem;">
                                    <span class="badge badge-success">Aktiv</span>
                                </div>
                            </div>
                            <div style="padding: 0.75rem; background: rgba(0,0,0,0.2); border-radius: 8px;">
                                <div style="font-size: 0.8rem; color: #888; margin-bottom: 0.3rem;">Auto-Retrain</div>
                                <div id="overview-auto-retrain-status" style="font-size: 1rem;">
                                    <span class="badge badge-success">Aktiv</span>
                                </div>
                            </div>
                            <div style="padding: 0.75rem; background: rgba(0,0,0,0.2); border-radius: 8px;">
                                <div style="font-size: 0.8rem; color: #888; margin-bottom: 0.3rem;">Auto-Forecast</div>
                                <div id="overview-auto-forecast-status" style="font-size: 1rem;">
                                    <span class="badge badge-success">Aktiv</span>
                                </div>
                            </div>
                            <div style="padding: 0.75rem; background: rgba(0,0,0,0.2); border-radius: 8px;">
                                <div style="font-size: 0.8rem; color: #888; margin-bottom: 0.3rem;">Retrain Cooldown</div>
                                <div id="overview-cooldown" style="font-size: 1rem; color: #ffb74d;">-</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Training Tab -->
        <div id="tab-training" class="tab-content">
            <div class="grid-2">
                <!-- Training Status -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Training Status</h2>
                        <button class="btn btn-sm btn-primary" onclick="refreshStatus()">Aktualisieren</button>
                    </div>
                    <div class="training-status">
                        <div id="training-message" style="font-size: 1.1rem; margin-bottom: 0.5rem;">Kein Training aktiv</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="training-progress" style="width: 0%"></div>
                        </div>
                        <div class="training-info">
                            <div class="training-stat">
                                <div class="value" id="stat-completed">-</div>
                                <div class="label">Abgeschlossen</div>
                            </div>
                            <div class="training-stat">
                                <div class="value" id="stat-successful" style="color: #4ade80;">-</div>
                                <div class="label">Erfolgreich</div>
                            </div>
                            <div class="training-stat">
                                <div class="value" id="stat-skipped" style="color: #fbbf24;">-</div>
                                <div class="label">√úbersprungen</div>
                            </div>
                            <div class="training-stat">
                                <div class="value" id="stat-failed" style="color: #f87171;">-</div>
                                <div class="label">Fehlgeschlagen</div>
                            </div>
                        </div>
                        <div class="training-timing" id="training-timing" style="display: none;">
                            <div class="timing-stat">
                                <div class="value" id="stat-elapsed">-</div>
                                <div class="label">Vergangen</div>
                            </div>
                            <div class="timing-stat">
                                <div class="value" id="stat-eta">-</div>
                                <div class="label">Verbleibend (ETA)</div>
                            </div>
                        </div>
                        <div class="timeframe-breakdown">
                            <div style="font-size: 0.85rem; opacity: 0.7; margin-bottom: 0.75rem;">Modelle nach Timeframe:</div>
                            <div class="training-info" style="grid-template-columns: repeat(6, 1fr);">
                                <div class="training-stat" title="5-Minuten Modelle">
                                    <div class="value" id="stat-tf-m5">-</div>
                                    <div class="label">M5</div>
                                </div>
                                <div class="training-stat" title="15-Minuten Modelle">
                                    <div class="value" id="stat-tf-m15">-</div>
                                    <div class="label">M15</div>
                                </div>
                                <div class="training-stat" title="St√ºndliche Modelle">
                                    <div class="value" id="stat-tf-h1">-</div>
                                    <div class="label">H1</div>
                                </div>
                                <div class="training-stat" title="4-Stunden Modelle">
                                    <div class="value" id="stat-tf-h4">-</div>
                                    <div class="label">H4</div>
                                </div>
                                <div class="training-stat" title="T√§gliche Modelle">
                                    <div class="value" id="stat-tf-d1">-</div>
                                    <div class="label">D1</div>
                                </div>
                                <div class="training-stat" title="W√∂chentliche Modelle">
                                    <div class="value" id="stat-tf-w1">-</div>
                                    <div class="label">W1</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Quick Actions -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Schnellaktionen</h2>
                    </div>
                    <div class="quick-actions">
                        <button class="btn btn-success" onclick="startTraining(['M5', 'M15', 'H1', 'H4', 'D1', 'W1'])" id="btn-train-all">
                            Multi-Timeframe Training (Alle)
                        </button>
                        <button class="btn btn-primary btn-sm" onclick="startTraining(['M5'])" id="btn-train-m5">
                            Nur M5
                        </button>
                        <button class="btn btn-primary btn-sm" onclick="startTraining(['M15'])" id="btn-train-m15">
                            Nur M15
                        </button>
                        <button class="btn btn-primary btn-sm" onclick="startTraining(['H1'])" id="btn-train-h1">
                            Nur H1
                        </button>
                        <button class="btn btn-primary btn-sm" onclick="startTraining(['H4'])" id="btn-train-h4">
                            Nur H4
                        </button>
                        <button class="btn btn-primary btn-sm" onclick="startTraining(['D1'])" id="btn-train-d1">
                            Nur D1
                        </button>
                        <button class="btn btn-primary btn-sm" onclick="startTraining(['W1'])" id="btn-train-w1">
                            Nur W1
                        </button>
                        <button class="btn btn-warning" onclick="startTraining(['M5', 'M15', 'H1', 'H4', 'D1', 'W1'], true)" id="btn-force-train" title="Trainiert alle Modelle neu, auch wenn bereits aktuell">
                            Force Train All
                        </button>
                        <button class="btn btn-danger" onclick="cancelTraining()" id="btn-cancel" disabled>
                            Training abbrechen
                        </button>
                        <button class="btn btn-warning" onclick="retrainFailed()" id="btn-retrain-failed">
                            Fehlgeschlagene erneut trainieren
                        </button>
                    </div>
                </div>
            </div>

            <!-- Failed Training Card -->
            <div class="card" id="failed-card" style="display: none;">
                <div class="card-header">
                    <h2 class="card-title">Fehlgeschlagene Trainings</h2>
                    <span class="badge badge-failed" id="failed-count">0</span>
                </div>
                <div class="failed-list" id="failed-list">
                    <!-- Dynamically populated -->
                </div>
            </div>
        </div>

        <!-- Models Tab -->
        <div id="tab-models" class="tab-content">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Trainierte Modelle</h2>
                    <span id="models-total" style="opacity: 0.7;">- Modelle</span>
                </div>
                <div class="toolbar">
                    <input type="text" class="search-box" id="model-search" placeholder="Symbol suchen..." oninput="filterModels()">
                    <select class="filter-select" id="favorite-filter" onchange="filterModels()">
                        <option value="">Alle Symbole</option>
                        <option value="favorites">&#9733; Nur Favoriten</option>
                        <option value="non-favorites">Ohne Favoriten</option>
                    </select>
                    <select class="filter-select" id="timeframe-filter" onchange="filterModels()">
                        <option value="">Alle Timeframes</option>
                        <option value="M5">M5</option>
                        <option value="M15">M15</option>
                        <option value="H1">H1</option>
                        <option value="H4">H4</option>
                        <option value="D1">D1</option>
                        <option value="W1">W1</option>
                    </select>
                    <button class="btn btn-primary" onclick="loadModels()">Aktualisieren</button>
                    <div class="legend" style="margin-left: auto;">
                        <span title="Trend-Prognose"><span style="color: #4ade80;">‚Üë</span> Steigend <span style="opacity: 0.5;">/</span> <span style="color: #f87171;">‚Üì</span> Fallend</span>
                        <span title="Evaluierungsstatus"><span style="color: #fbbf24;">‚è≥</span> Ausstehend <span style="opacity: 0.5;">/</span> <span style="color: #4ade80;">‚úì</span> Korrekt <span style="opacity: 0.5;">/</span> <span style="color: #f87171;">‚úó</span> Falsch</span>
                        <span title="Favorit"><span style="color: #fbbf24;">‚òÖ</span> Favorit</span>
                    </div>
                </div>
                <div class="table-container">
                    <table id="models-table">
                        <thead>
                            <tr>
                                <th style="width: 40px; text-align: center;" title="Favorit">&#9733;</th>
                                <th>Symbol</th>
                                <th>Timeframe</th>
                                <th>Letzte Prognose</th>
                                <th>Trainiert am</th>
                                <th>Samples</th>
                                <th>Loss</th>
                                <th>Aktionen</th>
                            </tr>
                        </thead>
                        <tbody id="models-tbody">
                            <tr><td colspan="8" style="text-align: center; opacity: 0.5;">Lade Modelle...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Forecast Tab -->
        <div id="tab-forecast" class="tab-content">
            <!-- Batch Forecast Card -->
            <div class="card" style="margin-bottom: 1rem;">
                <div class="card-header">
                    <h2 class="card-title">Batch-Prognosen</h2>
                    <span id="batch-forecast-status" style="opacity: 0.7;"></span>
                </div>
                <div style="display: flex; gap: 1rem; flex-wrap: wrap; align-items: center;">
                    <div class="form-group" style="margin: 0;">
                        <label style="font-size: 0.85rem; opacity: 0.7;">Timeframe</label>
                        <select class="filter-select" id="batch-timeframe" style="min-width: 180px;">
                            <option value="M5">M5 (5 Min)</option>
                            <option value="M15">M15 (15 Min)</option>
                            <option value="H1" selected>H1 (1 Stunde)</option>
                            <option value="H4">H4 (4 Stunden)</option>
                            <option value="D1">D1 (T√§glich)</option>
                            <option value="W1">W1 (W√∂chentlich)</option>
                        </select>
                    </div>
                    <button class="btn btn-success" onclick="runBatchForecast('favorites')" id="btn-forecast-favorites">
                        ‚≠ê Prognose f√ºr Favoriten
                    </button>
                    <button class="btn btn-primary" onclick="runBatchForecast('all')" id="btn-forecast-all">
                        üìä Prognose alle Symbole
                    </button>
                    <button class="btn btn-sm" onclick="cancelBatchForecast()" id="btn-cancel-batch" style="display: none;">
                        ‚ùå Abbrechen
                    </button>
                </div>
                <!-- Batch Progress -->
                <div id="batch-progress-container" style="display: none; margin-top: 1rem;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                        <span id="batch-progress-text">0 / 0 Symbole</span>
                        <span id="batch-progress-percent">0%</span>
                    </div>
                    <div style="background: rgba(0,0,0,0.3); border-radius: 4px; height: 8px; overflow: hidden;">
                        <div id="batch-progress-bar" style="background: linear-gradient(90deg, #4ade80, #22c55e); height: 100%; width: 0%; transition: width 0.3s;"></div>
                    </div>
                    <div id="batch-results-summary" style="margin-top: 0.5rem; font-size: 0.85rem; opacity: 0.8;"></div>
                </div>
            </div>

            <!-- Auto-Prognose Card -->
            <div class="card" style="margin-bottom: 1rem;">
                <div class="card-header">
                    <h2 class="card-title">üîÑ Auto-Prognose</h2>
                    <button class="btn btn-sm btn-primary" onclick="loadAutoForecastStatus()">Status aktualisieren</button>
                </div>

                <div class="grid-2" style="margin-bottom: 1rem;">
                    <!-- Favoriten Auto-Prognose -->
                    <div style="padding: 1rem; background: rgba(251, 191, 36, 0.1); border: 1px solid rgba(251, 191, 36, 0.3); border-radius: 8px;">
                        <h4 style="margin: 0 0 0.75rem 0; color: #fbbf24;">‚≠ê Favoriten (Timeframe-basiert)</h4>
                        <p style="font-size: 0.85rem; opacity: 0.8; margin-bottom: 0.75rem;">
                            Automatische Prognosen f√ºr Favoriten:<br>
                            ‚Ä¢ M5: 5 Min ‚Ä¢ M15: 15 Min ‚Ä¢ H1: 1 Std<br>
                            ‚Ä¢ H4: 4 Std ‚Ä¢ D1: t√§glich ‚Ä¢ W1: w√∂chentlich
                        </p>
                        <div id="favorites-auto-status" style="margin-bottom: 0.75rem; font-size: 0.9rem;">
                            <span style="opacity: 0.5;">Status wird geladen...</span>
                        </div>
                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 0.75rem;">
                            <label style="display: flex; align-items: center; gap: 0.3rem; font-size: 0.85rem;">
                                <input type="checkbox" id="auto-tf-m5" onchange="saveTimeframeSelection()"> M5
                            </label>
                            <label style="display: flex; align-items: center; gap: 0.3rem; font-size: 0.85rem;">
                                <input type="checkbox" id="auto-tf-m15" checked onchange="saveTimeframeSelection()"> M15
                            </label>
                            <label style="display: flex; align-items: center; gap: 0.3rem; font-size: 0.85rem;">
                                <input type="checkbox" id="auto-tf-h1" checked onchange="saveTimeframeSelection()"> H1
                            </label>
                            <label style="display: flex; align-items: center; gap: 0.3rem; font-size: 0.85rem;">
                                <input type="checkbox" id="auto-tf-h4" onchange="saveTimeframeSelection()"> H4
                            </label>
                            <label style="display: flex; align-items: center; gap: 0.3rem; font-size: 0.85rem;">
                                <input type="checkbox" id="auto-tf-d1" checked onchange="saveTimeframeSelection()"> D1
                            </label>
                            <label style="display: flex; align-items: center; gap: 0.3rem; font-size: 0.85rem;">
                                <input type="checkbox" id="auto-tf-w1" onchange="saveTimeframeSelection()"> W1
                            </label>
                        </div>
                        <div style="display: flex; gap: 0.5rem;">
                            <button class="btn btn-success btn-sm" id="btn-start-favorites-auto" onclick="startFavoritesAutoForecast()">
                                ‚ñ∂Ô∏è Starten
                            </button>
                            <button class="btn btn-danger btn-sm" id="btn-stop-favorites-auto" onclick="stopFavoritesAutoForecast()" style="display: none;">
                                ‚èπÔ∏è Stoppen
                            </button>
                        </div>
                    </div>

                    <!-- T√§gliche Auto-Prognose (Nicht-Favoriten) -->
                    <div style="padding: 1rem; background: rgba(100, 200, 255, 0.1); border: 1px solid rgba(100, 200, 255, 0.3); border-radius: 8px;">
                        <h4 style="margin: 0 0 0.75rem 0; color: #64c8ff;">üìÖ T√§glich (Restliche Symbole)</h4>
                        <p style="font-size: 0.85rem; opacity: 0.8; margin-bottom: 0.75rem;">
                            Einmalige t√§gliche Prognose f√ºr alle Nicht-Favoriten<br>
                            mit trainierten Modellen (H1 Timeframe).
                        </p>
                        <div id="daily-auto-status" style="margin-bottom: 0.75rem; font-size: 0.9rem;">
                            <span style="opacity: 0.5;">Status wird geladen...</span>
                        </div>
                        <div style="display: flex; gap: 0.5rem; align-items: center; margin-bottom: 0.75rem;">
                            <label style="font-size: 0.85rem; opacity: 0.8;">Zeit:</label>
                            <input type="time" id="daily-scheduled-time" value="05:00"
                                   style="padding: 0.4rem; border-radius: 4px; border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.2); color: #e8e8e8;">
                            <select id="daily-timezone" style="padding: 0.4rem; border-radius: 4px; border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.2); color: #e8e8e8; font-size: 0.85rem;">
                                <option value="Europe/Zurich">Europe/Zurich</option>
                                <option value="Europe/Berlin">Europe/Berlin</option>
                                <option value="Europe/London">Europe/London</option>
                                <option value="America/New_York">America/New_York</option>
                                <option value="Asia/Tokyo">Asia/Tokyo</option>
                                <option value="UTC">UTC</option>
                            </select>
                        </div>
                        <div style="display: flex; gap: 0.5rem;">
                            <button class="btn btn-success btn-sm" id="btn-start-daily-auto" onclick="startDailyAutoForecast()">
                                ‚ñ∂Ô∏è Starten
                            </button>
                            <button class="btn btn-danger btn-sm" id="btn-stop-daily-auto" onclick="stopDailyAutoForecast()" style="display: none;">
                                ‚èπÔ∏è Stoppen
                            </button>
                            <button class="btn btn-sm btn-primary" onclick="runDailyForecastNow()" title="Sofort ausf√ºhren">
                                ‚ö° Jetzt ausf√ºhren
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Auto-Prognose Statistiken -->
                <div id="auto-forecast-stats" style="padding: 0.75rem; background: rgba(0,0,0,0.2); border-radius: 8px;">
                    <div style="display: flex; gap: 2rem; flex-wrap: wrap; font-size: 0.9rem;">
                        <div>
                            <span style="opacity: 0.7;">Favoriten Prognosen:</span>
                            <span id="stat-favorites-total" style="color: #fbbf24; margin-left: 0.3rem;">0</span>
                            <span style="opacity: 0.5; margin-left: 0.3rem;">(Fehler: <span id="stat-favorites-failed" style="color: #f87171;">0</span>)</span>
                        </div>
                        <div>
                            <span style="opacity: 0.7;">T√§gliche Prognosen:</span>
                            <span id="stat-daily-total" style="color: #64c8ff; margin-left: 0.3rem;">0</span>
                            <span style="opacity: 0.5; margin-left: 0.3rem;">(Fehler: <span id="stat-daily-failed" style="color: #f87171;">0</span>)</span>
                        </div>
                        <div>
                            <span style="opacity: 0.7;">Gesamt Prognosen:</span>
                            <span id="stat-forecast-count" style="color: #4ade80; margin-left: 0.3rem;">0</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="grid-2">
                <!-- Forecast Form -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Einzelne Prognose</h2>
                    </div>
                    <div class="forecast-form">
                        <div class="form-group">
                            <label for="forecast-symbol">Symbol</label>
                            <select class="filter-select" id="forecast-symbol" style="width: 100%;">
                                <option value="">Symbol w√§hlen...</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="forecast-timeframe">Timeframe</label>
                            <select class="filter-select" id="forecast-timeframe" style="width: 100%;">
                                <option value="M5">M5 (5 Min) - 1h Horizont</option>
                                <option value="M15">M15 (15 Min) - 2h Horizont</option>
                                <option value="H1" selected>H1 (1 Stunde) - 24h Horizont</option>
                                <option value="H4">H4 (4 Stunden) - 48h Horizont</option>
                                <option value="D1">D1 (T√§glich) - 7 Tage Horizont</option>
                                <option value="W1">W1 (W√∂chentlich) - 4 Wochen Horizont</option>
                            </select>
                        </div>
                        <div class="form-group" style="margin-top: 1rem;">
                            <button class="btn btn-success" onclick="runForecast()" id="btn-forecast" style="width: 100%; padding: 1rem;">
                                Prognose erstellen
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Forecast Summary -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Zusammenfassung</h2>
                    </div>
                    <div id="forecast-summary" style="opacity: 0.5; text-align: center; padding: 2rem;">
                        W√§hle ein Symbol und starte die Prognose
                    </div>
                </div>
            </div>

            <!-- Forecast Results -->
            <div class="card" id="forecast-results-card" style="display: none;">
                <div class="card-header">
                    <h2 class="card-title">Prognoseergebnisse</h2>
                    <span id="forecast-info" style="opacity: 0.7;"></span>
                </div>

                <!-- Chart Container -->
                <div id="forecast-chart" style="height: 300px; margin-bottom: 1.5rem; position: relative;">
                    <canvas id="forecastCanvas"></canvas>
                </div>

                <!-- Forecast Table -->
                <div class="table-container" style="max-height: 300px;">
                    <table>
                        <thead>
                            <tr>
                                <th>Zeitpunkt</th>
                                <th>Prognose</th>
                                <th>Konfidenz (Tief)</th>
                                <th>Konfidenz (Hoch)</th>
                                <th>Spanne</th>
                            </tr>
                        </thead>
                        <tbody id="forecast-tbody">
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Performance Tab -->
        <div id="tab-performance" class="tab-content">
            <!-- Auto-Evaluation Status Card -->
            <div class="card" style="margin-bottom: 1rem;">
                <div class="card-header">
                    <h2 class="card-title">Auto-Evaluierung & Retrain</h2>
                    <button class="btn btn-sm btn-primary" onclick="loadAutoStatus()">Aktualisieren</button>
                </div>
                <div id="auto-status-content">
                    <div class="grid-2-equal" style="margin-bottom: 1rem;">
                        <!-- Auto-Evaluation Status -->
                        <div style="padding: 1rem; background: rgba(0,0,0,0.2); border-radius: 8px;">
                            <h4 style="margin: 0 0 0.5rem 0; opacity: 0.8;">Auto-Evaluierung</h4>
                            <div id="auto-eval-status">
                                <div style="opacity: 0.5;">Lade Status...</div>
                            </div>
                            <!-- Prediction Stats (KPIs) -->
                            <div class="stats-bar" id="prediction-stats" style="margin-top: 0.75rem; padding: 0.5rem 0;">
                                <div class="stat-item">
                                    <div class="stat-value" id="stat-pending">-</div>
                                    <div class="stat-label">Ausstehend total</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-value" id="stat-waiting">-</div>
                                    <div class="stat-label">Warten auf Horizont</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-value" id="stat-ready">-</div>
                                    <div class="stat-label">Bereit zur Eval.</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-value" id="stat-evaluated">-</div>
                                    <div class="stat-label">Evaluiert</div>
                                </div>
                            </div>
                            <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-top: 0.75rem;">
                                <button class="btn btn-sm" id="btn-toggle-auto-eval" onclick="toggleAutoEvaluation()">
                                    ‚è∏Ô∏è Auto-Eval pausieren
                                </button>
                                <button class="btn btn-sm btn-success" id="btn-manual-eval" onclick="runManualEvaluation()">
                                    üìä Jetzt evaluieren
                                </button>
                            </div>
                        </div>
                        <!-- Auto-Retrain Status -->
                        <div style="padding: 1rem; background: rgba(0,0,0,0.2); border-radius: 8px;">
                            <h4 style="margin: 0 0 0.5rem 0; opacity: 0.8;">Auto-Retrain</h4>
                            <div id="auto-retrain-status">
                                <div style="opacity: 0.5;">Lade Status...</div>
                            </div>
                            <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-top: 0.75rem;">
                                <button class="btn btn-sm" id="btn-toggle-auto-retrain" onclick="toggleAutoRetrain()">
                                    ‚è∏Ô∏è Auto-Retrain pausieren
                                </button>
                                <button class="btn btn-sm btn-warning" id="btn-manual-retrain" onclick="runManualRetrain()">
                                    üîÑ Schlechte Modelle retrainieren
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Performance Table Card -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Modell Performance</h2>
                    <button class="btn btn-sm btn-primary" onclick="loadPerformance()">Aktualisieren</button>
                </div>
                <p style="opacity: 0.7; margin-bottom: 1rem;">
                    √úbersicht der Prognosegenauigkeit basierend auf historischen Evaluierungen.
                    Performance-Daten werden gesammelt, wenn Prognosen mit tats√§chlichen Preisen verglichen werden.
                </p>
                <!-- Evaluation Status -->
                <div id="evaluation-status" style="display: none; margin-bottom: 1rem; padding: 0.75rem; background: rgba(100, 200, 255, 0.1); border-radius: 8px; border: 1px solid rgba(100, 200, 255, 0.2);">
                    <div style="display: flex; align-items: center; gap: 0.75rem;">
                        <span id="evaluation-message">Evaluierung l√§uft...</span>
                    </div>
                    <!-- Progress bar -->
                    <div id="evaluation-progress-container" style="display: none; margin-top: 0.5rem;">
                        <div style="background: rgba(255,255,255,0.1); border-radius: 4px; height: 6px; overflow: hidden;">
                            <div id="evaluation-progress-bar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #64b5f6, #42a5f5); border-radius: 4px; transition: width 0.3s ease;"></div>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-top: 0.25rem; font-size: 0.75rem; opacity: 0.7;">
                            <span id="evaluation-progress-text">0%</span>
                            <span id="evaluation-progress-count"></span>
                        </div>
                    </div>
                </div>
                <div class="table-container">
                    <table id="performance-table">
                        <thead>
                            <tr>
                                <th>Symbol</th>
                                <th>Evaluiert</th>
                                <th>√ò Fehler</th>
                                <th>Richtung</th>
                                <th>Letzte Eval.</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody id="performance-tbody">
                            <tr><td colspan="6" style="text-align: center; opacity: 0.5;">Lade Performance-Daten...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Self-Learning Tab -->
        <div id="tab-selflearning" class="tab-content">
            <!-- Closed-Loop Visualization -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">ü§ñ Self-Learning System</h2>
                    <div style="display: flex; gap: 0.5rem;">
                        <button class="btn btn-purple" id="selflearn-toggle-btn" onclick="toggleSelfLearning()">‚úÖ Aktiviert</button>
                        <button class="btn btn-warning" id="selflearn-manual-btn" onclick="triggerManualRetrain()">‚öôÔ∏è Manuell trainieren</button>
                    </div>
                </div>

                <!-- Manual Retrain Progress -->
                <div id="selflearn-retrain-progress" style="margin: 1rem 0; display: none;">
                    <div style="background: rgba(0,0,0,0.2); border-radius: 8px; padding: 1rem;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                            <span id="selflearn-retrain-status">Training l√§uft...</span>
                            <span id="selflearn-retrain-progress-text">0%</span>
                        </div>
                        <div style="background: rgba(255,255,255,0.1); height: 8px; border-radius: 4px; overflow: hidden;">
                            <div id="selflearn-retrain-progress-bar" style="background: #ffb74d; height: 100%; width: 0%; transition: width 0.3s;"></div>
                        </div>
                        <div id="selflearn-retrain-details" style="margin-top: 0.5rem; font-size: 0.8rem; color: #888;"></div>
                    </div>
                </div>

                <p style="opacity: 0.8; margin-bottom: 1rem;">
                    Das System lernt kontinuierlich aus seinen Prognose-Fehlern durch einen geschlossenen Feedback-Loop.
                    Bei schlechter Performance wird automatisch ein Re-Training getriggert.
                </p>

                <!-- Closed-Loop Diagram -->
                <div style="background: rgba(100, 200, 255, 0.1); border-radius: 12px; padding: 1.5rem; margin-bottom: 1.5rem;">
                    <h3 style="color: #64c8ff; margin-bottom: 1rem; font-size: 1rem;">Closed-Loop Feedback</h3>
                    <div style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; gap: 1rem;">
                        <div style="text-align: center;">
                            <div style="width: 80px; height: 80px; border-radius: 50%; background: rgba(100, 200, 255, 0.2); display: flex; align-items: center; justify-content: center; margin: 0 auto 0.5rem; font-size: 1.8rem;">üéØ</div>
                            <div style="font-size: 0.85rem; color: #64c8ff;">1. Prognose</div>
                        </div>
                        <div style="color: #666; font-size: 1.5rem;">‚Üí</div>
                        <div style="text-align: center;">
                            <div style="width: 80px; height: 80px; border-radius: 50%; background: rgba(129, 199, 132, 0.2); display: flex; align-items: center; justify-content: center; margin: 0 auto 0.5rem; font-size: 1.8rem;">‚úÖ</div>
                            <div style="font-size: 0.85rem; color: #81c784;">2. Evaluierung</div>
                        </div>
                        <div style="color: #666; font-size: 1.5rem;">‚Üí</div>
                        <div style="text-align: center;">
                            <div style="width: 80px; height: 80px; border-radius: 50%; background: rgba(255, 183, 77, 0.2); display: flex; align-items: center; justify-content: center; margin: 0 auto 0.5rem; font-size: 1.8rem;">üìä</div>
                            <div style="font-size: 0.85rem; color: #ffb74d;">3. Analyse</div>
                        </div>
                        <div style="color: #666; font-size: 1.5rem;">‚Üí</div>
                        <div style="text-align: center;">
                            <div style="width: 80px; height: 80px; border-radius: 50%; background: rgba(167, 139, 250, 0.2); display: flex; align-items: center; justify-content: center; margin: 0 auto 0.5rem; font-size: 1.8rem;">ü§ñ</div>
                            <div style="font-size: 0.85rem; color: #a78bfa;">4. Re-Train</div>
                        </div>
                        <div style="color: #666; font-size: 1.5rem;">‚Ü©</div>
                    </div>
                </div>

                <!-- Stats Grid -->
                <div class="stats-bar" id="selflearn-stats" style="margin-bottom: 0;">
                    <div class="stat-item">
                        <div class="stat-value" style="color: #a78bfa;" id="sl-stat-threshold">45%</div>
                        <div class="stat-label">Direction-Schwelle</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="sl-stat-total-retrains">0</div>
                        <div class="stat-label">Re-Trainings</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" style="color: #81c784;" id="sl-stat-improvement">-</div>
                        <div class="stat-label">Avg. Accuracy</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="sl-stat-cooldown">-</div>
                        <div class="stat-label">Cooldown</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="sl-stat-pending">0</div>
                        <div class="stat-label">Ausstehend</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="sl-stat-evaluated">0</div>
                        <div class="stat-label">Evaluiert</div>
                    </div>
                </div>
            </div>

            <!-- Configuration Card -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">‚öôÔ∏è Konfiguration</h2>
                </div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 1.5rem;">
                    <div>
                        <label style="color: #aaa; display: block; margin-bottom: 0.5rem;">Richtungs-Schwelle</label>
                        <select class="filter-select" id="sl-threshold-select" onchange="updateSelfLearnConfig()" style="width: 100%;">
                            <option value="0.40">40% (Niedrig)</option>
                            <option value="0.45" selected>45% (Standard)</option>
                            <option value="0.50">50%</option>
                            <option value="0.55">55% (Hoch)</option>
                        </select>
                        <small style="color: #666; display: block; margin-top: 0.3rem;">Re-Training wenn Accuracy darunter f√§llt</small>
                    </div>
                    <div>
                        <label style="color: #aaa; display: block; margin-bottom: 0.5rem;">Cooldown-Periode</label>
                        <select class="filter-select" id="sl-cooldown-select" onchange="updateSelfLearnCooldown()" style="width: 100%;">
                            <option value="2">2 Stunden</option>
                            <option value="4" selected>4 Stunden (Standard)</option>
                            <option value="6">6 Stunden</option>
                            <option value="12">12 Stunden</option>
                            <option value="24">24 Stunden</option>
                        </select>
                        <small style="color: #666; display: block; margin-top: 0.3rem;">Mindestwartezeit zwischen Trainings</small>
                    </div>
                    <div>
                        <label style="color: #aaa; display: block; margin-bottom: 0.5rem;">Min. Evaluierungen</label>
                        <select class="filter-select" id="sl-min-evals-select" style="width: 100%;">
                            <option value="5">5</option>
                            <option value="10" selected>10 (Standard)</option>
                            <option value="15">15</option>
                            <option value="20">20</option>
                        </select>
                        <small style="color: #666; display: block; margin-top: 0.3rem;">Mindestanzahl Evaluierungen f√ºr Trigger</small>
                    </div>
                    <div>
                        <label style="color: #aaa; display: block; margin-bottom: 0.5rem;">Eval-Intervall</label>
                        <select class="filter-select" id="sl-interval-select" style="width: 100%;">
                            <option value="60">1 Minute</option>
                            <option value="180">3 Minuten</option>
                            <option value="300" selected>5 Minuten (Standard)</option>
                            <option value="600">10 Minuten</option>
                        </select>
                        <small style="color: #666; display: block; margin-top: 0.3rem;">Automatischer Evaluierungs-Zyklus</small>
                    </div>
                </div>
            </div>

            <!-- Symbols Needing Retrain -->
            <div class="card" id="sl-retrain-candidates-card" style="display: none;">
                <div class="card-header">
                    <h2 class="card-title">‚ö†Ô∏è Symbole mit schlechter Performance</h2>
                    <button class="btn btn-sm btn-warning" onclick="triggerManualRetrain()">Alle retrainieren</button>
                </div>
                <div id="sl-retrain-candidates">
                    <!-- Dynamisch bef√ºllt -->
                </div>
            </div>

            <!-- Recent Evaluations Table -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üìã Letzte Evaluierungen</h2>
                    <div style="display: flex; gap: 0.5rem;">
                        <button class="btn btn-sm btn-primary" onclick="loadSelfLearningEvaluations()">üîÑ Aktualisieren</button>
                        <button class="btn btn-sm btn-success" onclick="triggerManualEvaluation()">üìä Jetzt evaluieren</button>
                    </div>
                </div>
                <div class="table-container" style="max-height: 400px;">
                    <table id="sl-evaluations-table">
                        <thead>
                            <tr>
                                <th>Zeitpunkt</th>
                                <th>Symbol</th>
                                <th>Horizont</th>
                                <th>Prognose</th>
                                <th>Tats√§chlich</th>
                                <th>Fehler</th>
                                <th>Richtung</th>
                            </tr>
                        </thead>
                        <tbody id="sl-evaluations-tbody">
                            <tr>
                                <td colspan="7" style="text-align: center; padding: 2rem; color: #666;">
                                    Lade Evaluierungen...
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Performance by Symbol -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">üìà Performance nach Symbol</h2>
                    <button class="btn btn-sm btn-primary" onclick="loadSelfLearningPerformance()">üîÑ Aktualisieren</button>
                </div>
                <div class="table-container" style="max-height: 350px;">
                    <table id="sl-performance-table">
                        <thead>
                            <tr>
                                <th>Symbol</th>
                                <th>Evaluiert</th>
                                <th>√ò Fehler</th>
                                <th>Richtung</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody id="sl-performance-tbody">
                            <tr>
                                <td colspan="5" style="text-align: center; padding: 2rem; color: #666;">
                                    Lade Performance-Daten...
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Backup Tab -->
        <div id="tab-backup" class="tab-content">
            <div class="grid-2">
                <!-- Status Card -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Backup Status</h2>
                        <button class="btn btn-sm btn-primary" onclick="loadBackupStatus()">Aktualisieren</button>
                    </div>
                    <div id="backup-status-content">
                        <div style="opacity: 0.5; text-align: center; padding: 2rem;">Lade Status...</div>
                    </div>
                </div>

                <!-- Quick Actions -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Schnellaktionen</h2>
                    </div>
                    <div class="quick-actions">
                        <button class="btn btn-success" onclick="backupModels()" id="btn-backup-models">
                            üíæ Modelle sichern (ZIP)
                        </button>
                        <button class="btn btn-success" onclick="backupPredictions()" id="btn-backup-predictions">
                            üíæ Prognosen sichern (JSON)
                        </button>
                        <div style="border-top: 1px solid rgba(255,255,255,0.1); margin: 1rem 0;"></div>
                        <button class="btn btn-primary" onclick="document.getElementById('restore-models-file').click()">
                            üì• Modelle wiederherstellen
                        </button>
                        <input type="file" id="restore-models-file" accept=".zip" style="display: none;" onchange="restoreModels(this)">
                        <button class="btn btn-primary" onclick="document.getElementById('restore-predictions-file').click()">
                            üì• Prognosen wiederherstellen
                        </button>
                        <input type="file" id="restore-predictions-file" accept=".json" style="display: none;" onchange="restorePredictions(this)">
                        <div style="border-top: 1px solid rgba(255,255,255,0.1); margin: 1rem 0;"></div>
                        <button class="btn btn-danger" onclick="clearPredictions()" id="btn-clear-predictions">
                            üóëÔ∏è Prognose-Daten l√∂schen
                        </button>
                    </div>
                </div>
            </div>

            <!-- Backup Result -->
            <div class="card" id="backup-result-card" style="display: none;">
                <div class="card-header">
                    <h2 class="card-title" id="backup-result-title">Backup Ergebnis</h2>
                    <button class="btn btn-sm btn-success" id="backup-download-btn" onclick="downloadBackup()" style="display: none;">
                        ‚¨áÔ∏è Herunterladen
                    </button>
                </div>
                <div id="backup-result-content">
                </div>
            </div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <!-- Forecast Details Modal -->
    <div class="modal-overlay" id="forecast-modal" onclick="closeForecastModal(event)">
        <div class="modal" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h3 class="modal-title" id="forecast-modal-title">Prognose Details</h3>
                <button class="modal-close" onclick="closeForecastModal()">&times;</button>
            </div>
            <div class="modal-body" id="forecast-modal-body">
                <!-- Content will be filled dynamically -->
            </div>
        </div>
    </div>

    <script>
        const API_BASE = '/nhits/api/v1';
        let allModels = [];
        let latestForecasts = {};  // Cache for latest forecasts per model
        let trainingInterval = null;
        let serviceStartTime = null;

        // Chart instances
        let learningProgressChart = null;
        let symbolPerformanceChart = null;

        // ==================== Overview Tab Functions ====================

        async function loadOverviewData() {
            await Promise.all([
                loadLearningProgress(),
                loadOverviewPerformance(),
                loadOverviewRecentPredictions(),
                loadOverviewSystemStatus()
            ]);
        }

        async function loadLearningProgress() {
            const summaryEl = document.getElementById('learning-progress-summary');
            const chartCanvas = document.getElementById('learning-progress-chart');
            const filterSelect = document.getElementById('overview-symbol-filter');

            if (!chartCanvas) return;

            try {
                // Get evaluated predictions for the chart
                const [evalRes, perfRes, autoRes] = await Promise.all([
                    fetch(`${API_BASE}/forecast/evaluated?limit=100`),
                    fetch(`${API_BASE}/forecast/performance`),
                    fetch(`${API_BASE}/forecast/auto-status`)
                ]);

                const evalData = await evalRes.json();
                const perfData = await perfRes.json();
                const autoData = await autoRes.json();

                // Update KPI stats
                const predictions = autoData.predictions || {};
                document.getElementById('overview-evaluated').textContent = predictions.evaluated_count || 0;
                document.getElementById('overview-pending').textContent = predictions.pending_count || 0;
                document.getElementById('overview-retrains').textContent = autoData.auto_retrain?.total_retrains || 0;

                // Populate symbol filter
                const symbols = Object.keys(perfData.by_symbol || {});
                document.getElementById('overview-models').textContent = symbols.length;

                if (filterSelect.options.length <= 1) {
                    symbols.forEach(sym => {
                        const opt = document.createElement('option');
                        opt.value = sym;
                        opt.textContent = sym;
                        filterSelect.appendChild(opt);
                    });
                }

                // Calculate overall metrics
                let totalAcc = 0, totalErr = 0, symbolCount = 0;
                for (const [sym, perf] of Object.entries(perfData.by_symbol || {})) {
                    if (perf.evaluated > 0) {
                        totalAcc += perf.direction_accuracy * 100;
                        totalErr += perf.avg_error_pct || 0;
                        symbolCount++;
                    }
                }

                const avgAccuracy = symbolCount > 0 ? (totalAcc / symbolCount).toFixed(1) : '-';
                const avgError = symbolCount > 0 ? (totalErr / symbolCount).toFixed(2) : '-';

                document.getElementById('overview-accuracy').textContent = avgAccuracy !== '-' ? avgAccuracy + '%' : '-';
                document.getElementById('overview-accuracy').style.color = parseFloat(avgAccuracy) >= 50 ? '#4ade80' : '#fbbf24';
                document.getElementById('overview-error').textContent = avgError !== '-' ? avgError + '%' : '-';

                // Group evaluations by date for the chart
                const evalsByDate = {};
                const selectedSymbol = filterSelect.value;

                (evalData.predictions || []).forEach(pred => {
                    if (selectedSymbol !== 'all' && pred.symbol !== selectedSymbol) return;

                    const date = pred.evaluated_at ? pred.evaluated_at.split('T')[0] : null;
                    if (!date) return;

                    if (!evalsByDate[date]) {
                        evalsByDate[date] = { correct: 0, total: 0, errorSum: 0 };
                    }
                    evalsByDate[date].total++;
                    if (pred.direction_correct) evalsByDate[date].correct++;
                    evalsByDate[date].errorSum += Math.abs(pred.prediction_error_pct || 0);
                });

                const dates = Object.keys(evalsByDate).sort();
                const accuracyData = dates.map(d => (evalsByDate[d].correct / evalsByDate[d].total * 100).toFixed(1));
                const errorData = dates.map(d => (evalsByDate[d].errorSum / evalsByDate[d].total).toFixed(2));

                // Destroy existing chart
                if (learningProgressChart) {
                    learningProgressChart.destroy();
                }

                if (dates.length === 0) {
                    summaryEl.innerHTML = 'Keine Metriken-Historie verf√ºgbar. Erstellen Sie Prognosen und warten Sie auf Evaluierungen.';
                    return;
                }

                // Create chart
                const ctx = chartCanvas.getContext('2d');
                learningProgressChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Richtung %',
                                data: accuracyData,
                                borderColor: '#4ade80',
                                backgroundColor: 'rgba(74, 222, 128, 0.1)',
                                borderWidth: 2,
                                fill: true,
                                tension: 0.3,
                                pointRadius: 4
                            },
                            {
                                label: 'Fehler %',
                                data: errorData,
                                borderColor: '#64c8ff',
                                backgroundColor: 'rgba(100, 200, 255, 0.1)',
                                borderWidth: 2,
                                fill: true,
                                tension: 0.3,
                                pointRadius: 4
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { intersect: false, mode: 'index' },
                        plugins: {
                            legend: {
                                position: 'top',
                                labels: { color: '#888', font: { size: 11 }, boxWidth: 12, padding: 8 }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(26, 26, 46, 0.95)',
                                titleColor: '#fff',
                                bodyColor: '#ccc',
                                borderColor: 'rgba(100, 200, 255, 0.3)',
                                borderWidth: 1
                            }
                        },
                        scales: {
                            x: {
                                grid: { color: 'rgba(255, 255, 255, 0.05)' },
                                ticks: { color: '#666', font: { size: 10 } }
                            },
                            y: {
                                min: 0,
                                grid: { color: 'rgba(255, 255, 255, 0.05)' },
                                ticks: { color: '#666', font: { size: 10 }, callback: v => v + '%' }
                            }
                        }
                    }
                });

                // Calculate trend
                const latestAcc = parseFloat(accuracyData[accuracyData.length - 1]) || 0;
                const firstAcc = parseFloat(accuracyData[0]) || 0;
                const accTrend = latestAcc - firstAcc;
                const trendColor = accTrend > 0 ? '#4ade80' : accTrend < 0 ? '#f87171' : '#888';

                summaryEl.innerHTML = `
                    <span style="margin-right: 1.5rem;">üìà Trend: <span style="color: ${trendColor};">${accTrend > 0 ? '+' : ''}${accTrend.toFixed(1)}%</span></span>
                    <span style="margin-right: 1.5rem;">Letzte Richtung: <strong>${latestAcc.toFixed(1)}%</strong></span>
                    <span>Datenpunkte: ${dates.length}</span>
                `;

            } catch (err) {
                console.error('Failed to load learning progress:', err);
                summaryEl.innerHTML = '<span style="color: #f87171;">Fehler beim Laden</span>';
            }
        }

        async function loadOverviewPerformance() {
            const chartCanvas = document.getElementById('symbol-performance-chart');
            if (!chartCanvas) return;

            try {
                const res = await fetch(`${API_BASE}/forecast/performance`);
                const data = await res.json();

                const symbols = [];
                const accuracyData = [];
                const errorData = [];

                for (const [sym, perf] of Object.entries(data.by_symbol || {})) {
                    if (perf.evaluated > 0) {
                        symbols.push(sym);
                        accuracyData.push((perf.direction_accuracy * 100).toFixed(1));
                        errorData.push(perf.avg_error_pct?.toFixed(2) || 0);
                    }
                }

                // Destroy existing chart
                if (symbolPerformanceChart) {
                    symbolPerformanceChart.destroy();
                }

                if (symbols.length === 0) return;

                const ctx = chartCanvas.getContext('2d');
                symbolPerformanceChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: symbols,
                        datasets: [
                            {
                                label: 'Richtung %',
                                data: accuracyData,
                                backgroundColor: 'rgba(74, 222, 128, 0.7)',
                                borderColor: '#4ade80',
                                borderWidth: 1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            x: {
                                grid: { display: false },
                                ticks: { color: '#888', font: { size: 10 } }
                            },
                            y: {
                                min: 0,
                                max: 100,
                                grid: { color: 'rgba(255, 255, 255, 0.05)' },
                                ticks: { color: '#666', callback: v => v + '%' }
                            }
                        }
                    }
                });

            } catch (err) {
                console.error('Failed to load symbol performance:', err);
            }
        }

        async function loadOverviewRecentPredictions() {
            const tbody = document.getElementById('overview-recent-tbody');
            if (!tbody) return;

            try {
                const res = await fetch(`${API_BASE}/forecast/latest-per-model`);
                const data = await res.json();

                const predictions = (data.forecasts || []).slice(0, 10);

                if (predictions.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: #666; padding: 1rem;">Keine Prognosen</td></tr>';
                    return;
                }

                tbody.innerHTML = predictions.map(p => {
                    const trendIcon = p.trend === 'up' ? '‚Üë' : p.trend === 'down' ? '‚Üì' : '‚Üí';
                    const trendColor = p.trend === 'up' ? '#4ade80' : p.trend === 'down' ? '#f87171' : '#888';
                    const time = p.timestamp ? new Date(p.timestamp).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : '-';

                    return `
                        <tr>
                            <td><strong>${p.symbol}</strong></td>
                            <td style="color: ${trendColor}; font-size: 1.1rem;">${trendIcon}</td>
                            <td>${p.horizon || '-'}</td>
                            <td style="font-size: 0.85rem; color: #888;">${time}</td>
                        </tr>
                    `;
                }).join('');

            } catch (err) {
                console.error('Failed to load recent predictions:', err);
                tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: #f87171;">Fehler</td></tr>';
            }
        }

        async function loadOverviewSystemStatus() {
            try {
                const [autoRes, forecastRes] = await Promise.all([
                    fetch(`${API_BASE}/forecast/auto-status`),
                    fetch(`${API_BASE}/forecast/auto/status`)
                ]);

                const autoData = await autoRes.json();
                const forecastData = await forecastRes.json();

                // Auto-Evaluation Status
                const evalStatus = autoData.auto_evaluation;
                document.getElementById('overview-auto-eval-status').innerHTML = evalStatus.enabled && evalStatus.running
                    ? '<span class="badge badge-success">Aktiv</span>'
                    : '<span class="badge badge-failed">Inaktiv</span>';

                // Auto-Retrain Status
                const retrainStatus = autoData.auto_retrain;
                document.getElementById('overview-auto-retrain-status').innerHTML = retrainStatus.enabled
                    ? (retrainStatus.in_progress ? '<span class="badge badge-warning">Training...</span>' : '<span class="badge badge-success">Aktiv</span>')
                    : '<span class="badge badge-failed">Inaktiv</span>';

                // Auto-Forecast Status
                const favoritesRunning = forecastData.favorites?.running || false;
                document.getElementById('overview-auto-forecast-status').innerHTML = favoritesRunning
                    ? '<span class="badge badge-success">Aktiv</span>'
                    : '<span class="badge badge-failed">Inaktiv</span>';

                // Cooldown
                document.getElementById('overview-cooldown').textContent = `${retrainStatus.cooldown_hours || 4}h`;

            } catch (err) {
                console.error('Failed to load system status:', err);
            }
        }

        // ==================== Header Status Functions ====================

        async function updateHeaderStatus() {
            try {
                // Fetch health info
                const healthResponse = await fetch(`${API_BASE.replace('/api/v1', '')}/health`);
                const healthData = await healthResponse.json();

                // Update status
                const statusEl = document.getElementById('headerStatus');
                const badgeEl = document.getElementById('service-status');
                if (healthData.status === 'healthy') {
                    statusEl.textContent = 'Online';
                    statusEl.style.color = '#4caf50';
                    badgeEl.textContent = 'Online';
                    badgeEl.classList.remove('offline');
                } else {
                    statusEl.textContent = 'Offline';
                    statusEl.style.color = '#f44336';
                    badgeEl.textContent = 'Offline';
                    badgeEl.classList.add('offline');
                }

                // Update version
                document.getElementById('headerVersion').textContent = healthData.version || '-';

                // Update device (GPU)
                const deviceEl = document.getElementById('headerDevice');
                if (healthData.gpu_enabled) {
                    deviceEl.textContent = 'cuda';
                    deviceEl.style.color = '#4caf50';
                } else {
                    deviceEl.textContent = 'cpu';
                    deviceEl.style.color = '#ff9800';
                }

                // Update training status
                const trainingEl = document.getElementById('headerTraining');
                if (healthData.training_in_progress) {
                    trainingEl.textContent = 'Aktiv';
                    trainingEl.style.color = '#ff9800';
                } else {
                    trainingEl.textContent = 'Idle';
                    trainingEl.style.color = '#4caf50';
                }

                // Fetch model count
                try {
                    const modelsResponse = await fetch(`${API_BASE}/forecast/models`);
                    const modelsData = await modelsResponse.json();
                    // API returns array directly, not {models: [...]}
                    const modelCount = Array.isArray(modelsData) ? modelsData.length : (modelsData.models?.length ?? 0);
                    document.getElementById('headerModels').textContent = modelCount;
                } catch (e) {
                    document.getElementById('headerModels').textContent = '-';
                }

                // Calculate uptime
                if (!serviceStartTime) {
                    serviceStartTime = Date.now();
                }
                updateUptime();

            } catch (error) {
                console.error('Error updating header status:', error);
                document.getElementById('headerStatus').textContent = 'Offline';
                document.getElementById('headerStatus').style.color = '#f44336';
                document.getElementById('service-status').textContent = 'Offline';
                document.getElementById('service-status').classList.add('offline');
            }
        }

        function updateUptime() {
            if (!serviceStartTime) return;
            const diff = Date.now() - serviceStartTime;
            const seconds = Math.floor(diff / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            let uptimeStr;
            if (days > 0) {
                uptimeStr = `${days}d ${hours % 24}h`;
            } else if (hours > 0) {
                uptimeStr = `${hours}h ${minutes % 60}m`;
            } else {
                uptimeStr = `${minutes}m ${seconds % 60}s`;
            }
            document.getElementById('headerUptime').textContent = uptimeStr;
        }

        // Update uptime every second
        setInterval(updateUptime, 1000);

        // Initial header status load
        updateHeaderStatus();

        // Tab switching
        function switchTab(tabName) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

            event.target.classList.add('active');
            document.getElementById(`tab-${tabName}`).classList.add('active');

            // Load data for the selected tab
            if (tabName === 'overview') loadOverviewData();
            if (tabName === 'models') loadModels();
            if (tabName === 'performance') {
                loadPerformance();
                loadAutoStatus();
            }
            if (tabName === 'forecast') loadForecastSymbols();
            if (tabName === 'selflearning') loadSelfLearningStatus();
            if (tabName === 'backup') loadBackupStatus();
        }

        // Show forecast details modal
        function showForecastModal(symbol, fullSymbol) {
            const forecast = latestForecasts[fullSymbol] || latestForecasts[symbol];
            if (!forecast) {
                showToast('Keine Prognose-Details verf√ºgbar');
                return;
            }

            const modal = document.getElementById('forecast-modal');
            const title = document.getElementById('forecast-modal-title');
            const body = document.getElementById('forecast-modal-body');

            // Format date (UTC -> local time)
            const dateStr = formatUTCTimestamp(forecast.timestamp);

            // Trend info
            const trendIcon = forecast.trend === 'up' ? '‚Üë' : (forecast.trend === 'down' ? '‚Üì' : '-');
            const trendText = forecast.trend === 'up' ? 'Steigend' : (forecast.trend === 'down' ? 'Fallend' : 'Neutral');
            const trendClass = forecast.trend === 'up' ? 'up' : (forecast.trend === 'down' ? 'down' : '');

            // Evaluation status
            let evalStatus = '<span class="modal-value pending">‚è≥ Ausstehend</span>';
            if (forecast.evaluated) {
                if (forecast.direction_correct) {
                    evalStatus = '<span class="modal-value up">‚úì Korrekt</span>';
                } else {
                    evalStatus = '<span class="modal-value down">‚úó Falsch</span>';
                }
            }

            // Price formatting
            const formatPrice = (price) => {
                if (!price) return '-';
                if (price < 1) return price.toFixed(5);
                if (price < 100) return price.toFixed(4);
                return price.toFixed(2);
            };

            // Calculate change
            let changeStr = '-';
            let changeClass = '';
            if (forecast.current_price && forecast.predicted_price) {
                const change = ((forecast.predicted_price - forecast.current_price) / forecast.current_price) * 100;
                changeStr = (change >= 0 ? '+' : '') + change.toFixed(3) + '%';
                changeClass = change >= 0 ? 'up' : 'down';
            }

            title.innerHTML = `<span style="color: ${trendClass === 'up' ? '#4ade80' : '#f87171'};">${trendIcon}</span> ${symbol}`;

            body.innerHTML = `
                <div class="modal-row">
                    <span class="modal-label">Zeitpunkt</span>
                    <span class="modal-value">${dateStr}</span>
                </div>
                <div class="modal-row">
                    <span class="modal-label">Horizont</span>
                    <span class="modal-value">${forecast.horizon || '-'}</span>
                </div>
                <div class="modal-row">
                    <span class="modal-label">Aktueller Preis</span>
                    <span class="modal-value">${formatPrice(forecast.current_price)}</span>
                </div>
                <div class="modal-row">
                    <span class="modal-label">Prognostizierter Preis</span>
                    <span class="modal-value ${trendClass}">${formatPrice(forecast.predicted_price)}</span>
                </div>
                <div class="modal-row">
                    <span class="modal-label">Erwartete √Ñnderung</span>
                    <span class="modal-value ${changeClass}">${changeStr}</span>
                </div>
                <div class="modal-row">
                    <span class="modal-label">Trend</span>
                    <span class="modal-value ${trendClass}">${trendIcon} ${trendText}</span>
                </div>
                <div class="modal-row">
                    <span class="modal-label">Evaluierung</span>
                    ${evalStatus}
                </div>
                ${forecast.evaluated && forecast.error_pct !== null ? `
                <div class="modal-row">
                    <span class="modal-label">Fehler</span>
                    <span class="modal-value ${Math.abs(forecast.error_pct) < 0.5 ? 'up' : 'down'}">${forecast.error_pct.toFixed(3)}%</span>
                </div>
                ` : ''}
            `;

            modal.classList.add('show');
        }

        // Close forecast modal
        function closeForecastModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('forecast-modal').classList.remove('show');
        }

        // Close modal on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeForecastModal();
            }
        });

        // Check service health
        async function checkHealth() {
            try {
                const res = await fetch(`${API_BASE.replace('/api/v1', '')}/health`);
                const data = await res.json();
                const badge = document.getElementById('service-status');
                if (data.status === 'healthy') {
                    badge.textContent = 'Online';
                    badge.classList.remove('offline');
                } else {
                    badge.textContent = 'Degraded';
                    badge.classList.add('offline');
                }
            } catch (err) {
                const badge = document.getElementById('service-status');
                badge.textContent = 'Offline';
                badge.classList.add('offline');
            }
        }

        // Training status
        async function updateTrainingStatus() {
            try {
                // Fetch both training progress and auto-status (for retrain info)
                const [progressRes, autoStatusRes] = await Promise.all([
                    fetch(`${API_BASE}/forecast/training/progress`),
                    fetch(`${API_BASE}/forecast/auto-status`)
                ]);
                const data = await progressRes.json();
                const autoStatus = await autoStatusRes.json();

                const msgEl = document.getElementById('training-message');
                const progressEl = document.getElementById('training-progress');
                const timingEl = document.getElementById('training-timing');
                const btnCancel = document.getElementById('btn-cancel');
                const trainButtons = [
                    'btn-train-all', 'btn-train-m5', 'btn-train-m15', 'btn-train-h1',
                    'btn-train-h4', 'btn-train-d1', 'btn-train-w1', 'btn-force-train', 'btn-retrain-failed'
                ];

                // Check if retrain is in progress (from auto-status)
                const retrainInProgress = autoStatus?.auto_retrain?.in_progress || false;
                const retrainSymbols = autoStatus?.auto_retrain?.last_symbols || [];

                if (data.training_in_progress) {
                    msgEl.textContent = `Training: ${data.current_symbol || '-'} (${data.completed_symbols}/${data.total_symbols})`;
                    msgEl.classList.add('training-active');
                    progressEl.style.width = `${Math.max(data.progress_percent, 5)}%`;
                    progressEl.classList.add('active');
                    btnCancel.disabled = false;
                    trainButtons.forEach(id => document.getElementById(id).disabled = true);

                    document.getElementById('stat-completed').textContent = data.completed_symbols || 0;
                    document.getElementById('stat-successful').textContent = data.results?.successful || 0;
                    document.getElementById('stat-skipped').textContent = data.results?.skipped || 0;
                    document.getElementById('stat-failed').textContent = data.results?.failed || 0;

                    if (data.timing) {
                        timingEl.style.display = 'grid';
                        document.getElementById('stat-elapsed').textContent = data.timing.elapsed_formatted || '-';
                        document.getElementById('stat-eta').textContent = data.timing.eta_formatted || '-';
                    }

                    // Start polling if not already
                    if (!trainingInterval) {
                        trainingInterval = setInterval(updateTrainingStatus, 2000);
                    }
                } else if (retrainInProgress) {
                    // Show retrain status when no batch training but retrain is active
                    const symbolCount = retrainSymbols.length;
                    msgEl.innerHTML = `<span style="color: #fbbf24;">üîÑ Auto-Retrain l√§uft</span> <span style="opacity: 0.7;">(${symbolCount} Modelle)</span>`;
                    msgEl.classList.add('training-active');
                    progressEl.style.width = '50%'; // Indeterminate progress
                    progressEl.classList.add('active');
                    btnCancel.disabled = true; // Can't cancel retrain from here
                    trainButtons.forEach(id => document.getElementById(id).disabled = true);
                    timingEl.style.display = 'none';

                    // Start polling if not already
                    if (!trainingInterval) {
                        trainingInterval = setInterval(updateTrainingStatus, 3000);
                    }
                } else {
                    msgEl.textContent = data.message || 'Kein Training aktiv';
                    msgEl.classList.remove('training-active');
                    progressEl.style.width = '0%';
                    progressEl.classList.remove('active');
                    btnCancel.disabled = true;
                    trainButtons.forEach(id => document.getElementById(id).disabled = false);
                    timingEl.style.display = 'none';

                    // Stop polling
                    if (trainingInterval) {
                        clearInterval(trainingInterval);
                        trainingInterval = null;
                    }
                }

                // Load failed trainings
                await loadFailedTrainings();

            } catch (err) {
                console.error('Training status error:', err);
            }
        }

        // Load model counts by timeframe
        async function loadModelCounts() {
            try {
                const res = await fetch(`${API_BASE}/forecast/models/by-timeframe`);
                const data = await res.json();

                document.getElementById('stat-tf-m5').textContent = data.by_timeframe?.M5?.count || 0;
                document.getElementById('stat-tf-m15').textContent = data.by_timeframe?.M15?.count || 0;
                document.getElementById('stat-tf-h1').textContent = data.by_timeframe?.H1?.count || 0;
                document.getElementById('stat-tf-h4').textContent = data.by_timeframe?.H4?.count || 0;
                document.getElementById('stat-tf-d1').textContent = data.by_timeframe?.D1?.count || 0;
                document.getElementById('stat-tf-w1').textContent = data.by_timeframe?.W1?.count || 0;
            } catch (err) {
                console.error('Failed to load model counts:', err);
            }
        }

        // Load failed trainings
        async function loadFailedTrainings() {
            try {
                const res = await fetch(`${API_BASE}/forecast/training/failed`);
                const data = await res.json();

                const failedCard = document.getElementById('failed-card');
                const failedList = document.getElementById('failed-list');
                const failedCount = document.getElementById('failed-count');

                if (data.count > 0) {
                    failedCard.style.display = 'block';
                    failedCount.textContent = data.count;

                    // Sort by timestamp descending (newest first)
                    const sortedEntries = Object.entries(data.models).sort((a, b) => {
                        const timeA = a[1].timestamp ? new Date(a[1].timestamp).getTime() : 0;
                        const timeB = b[1].timestamp ? new Date(b[1].timestamp).getTime() : 0;
                        return timeB - timeA;
                    });

                    let html = '';
                    for (const [key, info] of sortedEntries) {
                        // Format timestamp for display (timestamps from server are UTC)
                        let timeStr = '';
                        if (info.timestamp) {
                            // Append 'Z' if timestamp doesn't have timezone info (treat as UTC)
                            let ts = info.timestamp;
                            if (!ts.endsWith('Z') && !ts.includes('+') && !ts.includes('-', 10)) {
                                ts += 'Z';
                            }
                            const date = new Date(ts);
                            timeStr = date.toLocaleString('de-CH', {
                                day: '2-digit',
                                month: '2-digit',
                                year: 'numeric',
                                hour: '2-digit',
                                minute: '2-digit'
                            });
                        }
                        html += `
                            <div class="failed-item">
                                <div class="symbol">${info.symbol} (${info.timeframe})${timeStr ? ` <span style="color: #888; font-size: 0.85em; margin-left: 0.5rem;">${timeStr}</span>` : ''}</div>
                                <div class="error">${info.error}</div>
                            </div>
                        `;
                    }
                    failedList.innerHTML = html;
                } else {
                    failedCard.style.display = 'none';
                }
            } catch (err) {
                console.error('Failed to load failed trainings:', err);
            }
        }

        // Start training
        async function startTraining(timeframes, force = false) {
            try {
                let url = `${API_BASE}/forecast/train-all?force=${force}&background=true`;
                timeframes.forEach(tf => url += `&timeframes=${tf}`);

                const modeText = force ? 'Force-Training' : 'Training';
                showToast(`${modeText} wird gestartet (${timeframes.join(', ')})...`);
                const res = await fetch(url, { method: 'POST' });
                const data = await res.json();

                showToast(data.message || `${modeText} gestartet`);
                setTimeout(updateTrainingStatus, 1000);
            } catch (err) {
                showToast('Fehler beim Starten des Trainings');
            }
        }

        // Cancel training
        async function cancelTraining() {
            try {
                const res = await fetch(`${API_BASE}/forecast/training/cancel`, { method: 'POST' });
                const data = await res.json();
                showToast(data.message || 'Training wird abgebrochen...');
                setTimeout(updateTrainingStatus, 1000);
            } catch (err) {
                showToast('Fehler beim Abbrechen');
            }
        }

        // Retrain failed
        async function retrainFailed() {
            try {
                const res = await fetch(`${API_BASE}/forecast/retrain-poor-performers`, { method: 'POST' });
                const data = await res.json();
                showToast(data.message || 'Retraining gestartet');
                setTimeout(updateTrainingStatus, 1000);
            } catch (err) {
                showToast('Fehler beim Starten des Retrainings');
            }
        }

        // Load models with full details
        async function loadModels() {
            try {
                // Fetch models and latest forecasts in parallel
                const [modelsRes, forecastsRes] = await Promise.all([
                    fetch(`${API_BASE}/forecast/models`),
                    fetch(`${API_BASE}/forecast/latest-per-model`)
                ]);

                const data = await modelsRes.json();
                const forecastsData = await forecastsRes.json();

                // Store forecasts in cache
                latestForecasts = forecastsData.forecasts || {};

                // Count favorites
                const favoriteCount = data.filter(m => m.is_favorite && m.model_exists).length;
                document.getElementById('models-total').textContent = `${data.length} Modelle (${favoriteCount} Favoriten)`;

                allModels = [];
                for (const model of data) {
                    if (!model.model_exists) continue;

                    // Parse timeframe from symbol (e.g., BTCUSD_H1 -> H1, BTCUSD -> default)
                    let baseSymbol = model.symbol;
                    let timeframeKey = 'default';
                    let timeframeLabel = 'H1 (Std)';

                    // Extract timeframe suffix from symbol
                    const tfSuffixes = {
                        '_M5': 'M5', '_M15': 'M15', '_M30': 'M30',
                        '_H1': 'H1', '_H4': 'H4',
                        '_D1': 'D1', '_W1': 'W1', '_MN': 'MN'
                    };
                    for (const [suffix, tf] of Object.entries(tfSuffixes)) {
                        if (model.symbol.endsWith(suffix)) {
                            baseSymbol = model.symbol.slice(0, -suffix.length);
                            timeframeKey = tf;
                            timeframeLabel = tf;
                            break;
                        }
                    }

                    allModels.push({
                        symbol: baseSymbol,
                        fullSymbol: model.symbol,
                        timeframe: timeframeLabel,
                        timeframeKey: timeframeKey,
                        lastTrained: model.last_trained,
                        samples: model.training_samples,
                        loss: model.metrics?.final_loss,
                        isFavorite: model.is_favorite || false,
                        category: model.category || ''
                    });
                }

                filterModels();
            } catch (err) {
                console.error('Failed to load models:', err);
            }
        }

        // Load latest forecasts (separate function to refresh after single forecast)
        async function loadLatestForecasts() {
            try {
                const res = await fetch(`${API_BASE}/forecast/latest-per-model`);
                const data = await res.json();
                latestForecasts = data.forecasts || {};
            } catch (err) {
                console.error('Failed to load latest forecasts:', err);
            }
        }

        // Filter models
        function filterModels() {
            const search = document.getElementById('model-search').value.toLowerCase();
            const tfFilter = document.getElementById('timeframe-filter').value;
            const favFilter = document.getElementById('favorite-filter')?.value || '';

            const filtered = allModels.filter(m => {
                const matchSearch = m.symbol.toLowerCase().includes(search);
                const matchTf = !tfFilter || m.timeframeKey === tfFilter;
                const matchFav = !favFilter || (favFilter === 'favorites' && m.isFavorite) || (favFilter === 'non-favorites' && !m.isFavorite);
                return matchSearch && matchTf && matchFav;
            });

            // Sort by 1. Favorites first, 2. Symbol, 3. Timeframe (M5, M15, H1, H4, D1, W1)
            const timeframeOrder = { 'M5': 1, 'M15': 2, 'H1': 3, 'H4': 4, 'D1': 5, 'W1': 6, 'default': 3 };
            filtered.sort((a, b) => {
                // Favorites first
                if (a.isFavorite !== b.isFavorite) return b.isFavorite - a.isFavorite;
                // Then sort by symbol alphabetically
                const symbolCompare = a.symbol.localeCompare(b.symbol);
                if (symbolCompare !== 0) return symbolCompare;
                // Then sort by timeframe order
                return (timeframeOrder[a.timeframeKey] || 99) - (timeframeOrder[b.timeframeKey] || 99);
            });

            const tbody = document.getElementById('models-tbody');
            if (filtered.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; opacity: 0.5;">Keine Modelle gefunden</td></tr>';
                return;
            }

            let html = '';
            for (const model of filtered) {
                const tfClass = model.timeframeKey === 'M15' ? 'badge-m15' :
                               model.timeframeKey === 'D1' ? 'badge-d1' : 'badge-h1';

                // Format trained date (UTC -> local time)
                let trainedDate = model.lastTrained ? formatUTCTimestamp(model.lastTrained) : '-';

                // Get latest forecast for this model
                // Try full symbol first (e.g., "BTCUSD_H1"), then base symbol (e.g., "BTCUSD")
                let forecastInfo = '-';
                let forecastClickable = false;
                let forecast = latestForecasts[model.fullSymbol] || latestForecasts[model.symbol];
                if (forecast) {
                    forecastClickable = true;
                    const dateStr = formatUTCTimestamp(forecast.timestamp);
                    const trendIcon = forecast.trend === 'up' ? '‚Üë' : (forecast.trend === 'down' ? '‚Üì' : '-');
                    const trendColor = forecast.trend === 'up' ? '#4ade80' : (forecast.trend === 'down' ? '#f87171' : 'inherit');
                    const evalIcon = forecast.evaluated ? (forecast.direction_correct ? '‚úì' : '‚úó') : '‚è≥';
                    const evalColor = forecast.evaluated ? (forecast.direction_correct ? '#4ade80' : '#f87171') : '#fbbf24';
                    forecastInfo = `<span style="color: ${trendColor}; font-weight: 600;">${trendIcon}</span> ${dateStr} <span style="color: ${evalColor}; font-size: 0.85em;" title="${forecast.evaluated ? (forecast.direction_correct ? 'Korrekt' : 'Falsch') : 'Ausstehend'}">${evalIcon}</span>`;
                }

                // Format loss
                const lossStr = model.loss ? model.loss.toFixed(4) : '-';

                // Favorite indicator
                const favIcon = model.isFavorite ? '<span title="Favorit" style="color: #fbbf24;">&#9733;</span>' : '<span style="opacity: 0.3;">&#9734;</span>';
                const rowStyle = model.isFavorite ? 'background: rgba(251, 191, 36, 0.05);' : '';

                // Make forecast cell clickable if there's a forecast
                const forecastCell = forecastClickable
                    ? `<td class="forecast-cell" onclick="showForecastModal('${model.symbol}', '${model.fullSymbol}')" title="Klicken f√ºr Details">${forecastInfo}</td>`
                    : `<td>${forecastInfo}</td>`;

                html += `
                    <tr style="${rowStyle}">
                        <td>${favIcon}</td>
                        <td><strong>${model.symbol}</strong></td>
                        <td><span class="badge ${tfClass}">${model.timeframe}</span></td>
                        ${forecastCell}
                        <td>${trainedDate}</td>
                        <td>${model.samples || '-'}</td>
                        <td>${lossStr}</td>
                        <td style="white-space: nowrap;">
                            <button class="btn btn-sm btn-success" onclick="runSingleForecast('${model.symbol}', '${model.timeframeKey}')" title="Prognose erstellen">üìä</button>
                            <button class="btn btn-sm btn-primary" onclick="trainSingle('${model.symbol}', '${model.timeframeKey}')" title="Modell trainieren">üîß</button>
                        </td>
                    </tr>
                `;
            }
            tbody.innerHTML = html;
        }

        // Run single forecast for a model
        async function runSingleForecast(symbol, timeframe) {
            const tf = timeframe === 'default' ? 'H1' : timeframe;
            showToast(`Prognose f√ºr ${symbol}/${tf} wird erstellt...`);

            try {
                const res = await fetch(`${API_BASE}/forecast/${symbol}?timeframe=${tf}`);
                const data = await res.json();

                if (res.ok && data.predicted_prices && data.predicted_prices.length > 0) {
                    const currentPrice = data.predicted_prices[0];
                    const targetPrice = data.predicted_prices[data.predicted_prices.length - 1];
                    const trend = targetPrice > currentPrice ? 'up' : 'down';

                    // Build forecast object for modal display
                    const fullSymbol = `${symbol}_${tf}`;
                    const forecastData = {
                        symbol: symbol,
                        timeframe: tf,
                        timestamp: data.timestamp || new Date().toISOString(),
                        horizon: data.horizons ? data.horizons[data.horizons.length - 1] : '24h',
                        current_price: currentPrice,
                        predicted_price: targetPrice,
                        trend: trend,
                        evaluated: false,
                        direction_correct: null,
                        error_pct: null,
                        predicted_prices: data.predicted_prices,
                        horizons: data.horizons || ['1h', '4h', '24h']
                    };

                    // Store in cache for modal display
                    latestForecasts[fullSymbol] = forecastData;

                    // Refresh latest forecasts from server
                    await loadLatestForecasts();
                    // Refresh models table to show new forecast
                    filterModels();

                    // Show modal with forecast details
                    showForecastModal(symbol, fullSymbol);
                } else {
                    showToast(`‚úó Prognose fehlgeschlagen: ${data.detail || 'Unbekannter Fehler'}`, 'error');
                }
            } catch (err) {
                showToast(`Fehler: ${err.message}`, 'error');
            }
        }

        // Train single model
        async function trainSingle(symbol, timeframe) {
            try {
                const tf = timeframe === 'default' ? 'H1' : timeframe;
                showToast(`Training ${symbol}/${tf} gestartet... (kann bis zu 60s dauern)`, 60000);

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 120000); // 2 min timeout

                const res = await fetch(`${API_BASE}/forecast/${symbol}/train?timeframe=${tf}&force=true`, {
                    method: 'POST',
                    signal: controller.signal
                });
                clearTimeout(timeoutId);

                const data = await res.json();

                if (data.success) {
                    const duration = data.training_duration_seconds ? ` (${Math.round(data.training_duration_seconds)}s)` : '';
                    showToast(`‚úì ${symbol}/${tf} erfolgreich trainiert${duration}`);
                    loadModels(); // Refresh models list
                } else {
                    showToast(`‚úó Fehler: ${data.error_message || 'Unbekannt'}`);
                }
            } catch (err) {
                if (err.name === 'AbortError') {
                    showToast('Training Timeout - bitte Status pr√ºfen');
                } else {
                    showToast(`Fehler beim Training: ${err.message}`);
                }
            }
        }

        // Load performance
        async function loadPerformance() {
            try {
                // Fetch both performance summary and evaluated predictions
                const [perfRes, evalRes] = await Promise.all([
                    fetch(`${API_BASE}/forecast/performance`),
                    fetch(`${API_BASE}/forecast/evaluated`)
                ]);
                const perfData = await perfRes.json();
                const evalData = await evalRes.json();

                const tbody = document.getElementById('performance-tbody');

                // Check if there are any evaluated predictions
                if ((!evalData.predictions || evalData.predictions.length === 0) &&
                    Object.keys(perfData.by_symbol || {}).length === 0) {
                    tbody.innerHTML = `
                        <tr><td colspan="6" style="text-align: center; padding: 2rem;">
                            <div style="opacity: 0.7; margin-bottom: 1rem;">Keine Evaluierungen vorhanden</div>
                            <div style="font-size: 0.85rem; opacity: 0.5;">
                                Performance-Daten werden automatisch gesammelt, wenn Prognosen erstellt<br>
                                und sp√§ter mit den tats√§chlichen Preisen verglichen werden.
                            </div>
                        </td></tr>
                    `;
                    return;
                }

                let html = '';

                // Show symbol-level performance summary
                for (const [symbol, metrics] of Object.entries(perfData.by_symbol || {})) {
                    const avgError = metrics.avg_error_pct || 0;
                    const dirAccuracy = (metrics.direction_accuracy || 0) * 100;
                    const statusClass = avgError < 0.5 && dirAccuracy > 50 ? 'badge-success' : 'badge-failed';
                    const statusText = metrics.needs_retraining ? 'Retraining n√∂tig' : 'OK';

                    // Format evaluated date from most recent prediction (UTC -> local time)
                    let evaluatedAt = '-';
                    const symbolPreds = (evalData.predictions || []).filter(p => p.symbol === symbol);
                    if (symbolPreds.length > 0 && symbolPreds[0].evaluated_at) {
                        evaluatedAt = formatUTCTimestamp(symbolPreds[0].evaluated_at);
                    }

                    html += `
                        <tr>
                            <td><strong>${symbol}</strong></td>
                            <td>${metrics.evaluated}/${metrics.total}</td>
                            <td>${avgError.toFixed(4)}%</td>
                            <td>${dirAccuracy.toFixed(1)}%</td>
                            <td>${evaluatedAt}</td>
                            <td><span class="badge ${statusClass}">${statusText}</span></td>
                        </tr>
                    `;
                }

                // If no symbol metrics but have individual predictions, show those
                if (html === '' && evalData.predictions && evalData.predictions.length > 0) {
                    for (const pred of evalData.predictions.slice(0, 50)) {
                        const errorPct = pred.prediction_error_pct || 0;
                        const statusClass = pred.direction_correct ? 'badge-success' : 'badge-failed';
                        const statusText = pred.direction_correct ? 'Richtig' : 'Falsch';

                        let evaluatedAt = pred.evaluated_at ? formatUTCTimestamp(pred.evaluated_at) : '-';

                        html += `
                            <tr>
                                <td><strong>${pred.symbol}</strong></td>
                                <td>${pred.horizon || 'H1'}</td>
                                <td>${errorPct.toFixed(4)}%</td>
                                <td>${pred.direction_correct ? '‚úì' : '‚úó'}</td>
                                <td>${evaluatedAt}</td>
                                <td><span class="badge ${statusClass}">${statusText}</span></td>
                            </tr>
                        `;
                    }
                }

                tbody.innerHTML = html || '<tr><td colspan="6" style="text-align: center; opacity: 0.5;">Keine Daten</td></tr>';
            } catch (err) {
                console.error('Failed to load performance:', err);
                document.getElementById('performance-tbody').innerHTML =
                    '<tr><td colspan="6" style="text-align: center; opacity: 0.5;">Fehler beim Laden</td></tr>';
            }
        }

        // ========== AUTO-EVALUATION FUNCTIONS ==========

        let autoEvalEnabled = true;
        let autoRetrainEnabled = true;

        // Load auto-evaluation status
        async function loadAutoStatus() {
            try {
                const res = await fetch(`${API_BASE}/forecast/auto-status`);
                const data = await res.json();

                // Update auto-eval status
                const autoEvalDiv = document.getElementById('auto-eval-status');
                const evalStatus = data.auto_evaluation;
                autoEvalEnabled = evalStatus.enabled;

                const evalStatusBadge = evalStatus.running && evalStatus.enabled ?
                    '<span class="badge badge-success">Aktiv</span>' :
                    '<span class="badge badge-failed">Inaktiv</span>';

                let lastRunText = 'Noch nie';
                if (evalStatus.last_run) {
                    lastRunText = formatUTCTimestamp(evalStatus.last_run);
                }

                autoEvalDiv.innerHTML = `
                    <div style="margin-bottom: 0.5rem;">
                        ${evalStatusBadge}
                    </div>
                    <div style="font-size: 0.85rem; opacity: 0.8;">
                        <div>Intervall: ${evalStatus.interval_seconds}s</div>
                        <div>Letzte Ausf√ºhrung: ${lastRunText}</div>
                        <div>Gesamt evaluiert: ${evalStatus.total_evaluations}</div>
                    </div>
                `;

                // Update toggle button
                const toggleEvalBtn = document.getElementById('btn-toggle-auto-eval');
                if (autoEvalEnabled) {
                    toggleEvalBtn.innerHTML = '‚è∏Ô∏è Auto-Eval pausieren';
                    toggleEvalBtn.classList.remove('btn-success');
                } else {
                    toggleEvalBtn.innerHTML = '‚ñ∂Ô∏è Auto-Eval starten';
                    toggleEvalBtn.classList.add('btn-success');
                }

                // Update auto-retrain status
                const autoRetrainDiv = document.getElementById('auto-retrain-status');
                const retrainStatus = data.auto_retrain;
                autoRetrainEnabled = retrainStatus.enabled;

                let retrainStatusBadge;
                if (retrainStatus.in_progress) {
                    retrainStatusBadge = '<span class="badge badge-warning">Training l√§uft...</span>';
                } else if (retrainStatus.enabled) {
                    retrainStatusBadge = '<span class="badge badge-success">Aktiv</span>';
                } else {
                    retrainStatusBadge = '<span class="badge badge-failed">Inaktiv</span>';
                }

                let lastRetrainText = 'Noch nie';
                if (retrainStatus.last_run) {
                    lastRetrainText = formatUTCTimestamp(retrainStatus.last_run);
                }

                autoRetrainDiv.innerHTML = `
                    <div style="margin-bottom: 0.5rem;">
                        ${retrainStatusBadge}
                    </div>
                    <div style="font-size: 0.85rem; opacity: 0.8;">
                        <div>Cooldown: ${retrainStatus.cooldown_hours}h</div>
                        <div>Letztes Retrain: ${lastRetrainText}</div>
                        <div>Gesamt retrained: ${retrainStatus.total_retrains}</div>
                    </div>
                `;

                // Show symbols needing retrain
                if (data.symbols_needing_retrain && data.symbols_needing_retrain.length > 0) {
                    autoRetrainDiv.innerHTML += `
                        <div style="margin-top: 0.5rem; padding: 0.5rem; background: rgba(255,193,7,0.1); border-radius: 4px; font-size: 0.8rem;">
                            <strong>Retrain ben√∂tigt:</strong> ${data.symbols_needing_retrain.join(', ')}
                        </div>
                    `;
                }

                // Update toggle button
                const toggleRetrainBtn = document.getElementById('btn-toggle-auto-retrain');
                if (autoRetrainEnabled) {
                    toggleRetrainBtn.innerHTML = '‚è∏Ô∏è Auto-Retrain pausieren';
                    toggleRetrainBtn.classList.remove('btn-success');
                } else {
                    toggleRetrainBtn.innerHTML = '‚ñ∂Ô∏è Auto-Retrain starten';
                    toggleRetrainBtn.classList.add('btn-success');
                }

                // Update manual retrain button based on in_progress status
                const manualRetrainBtn = document.getElementById('btn-manual-retrain');
                if (retrainStatus.in_progress) {
                    manualRetrainBtn.disabled = true;
                    manualRetrainBtn.innerHTML = '‚è≥ Retrain l√§uft...';
                    manualRetrainBtn.classList.add('btn-loading');
                } else {
                    manualRetrainBtn.disabled = false;
                    manualRetrainBtn.innerHTML = 'üîÑ Schlechte Modelle retrainieren';
                    manualRetrainBtn.classList.remove('btn-loading');
                }

                // Update prediction stats
                const predictions = data.predictions;
                document.getElementById('stat-pending').textContent = predictions.pending_count;
                document.getElementById('stat-ready').textContent = predictions.ready_for_evaluation;
                document.getElementById('stat-waiting').textContent = predictions.waiting_for_horizon;
                document.getElementById('stat-evaluated').textContent = predictions.evaluated_count;

            } catch (err) {
                console.error('Failed to load auto status:', err);
                document.getElementById('auto-eval-status').innerHTML = '<div style="color: #f87171;">Fehler beim Laden</div>';
                document.getElementById('auto-retrain-status').innerHTML = '<div style="color: #f87171;">Fehler beim Laden</div>';
            }
        }

        // Toggle auto-evaluation
        async function toggleAutoEvaluation() {
            const newState = !autoEvalEnabled;
            try {
                const res = await fetch(`${API_BASE}/forecast/auto-evaluation/toggle?enabled=${newState}`, {
                    method: 'POST'
                });
                const data = await res.json();
                if (data.success) {
                    showToast(data.message);
                    await loadAutoStatus();
                }
            } catch (err) {
                console.error('Failed to toggle auto-evaluation:', err);
                showToast('Fehler: ' + err.message);
            }
        }

        // Toggle auto-retrain
        async function toggleAutoRetrain() {
            const newState = !autoRetrainEnabled;
            try {
                const res = await fetch(`${API_BASE}/forecast/auto-retrain/toggle?enabled=${newState}`, {
                    method: 'POST'
                });
                const data = await res.json();
                if (data.success) {
                    showToast(data.message);
                    await loadAutoStatus();
                }
            } catch (err) {
                console.error('Failed to toggle auto-retrain:', err);
                showToast('Fehler: ' + err.message);
            }
        }

        // Manual retrain for poor performers
        async function runManualRetrain() {
            const btn = document.getElementById('btn-manual-retrain');
            btn.disabled = true;
            btn.innerHTML = '‚è≥ Retrain l√§uft...';
            btn.classList.add('btn-loading');

            try {
                const res = await fetch(`${API_BASE}/forecast/retrain-poor-performers`, {
                    method: 'POST'
                });
                const data = await res.json();

                if (data.success) {
                    if (data.symbols && data.symbols.length > 0) {
                        showToast(`Retrain gestartet f√ºr: ${data.symbols.join(', ')}`);
                        // Start polling for status updates while training runs
                        startRetrainPolling();
                    } else {
                        showToast(data.message || 'Keine Modelle ben√∂tigen Retraining');
                        // No training started, reset button immediately
                        btn.disabled = false;
                        btn.innerHTML = 'üîÑ Schlechte Modelle retrainieren';
                        btn.classList.remove('btn-loading');
                    }
                } else {
                    showToast('Fehler: ' + (data.detail || 'Unbekannter Fehler'));
                    btn.disabled = false;
                    btn.innerHTML = 'üîÑ Schlechte Modelle retrainieren';
                    btn.classList.remove('btn-loading');
                }
            } catch (err) {
                console.error('Manual retrain failed:', err);
                showToast('Fehler: ' + err.message);
                btn.disabled = false;
                btn.innerHTML = 'üîÑ Schlechte Modelle retrainieren';
                btn.classList.remove('btn-loading');
            }
            // Note: Button state is now managed by loadAutoStatus() based on in_progress flag
        }

        // Poll for retrain status updates
        let retrainPollingInterval = null;
        function startRetrainPolling() {
            if (retrainPollingInterval) return; // Already polling

            retrainPollingInterval = setInterval(async () => {
                await loadAutoStatus();

                // Check if training is still in progress
                const btn = document.getElementById('btn-manual-retrain');
                if (!btn.classList.contains('btn-loading')) {
                    // Training finished, stop polling
                    clearInterval(retrainPollingInterval);
                    retrainPollingInterval = null;
                    showToast('Retrain abgeschlossen');
                }
            }, 3000); // Poll every 3 seconds
        }

        // Manual evaluation (updated)
        async function runManualEvaluation() {
            const btn = document.getElementById('btn-manual-eval');
            const statusDiv = document.getElementById('evaluation-status');
            const statusMsg = document.getElementById('evaluation-message');
            const progressContainer = document.getElementById('evaluation-progress-container');
            const progressBar = document.getElementById('evaluation-progress-bar');
            const progressText = document.getElementById('evaluation-progress-text');
            const progressCount = document.getElementById('evaluation-progress-count');

            // Disable button and show loading state
            btn.disabled = true;
            btn.textContent = '‚è≥ Evaluierung...';
            statusDiv.style.display = 'block';
            statusMsg.textContent = 'Evaluierung l√§uft... Prognosen werden mit tats√§chlichen Preisen verglichen.';
            statusDiv.style.background = 'rgba(100, 200, 255, 0.1)';
            statusDiv.style.borderColor = 'rgba(100, 200, 255, 0.2)';

            // Show progress bar
            progressContainer.style.display = 'block';
            progressBar.style.width = '0%';
            progressBar.style.background = 'linear-gradient(90deg, #64b5f6, #42a5f5)';
            progressText.textContent = '0%';
            progressCount.textContent = 'Initialisiere...';

            // Animated progress simulation
            let progress = 0;
            let progressInterval = null;

            // Start progress animation (simulate progress while waiting for API)
            const startProgress = (totalItems) => {
                const estimatedTimeMs = Math.max(2000, totalItems * 50); // ~50ms per item, min 2s
                const updateInterval = 100;
                const progressStep = (95 / (estimatedTimeMs / updateInterval)); // Go up to 95%

                progressCount.textContent = `${totalItems} Prognosen`;

                progressInterval = setInterval(() => {
                    if (progress < 95) {
                        progress += progressStep;
                        progress = Math.min(progress, 95);
                        progressBar.style.width = `${progress}%`;
                        progressText.textContent = `${Math.round(progress)}%`;
                    }
                }, updateInterval);
            };

            // Complete progress animation
            const completeProgress = (success) => {
                if (progressInterval) {
                    clearInterval(progressInterval);
                    progressInterval = null;
                }
                progress = 100;
                progressBar.style.width = '100%';
                progressText.textContent = '100%';
                if (success) {
                    progressBar.style.background = 'linear-gradient(90deg, #4caf50, #66bb6a)';
                } else {
                    progressBar.style.background = 'linear-gradient(90deg, #f44336, #e57373)';
                }
            };

            try {
                // First, get pending count to estimate progress
                let pendingCount = 100; // Default estimate
                try {
                    const statusRes = await fetch(`${API_BASE}/forecast/auto-status`);
                    if (statusRes.ok) {
                        const statusData = await statusRes.json();
                        pendingCount = statusData.pending_total || statusData.ready_for_eval || 100;
                    }
                } catch (e) {
                    console.warn('Could not get pending count:', e);
                }

                // Start progress animation
                startProgress(pendingCount);

                const res = await fetch(`${API_BASE}/forecast/evaluate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                const data = await res.json();

                if (res.ok && data.success) {
                    // Success
                    completeProgress(true);
                    btn.textContent = '‚úì Fertig';
                    statusDiv.style.background = 'rgba(76, 175, 80, 0.1)';
                    statusDiv.style.borderColor = 'rgba(76, 175, 80, 0.2)';

                    if (data.evaluated_count > 0) {
                        statusMsg.innerHTML = `<strong>${data.evaluated_count} Prognosen evaluiert!</strong><br>
                            <span style="font-size: 0.85rem; opacity: 0.8;">
                                Ausstehend vorher: ${data.pending_before} ‚Üí nachher: ${data.pending_after}
                            </span>`;
                        progressCount.textContent = `${data.evaluated_count} evaluiert`;

                        // Show per-symbol breakdown if available
                        if (data.by_symbol && Object.keys(data.by_symbol).length > 0) {
                            const symbolList = Object.entries(data.by_symbol)
                                .map(([sym, count]) => `${sym}: ${count}`)
                                .join(', ');
                            statusMsg.innerHTML += `<br><span style="font-size: 0.8rem; opacity: 0.7;">${symbolList}</span>`;
                        }
                    } else {
                        statusMsg.innerHTML = `<strong>Keine Prognosen bereit zur Evaluierung.</strong><br>
                            <span style="font-size: 0.85rem; opacity: 0.8;">
                                ${data.pending_before} Prognosen warten noch auf Ablauf ihres Zeithorizonts.
                            </span>`;
                        progressCount.textContent = 'Keine bereit';
                    }

                    // Reload performance data and auto status
                    await loadPerformance();
                    await loadAutoStatus();
                    showToast(data.message);
                } else {
                    // Error response
                    completeProgress(false);
                    btn.textContent = '‚úó Fehler';
                    statusDiv.style.background = 'rgba(244, 67, 54, 0.1)';
                    statusDiv.style.borderColor = 'rgba(244, 67, 54, 0.2)';
                    statusMsg.textContent = `Fehler: ${data.detail || 'Unbekannter Fehler'}`;
                    progressCount.textContent = 'Fehler';
                }
            } catch (err) {
                console.error('Evaluation failed:', err);
                completeProgress(false);
                btn.textContent = '‚úó Fehler';
                statusDiv.style.background = 'rgba(244, 67, 54, 0.1)';
                statusDiv.style.borderColor = 'rgba(244, 67, 54, 0.2)';
                statusMsg.textContent = `Fehler: ${err.message}`;
                progressCount.textContent = 'Fehler';
            } finally {
                // Re-enable button after short delay
                setTimeout(() => {
                    btn.disabled = false;
                    btn.textContent = 'üìä Jetzt evaluieren';
                }, 2000);

                // Hide status after 10 seconds
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                    progressContainer.style.display = 'none';
                }, 10000);
            }
        }

        // Refresh all status
        async function refreshStatus() {
            await Promise.all([
                checkHealth(),
                updateTrainingStatus(),
                loadModelCounts()
            ]);
        }

        // Toast notification
        let toastTimeout = null;
        function showToast(message, duration = 3000) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            if (toastTimeout) clearTimeout(toastTimeout);
            toastTimeout = setTimeout(() => toast.classList.remove('show'), duration);
        }

        // Initial load
        refreshStatus();

        // Auto-refresh every 10 seconds
        setInterval(refreshStatus, 10000);

        // ========== FORECAST TAB ==========
        let forecastChart = null;

        // Load available symbols for forecast
        async function loadForecastSymbols() {
            try {
                const res = await fetch(`${API_BASE}/forecast/models`);
                const data = await res.json();

                const select = document.getElementById('forecast-symbol');
                const symbols = new Set();

                // Extract unique base symbols
                const timeframeSuffixes = ['_M5', '_M15', '_M30', '_H1', '_H4', '_D1', '_W1', '_MN'];
                for (const model of data) {
                    if (!model.model_exists) continue;
                    let baseSymbol = model.symbol;
                    for (const suffix of timeframeSuffixes) {
                        if (baseSymbol.endsWith(suffix)) {
                            baseSymbol = baseSymbol.slice(0, -suffix.length);
                            break;
                        }
                    }
                    symbols.add(baseSymbol);
                }

                // Sort and populate dropdown
                const sortedSymbols = Array.from(symbols).sort();
                select.innerHTML = '<option value="">Symbol w√§hlen...</option>';
                for (const sym of sortedSymbols) {
                    select.innerHTML += `<option value="${sym}">${sym}</option>`;
                }
            } catch (err) {
                console.error('Failed to load forecast symbols:', err);
            }
        }

        // ========== BATCH FORECAST FUNCTIONS ==========

        let batchForecastCancelled = false;
        let batchForecastRunning = false;

        // Run batch forecast for favorites or all symbols
        async function runBatchForecast(mode) {
            if (batchForecastRunning) {
                showToast('Batch-Prognose l√§uft bereits');
                return;
            }

            const timeframe = document.getElementById('batch-timeframe').value;
            batchForecastCancelled = false;
            batchForecastRunning = true;

            // Update UI
            const btnFavorites = document.getElementById('btn-forecast-favorites');
            const btnAll = document.getElementById('btn-forecast-all');
            const btnCancel = document.getElementById('btn-cancel-batch');
            const progressContainer = document.getElementById('batch-progress-container');
            const statusSpan = document.getElementById('batch-forecast-status');

            btnFavorites.disabled = true;
            btnAll.disabled = true;
            btnCancel.style.display = 'inline-flex';
            progressContainer.style.display = 'block';

            try {
                // Get symbols to process
                let symbols = [];

                if (mode === 'favorites') {
                    statusSpan.textContent = 'Lade Favoriten...';
                    // Get favorites from models endpoint
                    const res = await fetch(`${API_BASE}/forecast/favorites`);
                    const data = await res.json();

                    // Extract unique base symbols from favorites models
                    const symbolSet = new Set();
                    const tfSuffixList = ['_M5', '_M15', '_M30', '_H1', '_H4', '_D1', '_W1', '_MN'];
                    if (data.models && data.models.length > 0) {
                        for (const model of data.models) {
                            let baseSymbol = model.base_symbol || model.symbol;
                            // Remove timeframe suffix if present
                            for (const suffix of tfSuffixList) {
                                if (baseSymbol.endsWith(suffix)) {
                                    baseSymbol = baseSymbol.slice(0, -suffix.length);
                                    break;
                                }
                            }
                            symbolSet.add(baseSymbol);
                        }
                    }
                    symbols = Array.from(symbolSet).sort();

                    if (symbols.length === 0) {
                        showToast('‚ö†Ô∏è Keine Favoriten gefunden. Markieren Sie Symbole im Data Service (config-data.html ‚Üí Symbol Management ‚Üí ‚≠ê) als Favoriten.', 8000);
                        batchForecastRunning = false;
                        btnFavorites.disabled = false;
                        btnAll.disabled = false;
                        btnCancel.style.display = 'none';
                        progressContainer.style.display = 'none';
                        return;
                    }
                } else {
                    statusSpan.textContent = 'Lade alle Symbole...';
                    // Get all symbols with trained models
                    const res = await fetch(`${API_BASE}/forecast/models`);
                    const data = await res.json();

                    const symbolSet = new Set();
                    const tfSuffixList2 = ['_M5', '_M15', '_M30', '_H1', '_H4', '_D1', '_W1', '_MN'];
                    for (const model of data) {
                        if (!model.model_exists) continue;
                        let baseSymbol = model.symbol;
                        for (const suffix of tfSuffixList2) {
                            if (baseSymbol.endsWith(suffix)) {
                                baseSymbol = baseSymbol.slice(0, -suffix.length);
                                break;
                            }
                        }
                        symbolSet.add(baseSymbol);
                    }
                    symbols = Array.from(symbolSet).sort();
                }

                statusSpan.textContent = `${mode === 'favorites' ? 'Favoriten' : 'Alle'}: ${symbols.length} Symbole`;

                // Process symbols
                let completed = 0;
                let successful = 0;
                let failed = 0;
                const total = symbols.length;
                const results = [];

                for (const symbol of symbols) {
                    if (batchForecastCancelled) {
                        showToast('Batch-Prognose abgebrochen');
                        break;
                    }

                    // Update progress
                    updateBatchProgress(completed, total, symbol);

                    try {
                        const res = await fetch(`${API_BASE}/forecast/${symbol}?timeframe=${timeframe}`);
                        const data = await res.json();

                        // Check for various error conditions
                        if (!res.ok || data.error || data.detail || !data.predicted_prices || data.predicted_prices.length === 0) {
                            failed++;
                            const errorMsg = data.error || data.detail || data.message || 'Kein Modell oder keine Daten';
                            results.push({ symbol, success: false, error: errorMsg });
                        } else {
                            successful++;
                            const trend = data.predicted_prices.length > 1 ?
                                (data.predicted_prices[data.predicted_prices.length - 1] > data.current_price ? '‚Üë' : '‚Üì') : '-';
                            results.push({
                                symbol,
                                success: true,
                                trend,
                                currentPrice: data.current_price,
                                predictedPrice: data.predicted_prices[data.predicted_prices.length - 1]
                            });
                        }
                    } catch (err) {
                        failed++;
                        results.push({ symbol, success: false, error: err.message });
                    }

                    completed++;
                    updateBatchProgress(completed, total, completed < total ? symbols[completed] : null);
                }

                // Show final summary
                const summaryDiv = document.getElementById('batch-results-summary');
                const successResults = results.filter(r => r.success);
                const failedResults = results.filter(r => !r.success);

                let summaryHtml = `<strong>Fertig!</strong> ‚úì ${successful} erfolgreich, ‚úó ${failed} fehlgeschlagen<br>`;

                // Show successful forecasts with trend
                if (successResults.length > 0) {
                    summaryHtml += `<div style="margin-top: 0.3rem;">`;
                    summaryHtml += successResults.map(r => `
                        <span style="margin-right: 0.5rem; color: ${r.trend === '‚Üë' ? '#4ade80' : '#f87171'};">${r.symbol} ${r.trend}</span>
                    `).join('');
                    summaryHtml += `</div>`;
                }

                // Show failed forecasts with reason
                if (failedResults.length > 0) {
                    summaryHtml += `<div style="margin-top: 0.3rem; color: #f87171;">`;
                    summaryHtml += `<strong>Fehlgeschlagen:</strong> `;
                    summaryHtml += failedResults.map(r => `
                        <span title="${r.error || 'Unbekannter Fehler'}" style="cursor: help; text-decoration: underline dotted;">${r.symbol}</span>
                    `).join(', ');
                    summaryHtml += `</div>`;
                }

                summaryDiv.innerHTML = summaryHtml;

                showToast(`Batch-Prognose abgeschlossen: ${successful}/${total} erfolgreich`);

            } catch (err) {
                console.error('Batch forecast error:', err);
                showToast('Fehler bei Batch-Prognose: ' + err.message);
            } finally {
                batchForecastRunning = false;
                btnFavorites.disabled = false;
                btnAll.disabled = false;
                btnCancel.style.display = 'none';
            }
        }

        // Update batch progress UI
        function updateBatchProgress(completed, total, currentSymbol) {
            const percent = total > 0 ? Math.round((completed / total) * 100) : 0;

            document.getElementById('batch-progress-text').textContent =
                `${completed} / ${total} Symbole${currentSymbol ? ` (${currentSymbol})` : ''}`;
            document.getElementById('batch-progress-percent').textContent = `${percent}%`;
            document.getElementById('batch-progress-bar').style.width = `${percent}%`;
        }

        // Cancel batch forecast
        function cancelBatchForecast() {
            batchForecastCancelled = true;
            showToast('Batch-Prognose wird abgebrochen...');
        }

        // Run forecast
        async function runForecast() {
            const symbol = document.getElementById('forecast-symbol').value;
            const timeframe = document.getElementById('forecast-timeframe').value;

            if (!symbol) {
                showToast('Bitte w√§hle ein Symbol');
                return;
            }

            const btn = document.getElementById('btn-forecast');
            btn.disabled = true;
            btn.textContent = 'Prognose wird erstellt...';
            showToast(`Erstelle Prognose f√ºr ${symbol}/${timeframe}...`);

            try {
                const res = await fetch(`${API_BASE}/forecast/${symbol}?timeframe=${timeframe}`);
                const data = await res.json();

                if (data.error) {
                    showToast(`Fehler: ${data.error}`);
                    return;
                }

                displayForecastResults(data);
                showToast(`Prognose f√ºr ${symbol} erstellt`);

            } catch (err) {
                console.error('Forecast error:', err);
                showToast('Fehler bei der Prognose');
            } finally {
                btn.disabled = false;
                btn.textContent = 'Prognose erstellen';
            }
        }

        // Display forecast results
        function displayForecastResults(data) {
            // Show results card
            document.getElementById('forecast-results-card').style.display = 'block';

            // Update info (UTC -> local time)
            document.getElementById('forecast-info').textContent =
                `${data.symbol} | ${data.timeframe} | ${formatUTCTimestamp(data.forecast_timestamp)}`;

            // Get current price and predicted prices
            const currentPrice = data.current_price;
            const predictedPrices = data.predicted_prices;
            const lastPrice = predictedPrices[predictedPrices.length - 1];

            // Calculate change from current price to final prediction
            const change = lastPrice - currentPrice;
            const changePercent = (change / currentPrice) * 100;
            const isBullish = change >= 0;

            // Min/Max including current price
            const allPrices = [currentPrice, ...predictedPrices];
            const minPrice = Math.min(...allPrices);
            const maxPrice = Math.max(...allPrices);

            // Update summary
            const summaryEl = document.getElementById('forecast-summary');
            summaryEl.innerHTML = `
                <div class="forecast-summary-grid">
                    <div class="summary-item">
                        <div class="value">${formatPrice(currentPrice, data.symbol)}</div>
                        <div class="label">Aktueller Preis</div>
                    </div>
                    <div class="summary-item">
                        <div class="value ${isBullish ? 'up' : 'down'}">${formatPrice(lastPrice, data.symbol)}</div>
                        <div class="label">Endpreis (${data.horizon_hours}h)</div>
                    </div>
                    <div class="summary-item">
                        <div class="value">${formatPrice(minPrice, data.symbol)}</div>
                        <div class="label">Minimum</div>
                    </div>
                    <div class="summary-item">
                        <div class="value">${formatPrice(maxPrice, data.symbol)}</div>
                        <div class="label">Maximum</div>
                    </div>
                </div>
                <div class="trend-indicator ${isBullish ? 'bullish' : 'bearish'}">
                    <span class="arrow">${isBullish ? '‚Üë' : '‚Üì'}</span>
                    <span class="text">${isBullish ? 'Bullish' : 'Bearish'}: ${changePercent >= 0 ? '+' : ''}${changePercent.toFixed(3)}%</span>
                </div>
            `;
            summaryEl.style.opacity = '1';

            // Generate time labels - start with "Jetzt" for current price
            const labels = [];
            const baseTime = parseUTCDate(data.forecast_timestamp);
            const intervalMinutes = data.timeframe === 'M15' ? 15 : (data.timeframe === 'D1' ? 1440 : 60);

            // First label is "Jetzt" (current time)
            if (data.timeframe === 'D1') {
                labels.push(baseTime.toLocaleDateString('de-DE', { day: '2-digit', month: '2-digit' }));
            } else {
                labels.push('Jetzt');
            }

            // Then add forecast time labels
            for (let i = 0; i < predictedPrices.length; i++) {
                const time = new Date(baseTime.getTime() + (i + 1) * intervalMinutes * 60000);
                if (data.timeframe === 'D1') {
                    labels.push(time.toLocaleDateString('de-DE', { day: '2-digit', month: '2-digit' }));
                } else {
                    labels.push(time.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }));
                }
            }

            // Build chart data with current price as first point
            const chartData = {
                ...data,
                // Include current price at the start
                chartPrices: [currentPrice, ...predictedPrices],
                chartConfidenceLow: [currentPrice, ...data.confidence_low],
                chartConfidenceHigh: [currentPrice, ...data.confidence_high]
            };

            // Update chart
            updateForecastChart(labels, chartData);

            // Update table - show current price first, then predictions
            const tbody = document.getElementById('forecast-tbody');
            let html = '';

            // Current price row
            html += `
                <tr style="background: rgba(59, 130, 246, 0.1);">
                    <td><strong>${labels[0]}</strong></td>
                    <td><strong>${formatPrice(currentPrice, data.symbol)}</strong></td>
                    <td style="opacity: 0.5;">-</td>
                    <td style="opacity: 0.5;">-</td>
                    <td style="opacity: 0.5;">Aktuell</td>
                </tr>
            `;

            // Predicted prices
            for (let i = 0; i < predictedPrices.length; i++) {
                const low = data.confidence_low[i];
                const high = data.confidence_high[i];
                const spread = high - low;

                html += `
                    <tr>
                        <td>${labels[i + 1]}</td>
                        <td><strong>${formatPrice(predictedPrices[i], data.symbol)}</strong></td>
                        <td style="color: #f87171;">${formatPrice(low, data.symbol)}</td>
                        <td style="color: #4ade80;">${formatPrice(high, data.symbol)}</td>
                        <td style="opacity: 0.7;">${formatPrice(spread, data.symbol)}</td>
                    </tr>
                `;
            }
            tbody.innerHTML = html;
        }

        // Parse UTC timestamp (API returns timestamps without Z suffix but they are UTC)
        function parseUTCDate(timestamp) {
            if (!timestamp) return null;
            // Handle various UTC timestamp formats:
            // - "2026-01-14T18:23:31.382089Z" (Z suffix)
            // - "2026-01-14T18:23:31.382089+00:00" (offset suffix)
            // - "2026-01-14T18:23:31.382089" (no suffix - assume UTC)
            let ts = timestamp;
            if (!timestamp.endsWith('Z') && !timestamp.includes('+') && !timestamp.includes('-', 10)) {
                // No timezone info, append Z for UTC
                ts = timestamp + 'Z';
            }
            return new Date(ts);
        }

        // Format a UTC timestamp for display in local timezone
        function formatUTCTimestamp(timestamp) {
            const d = parseUTCDate(timestamp);
            if (!d || isNaN(d.getTime())) return '-';
            return d.toLocaleDateString('de-DE') + ' ' + d.toLocaleTimeString('de-DE', {hour: '2-digit', minute: '2-digit'});
        }

        // Format price based on symbol
        function formatPrice(price, symbol) {
            if (symbol.includes('JPY')) {
                return price.toFixed(3);
            } else if (symbol.includes('BTC') || symbol.includes('ETH')) {
                return price.toFixed(2);
            } else if (symbol.includes('XAU')) {
                return price.toFixed(2);
            } else {
                return price.toFixed(5);
            }
        }

        // Update forecast chart
        function updateForecastChart(labels, data) {
            const ctx = document.getElementById('forecastCanvas').getContext('2d');

            if (forecastChart) {
                forecastChart.destroy();
            }

            // Use chart-specific arrays that include current price at start
            const chartPrices = data.chartPrices || data.predicted_prices;
            const chartConfidenceHigh = data.chartConfidenceHigh || data.confidence_high;
            const chartConfidenceLow = data.chartConfidenceLow || data.confidence_low;

            // Create point styling - first point (current price) gets different color
            const pointBackgroundColors = chartPrices.map((_, i) => i === 0 ? '#3b82f6' : '#64c8ff');
            const pointRadii = chartPrices.map((_, i) => i === 0 ? 6 : 2);

            forecastChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Konfidenz (Hoch)',
                            data: chartConfidenceHigh,
                            borderColor: 'rgba(74, 222, 128, 0.3)',
                            backgroundColor: 'rgba(74, 222, 128, 0.1)',
                            borderWidth: 1,
                            fill: false,
                            pointRadius: 0,
                            tension: 0.3
                        },
                        {
                            label: 'Prognose',
                            data: chartPrices,
                            borderColor: '#64c8ff',
                            backgroundColor: 'rgba(100, 200, 255, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            pointRadius: pointRadii,
                            pointBackgroundColor: pointBackgroundColors,
                            pointBorderColor: pointBackgroundColors,
                            pointHoverRadius: 5,
                            tension: 0.3
                        },
                        {
                            label: 'Konfidenz (Tief)',
                            data: chartConfidenceLow,
                            borderColor: 'rgba(248, 113, 113, 0.3)',
                            backgroundColor: 'rgba(248, 113, 113, 0.1)',
                            borderWidth: 1,
                            fill: '-1',
                            pointRadius: 0,
                            tension: 0.3
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                color: '#a0a0a0',
                                font: { size: 11 }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#fff',
                            bodyColor: '#e8e8e8',
                            borderColor: 'rgba(100, 200, 255, 0.3)',
                            borderWidth: 1
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: 'rgba(255, 255, 255, 0.05)' },
                            ticks: { color: '#a0a0a0', font: { size: 10 } }
                        },
                        y: {
                            grid: { color: 'rgba(255, 255, 255, 0.05)' },
                            ticks: {
                                color: '#a0a0a0',
                                font: { size: 10 },
                                callback: function(value) {
                                    return formatPrice(value, data.symbol);
                                }
                            }
                        }
                    }
                }
            });
        }

        // Load forecast symbols on page load
        loadForecastSymbols();

        // ========== SELF-LEARNING TAB ==========
        let selfLearningEnabled = true;
        let selfLearningRetrainEnabled = true;

        // Load Self-Learning status
        async function loadSelfLearningStatus() {
            try {
                const res = await fetch(`${API_BASE}/forecast/auto-status`);
                const data = await res.json();

                // Update stats
                const evalStatus = data.auto_evaluation;
                const retrainStatus = data.auto_retrain;
                const predictions = data.predictions;

                selfLearningEnabled = evalStatus.enabled;
                selfLearningRetrainEnabled = retrainStatus.enabled;

                // Update toggle button
                const btn = document.getElementById('selflearn-toggle-btn');
                if (selfLearningEnabled && selfLearningRetrainEnabled) {
                    btn.innerHTML = '‚úÖ Aktiviert';
                    btn.classList.remove('btn-danger');
                    btn.classList.add('btn-purple');
                } else {
                    btn.innerHTML = '‚ùå Deaktiviert';
                    btn.classList.remove('btn-purple');
                    btn.classList.add('btn-danger');
                }

                // Update cooldown
                document.getElementById('sl-stat-cooldown').textContent = `${retrainStatus.cooldown_hours}h`;
                document.getElementById('sl-cooldown-select').value = retrainStatus.cooldown_hours.toString();

                // Update stats
                document.getElementById('sl-stat-total-retrains').textContent = retrainStatus.total_retrains;
                document.getElementById('sl-stat-pending').textContent = predictions.pending_count;
                document.getElementById('sl-stat-evaluated').textContent = predictions.evaluated_count;

                // Update interval select
                const intervalSelect = document.getElementById('sl-interval-select');
                if (evalStatus.interval_seconds) {
                    intervalSelect.value = evalStatus.interval_seconds.toString();
                }

                // Show retrain candidates if any
                const candidatesCard = document.getElementById('sl-retrain-candidates-card');
                const candidatesDiv = document.getElementById('sl-retrain-candidates');

                if (data.symbols_needing_retrain && data.symbols_needing_retrain.length > 0) {
                    candidatesCard.style.display = 'block';
                    candidatesDiv.innerHTML = data.symbols_needing_retrain.map(symbol => `
                        <div style="display: inline-block; padding: 0.4rem 0.8rem; margin: 0.25rem; background: rgba(255,193,7,0.2); border-radius: 4px; font-size: 0.9rem;">
                            <span style="color: #fbbf24;">‚ö†Ô∏è</span> ${symbol}
                        </div>
                    `).join('');
                } else {
                    candidatesCard.style.display = 'none';
                }

                // Update manual retrain button
                const manualBtn = document.getElementById('selflearn-manual-btn');
                if (retrainStatus.in_progress) {
                    manualBtn.disabled = true;
                    manualBtn.innerHTML = '‚è≥ Training l√§uft...';
                    manualBtn.classList.add('btn-loading');
                    document.getElementById('selflearn-retrain-progress').style.display = 'block';
                } else {
                    manualBtn.disabled = false;
                    manualBtn.innerHTML = '‚öôÔ∏è Manuell trainieren';
                    manualBtn.classList.remove('btn-loading');
                    document.getElementById('selflearn-retrain-progress').style.display = 'none';
                }

                // Load evaluations and performance
                await loadSelfLearningEvaluations();
                await loadSelfLearningPerformance();

            } catch (err) {
                console.error('Failed to load self-learning status:', err);
                showToast('Fehler beim Laden des Self-Learning Status');
            }
        }

        // Load recent evaluations
        async function loadSelfLearningEvaluations() {
            const tbody = document.getElementById('sl-evaluations-tbody');

            try {
                const res = await fetch(`${API_BASE}/forecast/evaluated?limit=30`);

                if (!res.ok) {
                    console.error('API returned error:', res.status, res.statusText);
                    tbody.innerHTML = `
                        <tr>
                            <td colspan="7" style="text-align: center; padding: 2rem; color: #f87171;">
                                API-Fehler: ${res.status} ${res.statusText}
                            </td>
                        </tr>
                    `;
                    return;
                }

                const data = await res.json();
                console.log('Evaluations data:', data);

                if (!data.predictions || data.predictions.length === 0) {
                    tbody.innerHTML = `
                        <tr>
                            <td colspan="7" style="text-align: center; padding: 2rem; color: #666;">
                                Noch keine Evaluierungen vorhanden.<br>
                                <small style="opacity: 0.7;">Prognosen werden automatisch evaluiert, sobald der Horizont erreicht ist.</small>
                            </td>
                        </tr>
                    `;
                    return;
                }

                tbody.innerHTML = data.predictions.map(pred => {
                    const directionIcon = pred.direction_correct ?
                        '<span style="color: #4ade80;">‚úì</span>' :
                        '<span style="color: #f87171;">‚úó</span>';

                    const errorColor = pred.prediction_error_pct < 0.5 ? '#4ade80' :
                                       pred.prediction_error_pct < 1.0 ? '#fbbf24' : '#f87171';

                    const formatPrice = (price) => {
                        if (!price) return '-';
                        if (price < 1) return price.toFixed(5);
                        if (price < 100) return price.toFixed(4);
                        return price.toFixed(2);
                    };

                    return `
                        <tr>
                            <td style="font-size: 0.85rem;">${pred.evaluated_at ? formatUTCTimestamp(pred.evaluated_at) : '-'}</td>
                            <td><strong>${pred.symbol}</strong></td>
                            <td>${pred.horizon}</td>
                            <td>${formatPrice(pred.predicted_price)}</td>
                            <td>${formatPrice(pred.actual_price)}</td>
                            <td style="color: ${errorColor};">${pred.prediction_error_pct?.toFixed(3) || '-'}%</td>
                            <td>${directionIcon}</td>
                        </tr>
                    `;
                }).join('');

            } catch (err) {
                console.error('Failed to load evaluations:', err);
                tbody.innerHTML = `
                    <tr>
                        <td colspan="7" style="text-align: center; padding: 2rem; color: #f87171;">
                            Fehler: ${err.message}
                        </td>
                    </tr>
                `;
            }
        }

        // Load performance by symbol
        async function loadSelfLearningPerformance() {
            const tbody = document.getElementById('sl-performance-tbody');

            try {
                const res = await fetch(`${API_BASE}/forecast/performance`);

                if (!res.ok) {
                    console.error('Performance API error:', res.status);
                    tbody.innerHTML = `
                        <tr>
                            <td colspan="5" style="text-align: center; padding: 2rem; color: #f87171;">
                                API-Fehler: ${res.status}
                            </td>
                        </tr>
                    `;
                    return;
                }

                const data = await res.json();
                console.log('Performance data:', data);

                if (!data.by_symbol || Object.keys(data.by_symbol).length === 0) {
                    tbody.innerHTML = `
                        <tr>
                            <td colspan="5" style="text-align: center; padding: 2rem; color: #666;">
                                Noch keine Performance-Daten vorhanden
                            </td>
                        </tr>
                    `;
                    // Update avg accuracy
                    document.getElementById('sl-stat-improvement').textContent = '-';
                    return;
                }

                // Calculate average accuracy
                let totalAcc = 0;
                let symbolCount = 0;

                const symbols = Object.entries(data.by_symbol).sort((a, b) => b[1].evaluated - a[1].evaluated);

                tbody.innerHTML = symbols.map(([symbol, perf]) => {
                    const directionAcc = (perf.direction_accuracy * 100).toFixed(1);
                    const avgError = perf.avg_error_pct?.toFixed(3) || '0.000';

                    if (perf.evaluated > 0) {
                        totalAcc += perf.direction_accuracy * 100;
                        symbolCount++;
                    }

                    const directionColor = perf.direction_accuracy >= 0.5 ? '#4ade80' :
                                          perf.direction_accuracy >= 0.45 ? '#fbbf24' : '#f87171';

                    const statusBadge = perf.needs_retraining ?
                        '<span class="badge badge-failed">Retrain</span>' :
                        '<span class="badge badge-success">OK</span>';

                    return `
                        <tr>
                            <td><strong>${symbol}</strong></td>
                            <td>${perf.evaluated}</td>
                            <td>${avgError}%</td>
                            <td style="color: ${directionColor};">${directionAcc}%</td>
                            <td>${statusBadge}</td>
                        </tr>
                    `;
                }).join('');

                // Update avg accuracy stat
                if (symbolCount > 0) {
                    const avgAcc = (totalAcc / symbolCount).toFixed(1);
                    document.getElementById('sl-stat-improvement').textContent = `${avgAcc}%`;
                    document.getElementById('sl-stat-improvement').style.color =
                        parseFloat(avgAcc) >= 50 ? '#4ade80' : '#fbbf24';
                }

            } catch (err) {
                console.error('Failed to load performance:', err);
            }
        }

        // Toggle Self-Learning (both eval and retrain)
        async function toggleSelfLearning() {
            const newState = !(selfLearningEnabled && selfLearningRetrainEnabled);

            try {
                // Toggle both evaluation and retrain
                await fetch(`${API_BASE}/forecast/auto-evaluation/toggle?enabled=${newState}`, { method: 'POST' });
                await fetch(`${API_BASE}/forecast/auto-retrain/toggle?enabled=${newState}`, { method: 'POST' });

                showToast(newState ? 'Self-Learning aktiviert' : 'Self-Learning deaktiviert');
                await loadSelfLearningStatus();
            } catch (err) {
                console.error('Failed to toggle self-learning:', err);
                showToast('Fehler beim Umschalten');
            }
        }

        // Update Self-Learning config (placeholder - server-side config would be needed)
        function updateSelfLearnConfig() {
            const threshold = document.getElementById('sl-threshold-select').value;
            document.getElementById('sl-stat-threshold').textContent = `${(parseFloat(threshold) * 100).toFixed(0)}%`;
            showToast(`Schwelle auf ${(parseFloat(threshold) * 100).toFixed(0)}% gesetzt (Client-seitig)`);
        }

        // Update cooldown
        async function updateSelfLearnCooldown() {
            const hours = parseInt(document.getElementById('sl-cooldown-select').value);
            try {
                await fetch(`${API_BASE}/forecast/auto-retrain/cooldown?hours=${hours}`, { method: 'POST' });
                showToast(`Cooldown auf ${hours}h gesetzt`);
                document.getElementById('sl-stat-cooldown').textContent = `${hours}h`;
            } catch (err) {
                console.error('Failed to update cooldown:', err);
                showToast('Fehler beim Setzen des Cooldowns');
            }
        }

        // Trigger manual evaluation
        async function triggerManualEvaluation() {
            try {
                showToast('Evaluierung gestartet...');
                const res = await fetch(`${API_BASE}/forecast/evaluate`, { method: 'POST' });
                const data = await res.json();

                if (data.success) {
                    const count = data.evaluated_count || 0;
                    showToast(`${count} Prognosen evaluiert`);
                    await loadSelfLearningStatus();
                } else {
                    showToast('Evaluierung fehlgeschlagen');
                }
            } catch (err) {
                console.error('Failed to trigger evaluation:', err);
                showToast('Fehler bei der Evaluierung');
            }
        }

        // Trigger manual retrain
        async function triggerManualRetrain() {
            const btn = document.getElementById('selflearn-manual-btn');
            btn.disabled = true;
            btn.innerHTML = '‚è≥ Training l√§uft...';
            btn.classList.add('btn-loading');

            document.getElementById('selflearn-retrain-progress').style.display = 'block';
            document.getElementById('selflearn-retrain-status').textContent = 'Suche nach Symbolen f√ºr Retrain...';

            try {
                const res = await fetch(`${API_BASE}/forecast/retrain-poor-performers`, { method: 'POST' });
                const data = await res.json();

                if (data.success) {
                    if (data.symbols && data.symbols.length > 0) {
                        document.getElementById('selflearn-retrain-status').textContent =
                            `Training f√ºr: ${data.symbols.join(', ')}`;
                        showToast(`Retrain gestartet f√ºr ${data.symbols.length} Symbole`);

                        // Start polling
                        startSelfLearnRetrainPolling();
                    } else {
                        showToast(data.message || 'Keine Modelle ben√∂tigen Retraining');
                        document.getElementById('selflearn-retrain-progress').style.display = 'none';
                        btn.disabled = false;
                        btn.innerHTML = '‚öôÔ∏è Manuell trainieren';
                        btn.classList.remove('btn-loading');
                    }
                } else {
                    showToast('Fehler: ' + (data.detail || 'Unbekannter Fehler'));
                    document.getElementById('selflearn-retrain-progress').style.display = 'none';
                    btn.disabled = false;
                    btn.innerHTML = '‚öôÔ∏è Manuell trainieren';
                    btn.classList.remove('btn-loading');
                }
            } catch (err) {
                console.error('Manual retrain failed:', err);
                showToast('Fehler: ' + err.message);
                document.getElementById('selflearn-retrain-progress').style.display = 'none';
                btn.disabled = false;
                btn.innerHTML = '‚öôÔ∏è Manuell trainieren';
                btn.classList.remove('btn-loading');
            }
        }

        // Poll for retrain status
        let selfLearnRetrainPolling = null;
        function startSelfLearnRetrainPolling() {
            if (selfLearnRetrainPolling) return;

            selfLearnRetrainPolling = setInterval(async () => {
                try {
                    const res = await fetch(`${API_BASE}/forecast/auto-status`);
                    const data = await res.json();

                    if (!data.auto_retrain.in_progress) {
                        clearInterval(selfLearnRetrainPolling);
                        selfLearnRetrainPolling = null;

                        document.getElementById('selflearn-retrain-progress').style.display = 'none';
                        document.getElementById('selflearn-manual-btn').disabled = false;
                        document.getElementById('selflearn-manual-btn').innerHTML = '‚öôÔ∏è Manuell trainieren';
                        document.getElementById('selflearn-manual-btn').classList.remove('btn-loading');

                        showToast('Retrain abgeschlossen');
                        await loadSelfLearningStatus();
                    }
                } catch (err) {
                    console.error('Polling error:', err);
                }
            }, 3000);
        }

        // ========== BACKUP TAB ==========
        let currentBackupData = null;
        let currentBackupFilename = null;
        let currentBackupType = null;

        // Load backup status
        async function loadBackupStatus() {
            const content = document.getElementById('backup-status-content');
            try {
                const res = await fetch(`${API_BASE}/backup/status`);
                const data = await res.json();

                content.innerHTML = `
                    <div class="stats-bar" style="margin-bottom: 1rem;">
                        <div class="stat-item">
                            <div class="stat-value">${data.models.count}</div>
                            <div class="stat-label">Modelle</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${data.models.size_mb} MB</div>
                            <div class="stat-label">Modell-Gr√∂√üe</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${data.predictions.pending_count}</div>
                            <div class="stat-label">Ausstehende Prognosen</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${data.predictions.evaluated_count}</div>
                            <div class="stat-label">Evaluierte Prognosen</div>
                        </div>
                    </div>
                    <div style="opacity: 0.7; font-size: 0.85rem;">
                        <p><strong>Modell-Pfad:</strong> ${data.models.path}</p>
                        <p><strong>Symbole mit Metriken:</strong> ${data.predictions.symbols_with_metrics}</p>
                        <p><strong>Letzte Aktualisierung:</strong> ${formatUTCTimestamp(data.timestamp)}</p>
                    </div>
                `;
            } catch (err) {
                console.error('Failed to load backup status:', err);
                content.innerHTML = '<div style="color: #e57373;">Fehler beim Laden des Status</div>';
            }
        }

        // Backup models - direct download
        async function backupModels() {
            const btn = document.getElementById('btn-backup-models');
            btn.disabled = true;
            btn.textContent = '‚è≥ Pr√ºfe Modelle...';

            try {
                // First check if models are available
                const res = await fetch(`${API_BASE}/backup/models`, { method: 'POST' });
                const data = await res.json();

                if (data.success) {
                    showBackupResult(
                        'Modell-Backup bereit',
                        `<p>‚úÖ <strong>${data.model_count} Modelle</strong> und <strong>${data.metadata_count} Metadaten</strong> bereit</p>
                         <p>Gesch√§tzte Gr√∂√üe: <strong>${data.size_mb} MB</strong></p>
                         <p style="opacity: 0.7;">Der Download wird gestartet...</p>`,
                        false
                    );

                    // Trigger direct download
                    showToast('Download wird gestartet...');
                    const downloadLink = document.createElement('a');
                    downloadLink.href = `${API_BASE}/backup/models/download`;
                    downloadLink.download = `nhits_models_backup.zip`;
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);

                    showToast(data.message);
                } else {
                    showBackupResult('Backup fehlgeschlagen', `<p style="color: #e57373;">${data.message}</p>`, false);
                }
            } catch (err) {
                console.error('Backup failed:', err);
                showToast('Backup fehlgeschlagen: ' + err.message);
            } finally {
                btn.disabled = false;
                btn.textContent = 'üíæ Modelle sichern (ZIP)';
            }
        }

        // Backup predictions
        async function backupPredictions() {
            const btn = document.getElementById('btn-backup-predictions');
            btn.disabled = true;
            btn.textContent = '‚è≥ Erstelle Backup...';
            showToast('Erstelle Prognose-Backup...');

            try {
                const res = await fetch(`${API_BASE}/backup/predictions`, { method: 'POST' });
                const data = await res.json();

                if (data.success) {
                    currentBackupData = JSON.stringify(data.backup_data, null, 2);
                    currentBackupFilename = data.filename;
                    currentBackupType = 'predictions';

                    showBackupResult(
                        'Prognose-Backup erstellt',
                        `<p>‚úÖ Prognose-Daten gesichert:</p>
                         <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
                            <li><strong>${data.pending_count}</strong> ausstehende Prognosen</li>
                            <li><strong>${data.evaluated_count}</strong> evaluierte Prognosen</li>
                            <li><strong>${data.metrics_count}</strong> Symbol-Metriken</li>
                         </ul>
                         <p style="opacity: 0.7;">Dateiname: ${data.filename}</p>`,
                        true
                    );
                    showToast(data.message);
                } else {
                    // Handle both 'message' and 'detail' (FastAPI error format)
                    const errorMsg = data.message || data.detail || 'Unbekannter Fehler';
                    showBackupResult('Backup fehlgeschlagen', `<p style="color: #e57373;">${errorMsg}</p>`, false);
                }
            } catch (err) {
                console.error('Backup failed:', err);
                showToast('Backup fehlgeschlagen: ' + err.message);
            } finally {
                btn.disabled = false;
                btn.textContent = 'üíæ Prognosen sichern (JSON)';
            }
        }

        // Show backup result
        function showBackupResult(title, content, showDownload) {
            document.getElementById('backup-result-card').style.display = 'block';
            document.getElementById('backup-result-title').textContent = title;
            document.getElementById('backup-result-content').innerHTML = content;
            document.getElementById('backup-download-btn').style.display = showDownload ? 'inline-flex' : 'none';
        }

        // Download backup
        function downloadBackup() {
            if (!currentBackupData || !currentBackupFilename) return;

            let blob;
            if (currentBackupType === 'models') {
                // Decode base64 and create blob
                const byteCharacters = atob(currentBackupData);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                blob = new Blob([byteArray], { type: 'application/zip' });
            } else {
                blob = new Blob([currentBackupData], { type: 'application/json' });
            }

            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = currentBackupFilename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showToast('Download gestartet: ' + currentBackupFilename);
        }

        // Restore models
        async function restoreModels(input) {
            if (!input.files || input.files.length === 0) return;

            const file = input.files[0];
            showToast('Stelle Modelle wieder her...');

            try {
                const formData = new FormData();
                formData.append('file', file);

                const res = await fetch(`${API_BASE}/restore/models`, {
                    method: 'POST',
                    body: formData
                });
                const data = await res.json();

                if (data.success) {
                    showBackupResult(
                        'Wiederherstellung erfolgreich',
                        `<p>‚úÖ Backup wiederhergestellt:</p>
                         <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
                            <li><strong>${data.restored_models}</strong> Modelle</li>
                            <li><strong>${data.restored_metadata}</strong> Metadaten</li>
                         </ul>`,
                        false
                    );
                    showToast(data.message);
                    loadBackupStatus();
                } else {
                    showToast('Wiederherstellung fehlgeschlagen: ' + (data.detail || 'Unbekannter Fehler'));
                }
            } catch (err) {
                console.error('Restore failed:', err);
                showToast('Wiederherstellung fehlgeschlagen: ' + err.message);
            }

            input.value = '';
        }

        // Restore predictions
        async function restorePredictions(input) {
            if (!input.files || input.files.length === 0) return;

            const file = input.files[0];
            showToast('Stelle Prognosen wieder her...');

            try {
                const formData = new FormData();
                formData.append('file', file);

                const res = await fetch(`${API_BASE}/restore/predictions`, {
                    method: 'POST',
                    body: formData
                });
                const data = await res.json();

                if (data.success) {
                    showBackupResult(
                        'Wiederherstellung erfolgreich',
                        `<p>‚úÖ Prognose-Backup wiederhergestellt:</p>
                         <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
                            <li><strong>${data.restored_pending}</strong> ausstehende Prognosen</li>
                            <li><strong>${data.restored_evaluated}</strong> evaluierte Prognosen</li>
                            <li><strong>${data.restored_metrics}</strong> Metriken</li>
                         </ul>`,
                        false
                    );
                    showToast(data.message);
                    loadBackupStatus();
                } else {
                    showToast('Wiederherstellung fehlgeschlagen: ' + (data.detail || 'Unbekannter Fehler'));
                }
            } catch (err) {
                console.error('Restore failed:', err);
                showToast('Wiederherstellung fehlgeschlagen: ' + err.message);
            }

            input.value = '';
        }

        // Clear predictions
        async function clearPredictions() {
            if (!confirm('Alle Prognose-Daten l√∂schen? Diese Aktion kann nicht r√ºckg√§ngig gemacht werden!')) {
                return;
            }

            const btn = document.getElementById('btn-clear-predictions');
            btn.disabled = true;
            btn.textContent = '‚è≥ L√∂sche...';

            try {
                const res = await fetch(`${API_BASE}/backup/predictions/clear`, { method: 'DELETE' });
                const data = await res.json();

                if (data.success) {
                    showBackupResult(
                        'Daten gel√∂scht',
                        `<p>‚úÖ Alle Prognose-Daten wurden gel√∂scht:</p>
                         <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
                            <li><strong>${data.cleared_pending}</strong> ausstehende Prognosen</li>
                            <li><strong>${data.cleared_evaluated}</strong> evaluierte Prognosen</li>
                            <li><strong>${data.cleared_metrics}</strong> Metriken</li>
                         </ul>`,
                        false
                    );
                    showToast(data.message);
                    loadBackupStatus();
                } else {
                    showToast('L√∂schen fehlgeschlagen');
                }
            } catch (err) {
                console.error('Clear failed:', err);
                showToast('L√∂schen fehlgeschlagen: ' + err.message);
            } finally {
                btn.disabled = false;
                btn.textContent = 'üóëÔ∏è Prognose-Daten l√∂schen';
            }
        }

        // ========== AUTO-FORECAST FUNCTIONS ==========

        // Load auto-forecast status (favorites + daily)
        async function loadAutoForecastStatus() {
            try {
                const res = await fetch(`${API_BASE}/forecast/auto/status`);
                const data = await res.json();

                updateFavoritesAutoStatus(data.favorites);
                updateDailyAutoStatus(data.daily);
                updateAutoForecastStats(data);

            } catch (err) {
                console.error('Failed to load auto-forecast status:', err);
                document.getElementById('favorites-auto-status').innerHTML =
                    '<span style="color: #f87171;">Fehler beim Laden</span>';
                document.getElementById('daily-auto-status').innerHTML =
                    '<span style="color: #f87171;">Fehler beim Laden</span>';
            }
        }

        function updateFavoritesAutoStatus(favorites) {
            const statusDiv = document.getElementById('favorites-auto-status');
            const startBtn = document.getElementById('btn-start-favorites-auto');
            const stopBtn = document.getElementById('btn-stop-favorites-auto');

            if (favorites.running) {
                // Show running status
                const activeTimeframes = favorites.enabled_timeframes.join(', ') || 'Keine';
                let statusHtml = `<span class="badge badge-success">Aktiv</span> `;
                statusHtml += `<span style="opacity: 0.8;">Timeframes: ${activeTimeframes}</span>`;

                // Show last run times (UTC -> local time) - only for enabled timeframes
                if (favorites.timeframes && favorites.enabled_timeframes) {
                    const lastRuns = [];
                    for (const tf of favorites.enabled_timeframes) {
                        const info = favorites.timeframes[tf];
                        if (info && info.last_run) {
                            const d = parseUTCDate(info.last_run);
                            if (d && !isNaN(d.getTime())) {
                                lastRuns.push(`${tf}: ${d.toLocaleTimeString('de-DE', {hour: '2-digit', minute: '2-digit'})}`);
                            }
                        }
                    }
                    if (lastRuns.length > 0) {
                        statusHtml += `<div style="font-size: 0.8rem; opacity: 0.7; margin-top: 0.3rem;">Letzte: ${lastRuns.join(', ')}</div>`;
                    }
                }

                statusDiv.innerHTML = statusHtml;
                startBtn.style.display = 'none';
                stopBtn.style.display = 'inline-flex';

                // Update checkboxes to reflect active timeframes
                document.getElementById('auto-tf-m5').checked = favorites.enabled_timeframes.includes('M5');
                document.getElementById('auto-tf-m15').checked = favorites.enabled_timeframes.includes('M15');
                document.getElementById('auto-tf-h1').checked = favorites.enabled_timeframes.includes('H1');
                document.getElementById('auto-tf-h4').checked = favorites.enabled_timeframes.includes('H4');
                document.getElementById('auto-tf-d1').checked = favorites.enabled_timeframes.includes('D1');
                document.getElementById('auto-tf-w1').checked = favorites.enabled_timeframes.includes('W1');
            } else {
                // Show saved timeframes info if available
                let statusHtml = '<span class="badge badge-failed">Inaktiv</span>';
                if (favorites.enabled_timeframes && favorites.enabled_timeframes.length > 0) {
                    statusHtml += ` <span style="opacity: 0.6; font-size: 0.85rem;">(Gespeichert: ${favorites.enabled_timeframes.join(', ')})</span>`;
                    // Restore checkboxes from saved config
                    document.getElementById('auto-tf-m5').checked = favorites.enabled_timeframes.includes('M5');
                    document.getElementById('auto-tf-m15').checked = favorites.enabled_timeframes.includes('M15');
                    document.getElementById('auto-tf-h1').checked = favorites.enabled_timeframes.includes('H1');
                    document.getElementById('auto-tf-h4').checked = favorites.enabled_timeframes.includes('H4');
                    document.getElementById('auto-tf-d1').checked = favorites.enabled_timeframes.includes('D1');
                    document.getElementById('auto-tf-w1').checked = favorites.enabled_timeframes.includes('W1');
                }
                statusDiv.innerHTML = statusHtml;
                startBtn.style.display = 'inline-flex';
                stopBtn.style.display = 'none';
            }
        }

        function updateDailyAutoStatus(daily) {
            const statusDiv = document.getElementById('daily-auto-status');
            const startBtn = document.getElementById('btn-start-daily-auto');
            const stopBtn = document.getElementById('btn-stop-daily-auto');

            if (daily.running) {
                let statusHtml = `<span class="badge badge-success">Aktiv</span> `;
                statusHtml += `<span style="opacity: 0.8;">${daily.scheduled_time} ${daily.timezone}</span>`;

                if (daily.next_run) {
                    const nextRun = parseUTCDate(daily.next_run);
                    const hoursUntil = Math.round((nextRun - new Date()) / 3600000 * 10) / 10;
                    statusHtml += `<div style="font-size: 0.8rem; opacity: 0.7; margin-top: 0.3rem;">N√§chste Ausf√ºhrung in ${hoursUntil}h</div>`;
                }

                if (daily.last_run) {
                    statusHtml += `<div style="font-size: 0.8rem; opacity: 0.7;">Letzte: ${formatUTCTimestamp(daily.last_run)}</div>`;
                }

                statusDiv.innerHTML = statusHtml;
                startBtn.style.display = 'none';
                stopBtn.style.display = 'inline-flex';

                // Update form values
                document.getElementById('daily-scheduled-time').value = daily.scheduled_time;
                const tzSelect = document.getElementById('daily-timezone');
                for (let opt of tzSelect.options) {
                    if (opt.value === daily.timezone) {
                        opt.selected = true;
                        break;
                    }
                }
            } else {
                statusDiv.innerHTML = '<span class="badge badge-failed">Inaktiv</span>';
                startBtn.style.display = 'inline-flex';
                stopBtn.style.display = 'none';
            }
        }

        function updateAutoForecastStats(data) {
            document.getElementById('stat-favorites-total').textContent = data.favorites?.total_forecasts || 0;
            document.getElementById('stat-favorites-failed').textContent = data.favorites?.failed_forecasts || 0;
            document.getElementById('stat-daily-total').textContent = data.daily?.total_forecasts || 0;
            document.getElementById('stat-daily-failed').textContent = data.daily?.failed_forecasts || 0;
            document.getElementById('stat-forecast-count').textContent = data.forecast_count || 0;
        }

        // Start favorites auto-forecast
        async function startFavoritesAutoForecast() {
            const timeframes = [];
            if (document.getElementById('auto-tf-m5').checked) timeframes.push('M5');
            if (document.getElementById('auto-tf-m15').checked) timeframes.push('M15');
            if (document.getElementById('auto-tf-h1').checked) timeframes.push('H1');
            if (document.getElementById('auto-tf-h4').checked) timeframes.push('H4');
            if (document.getElementById('auto-tf-d1').checked) timeframes.push('D1');
            if (document.getElementById('auto-tf-w1').checked) timeframes.push('W1');

            if (timeframes.length === 0) {
                showToast('Mindestens ein Timeframe muss ausgew√§hlt sein', 'warning');
                return;
            }

            try {
                const res = await fetch(`${API_BASE}/forecast/auto/favorites/start?timeframes=${timeframes.join(',')}`, {
                    method: 'POST'
                });
                const data = await res.json();

                if (res.ok) {
                    showToast(`Favoriten Auto-Prognose gestartet: ${timeframes.join(', ')}`, 'success');
                    await loadAutoForecastStatus();
                } else {
                    showToast(data.detail || 'Fehler beim Starten', 'error');
                }
            } catch (err) {
                console.error('Failed to start favorites auto-forecast:', err);
                showToast('Fehler beim Starten: ' + err.message, 'error');
            }
        }

        // Stop favorites auto-forecast
        async function stopFavoritesAutoForecast() {
            try {
                const res = await fetch(`${API_BASE}/forecast/auto/favorites/stop`, {
                    method: 'POST'
                });
                const data = await res.json();

                if (res.ok) {
                    showToast('Favoriten Auto-Prognose gestoppt', 'info');
                    await loadAutoForecastStatus();
                } else {
                    showToast(data.detail || 'Fehler beim Stoppen', 'error');
                }
            } catch (err) {
                console.error('Failed to stop favorites auto-forecast:', err);
                showToast('Fehler beim Stoppen: ' + err.message, 'error');
            }
        }

        // Save timeframe selection (called on checkbox change)
        let saveTimeframeTimeout = null;
        async function saveTimeframeSelection() {
            // Debounce to avoid multiple rapid calls
            if (saveTimeframeTimeout) {
                clearTimeout(saveTimeframeTimeout);
            }

            saveTimeframeTimeout = setTimeout(async () => {
                const timeframes = [];
                if (document.getElementById('auto-tf-m5').checked) timeframes.push('M5');
                if (document.getElementById('auto-tf-m15').checked) timeframes.push('M15');
                if (document.getElementById('auto-tf-h1').checked) timeframes.push('H1');
                if (document.getElementById('auto-tf-h4').checked) timeframes.push('H4');
                if (document.getElementById('auto-tf-d1').checked) timeframes.push('D1');
                if (document.getElementById('auto-tf-w1').checked) timeframes.push('W1');

                if (timeframes.length === 0) {
                    showToast('Mindestens ein Timeframe muss ausgew√§hlt sein', 'warning');
                    return;
                }

                try {
                    const res = await fetch(`${API_BASE}/forecast/auto/favorites/update-timeframes?timeframes=${timeframes.join(',')}`, {
                        method: 'POST'
                    });
                    const data = await res.json();

                    if (res.ok) {
                        if (data.running) {
                            showToast(`Timeframes aktualisiert: ${timeframes.join(', ')}`, 'success');
                        } else {
                            showToast(`Timeframes gespeichert: ${timeframes.join(', ')}`, 'info');
                        }
                        await loadAutoForecastStatus();
                    } else {
                        showToast(data.detail || 'Fehler beim Speichern', 'error');
                    }
                } catch (err) {
                    console.error('Failed to save timeframe selection:', err);
                    showToast('Fehler beim Speichern: ' + err.message, 'error');
                }
            }, 500); // 500ms debounce
        }

        // Start daily auto-forecast
        async function startDailyAutoForecast() {
            const scheduledTime = document.getElementById('daily-scheduled-time').value;
            const timezone = document.getElementById('daily-timezone').value;

            if (!scheduledTime) {
                showToast('Bitte eine Zeit eingeben', 'warning');
                return;
            }

            try {
                const params = new URLSearchParams({
                    scheduled_time: scheduledTime,
                    timezone: timezone
                });
                const res = await fetch(`${API_BASE}/forecast/auto/daily/start?${params}`, {
                    method: 'POST'
                });
                const data = await res.json();

                if (res.ok) {
                    showToast(`T√§gliche Auto-Prognose gestartet: ${scheduledTime} ${timezone}`, 'success');
                    await loadAutoForecastStatus();
                } else {
                    showToast(data.detail || 'Fehler beim Starten', 'error');
                }
            } catch (err) {
                console.error('Failed to start daily auto-forecast:', err);
                showToast('Fehler beim Starten: ' + err.message, 'error');
            }
        }

        // Stop daily auto-forecast
        async function stopDailyAutoForecast() {
            try {
                const res = await fetch(`${API_BASE}/forecast/auto/daily/stop`, {
                    method: 'POST'
                });
                const data = await res.json();

                if (res.ok) {
                    showToast('T√§gliche Auto-Prognose gestoppt', 'info');
                    await loadAutoForecastStatus();
                } else {
                    showToast(data.detail || 'Fehler beim Stoppen', 'error');
                }
            } catch (err) {
                console.error('Failed to stop daily auto-forecast:', err);
                showToast('Fehler beim Stoppen: ' + err.message, 'error');
            }
        }

        // Run daily forecast immediately
        async function runDailyForecastNow() {
            const btn = event.target;
            btn.disabled = true;
            btn.textContent = '‚è≥ L√§uft...';

            try {
                const res = await fetch(`${API_BASE}/forecast/auto/daily/run-now`, {
                    method: 'POST'
                });
                const data = await res.json();

                if (res.ok) {
                    const result = data.result || {};
                    showToast(
                        `T√§gliche Prognose abgeschlossen: ${result.forecasts_generated || 0} erstellt, ` +
                        `${result.forecasts_failed || 0} fehlgeschlagen, ` +
                        `${result.skipped_no_model || 0} √ºbersprungen`,
                        'success'
                    );
                    await loadAutoForecastStatus();
                } else {
                    showToast(data.detail || 'Fehler bei der Ausf√ºhrung', 'error');
                }
            } catch (err) {
                console.error('Failed to run daily forecast:', err);
                showToast('Fehler bei der Ausf√ºhrung: ' + err.message, 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = '‚ö° Jetzt ausf√ºhren';
            }
        }

        // Load auto-forecast status when switching to forecast tab
        const origSwitchTab = switchTab;
        switchTab = function(tabName) {
            origSwitchTab(tabName);
            if (tabName === 'forecast') {
                loadAutoForecastStatus();
            }
        };

        // Initial load of auto-forecast status after page load
        setTimeout(loadAutoForecastStatus, 1500);

        // Load overview data on page load (overview is the default tab)
        setTimeout(loadOverviewData, 500);
    </script>
</body>
</html>
