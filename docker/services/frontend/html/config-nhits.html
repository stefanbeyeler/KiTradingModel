<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NHITS Service - Konfiguration</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e8e8e8;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1.5rem;
        }

        header {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1rem 0;
            margin-bottom: 1.5rem;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        header .container {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #64c8ff;
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .back-link:hover {
            color: #fff;
        }

        .header-title {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .service-badge {
            background: rgba(76, 175, 80, 0.2);
            color: #81c784;
            padding: 0.3rem 0.8rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .service-badge.offline {
            background: rgba(244, 67, 54, 0.2);
            color: #e57373;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 0.5rem;
        }

        .tab-btn {
            padding: 0.75rem 1.5rem;
            background: transparent;
            border: none;
            color: #a0a0a0;
            font-size: 1rem;
            cursor: pointer;
            border-radius: 8px 8px 0 0;
            transition: all 0.2s;
        }

        .tab-btn:hover {
            background: rgba(255, 255, 255, 0.05);
            color: #e8e8e8;
        }

        .tab-btn.active {
            background: rgba(100, 200, 255, 0.15);
            color: #64c8ff;
            border-bottom: 2px solid #64c8ff;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Card */
        .card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 1.5rem;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .card-title {
            font-size: 1.2rem;
            color: #64c8ff;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Stats Bar */
        .stats-bar {
            display: flex;
            gap: 2rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 600;
            color: #64c8ff;
        }

        .stat-label {
            font-size: 0.8rem;
            opacity: 0.7;
        }

        /* Buttons */
        .btn {
            padding: 0.6rem 1.2rem;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
        }

        .btn-primary {
            background: rgba(100, 200, 255, 0.2);
            color: #64c8ff;
            border: 1px solid rgba(100, 200, 255, 0.3);
        }

        .btn-primary:hover {
            background: rgba(100, 200, 255, 0.3);
        }

        .btn-success {
            background: rgba(76, 175, 80, 0.2);
            color: #81c784;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .btn-success:hover {
            background: rgba(76, 175, 80, 0.3);
        }

        .btn-danger {
            background: rgba(244, 67, 54, 0.2);
            color: #e57373;
            border: 1px solid rgba(244, 67, 54, 0.3);
        }

        .btn-danger:hover {
            background: rgba(244, 67, 54, 0.3);
        }

        .btn-warning {
            background: rgba(255, 152, 0, 0.2);
            color: #ffb74d;
            border: 1px solid rgba(255, 152, 0, 0.3);
        }

        .btn-warning:hover {
            background: rgba(255, 152, 0, 0.3);
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .btn-sm {
            padding: 0.4rem 0.8rem;
            font-size: 0.8rem;
        }

        /* Grid Layout */
        .grid-2 {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 1.5rem;
        }

        @media (max-width: 900px) {
            .grid-2 {
                grid-template-columns: 1fr;
            }
        }

        /* Training Status */
        .training-status {
            font-size: 0.9rem;
        }

        .training-status .training-active {
            color: #4ade80;
            font-weight: 600;
            animation: blink 1s ease-in-out infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .progress-bar {
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            overflow: hidden;
            margin: 0.75rem 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #64c8ff, #a78bfa);
            border-radius: 6px;
            transition: width 0.3s;
        }

        .progress-fill.active {
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .training-info {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-top: 1rem;
        }

        .training-timing {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-top: 1rem;
        }

        .timing-stat {
            text-align: center;
            padding: 0.8rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        .timing-stat .value {
            font-size: 1.2rem;
            font-weight: 600;
            color: #a78bfa;
        }

        .timing-stat .label {
            font-size: 0.75rem;
            opacity: 0.6;
            margin-top: 0.3rem;
        }

        .training-stat {
            text-align: center;
            padding: 0.8rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        .training-stat .value {
            font-size: 1.5rem;
            font-weight: 600;
            color: #64c8ff;
        }

        .training-stat .label {
            font-size: 0.75rem;
            opacity: 0.6;
            margin-top: 0.3rem;
        }

        .timeframe-breakdown {
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Quick Actions */
        .quick-actions {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .quick-actions .btn {
            width: 100%;
            justify-content: center;
            padding: 0.9rem;
        }

        /* Cache Stats */
        .cache-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-top: 1rem;
        }

        .cache-stat {
            background: rgba(0, 0, 0, 0.2);
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
        }

        .cache-stat .value {
            font-size: 1.3rem;
            font-weight: 600;
            color: #64c8ff;
        }

        .cache-stat .label {
            font-size: 0.75rem;
            opacity: 0.6;
            margin-top: 0.3rem;
        }

        /* Models Table */
        .table-container {
            overflow-x: auto;
            max-height: 400px;
            overflow-y: auto;
        }

        /* Dynamic height for models table - uses available viewport height */
        #tab-models .table-container {
            max-height: calc(100vh - 280px);
            min-height: 300px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        th {
            background: rgba(22, 33, 62, 0.98);
            position: sticky;
            top: 0;
            z-index: 10;
            font-weight: 500;
            color: #a0a0a0;
            font-size: 0.85rem;
            text-transform: uppercase;
        }

        /* Legend styling */
        .legend {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            font-size: 0.8rem;
            opacity: 0.8;
        }
        .legend span {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            white-space: nowrap;
        }

        tr:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        /* Badges */
        .badge {
            padding: 0.25rem 0.6rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .badge-m15 { background: rgba(244, 67, 54, 0.2); color: #e57373; }
        .badge-h1 { background: rgba(33, 150, 243, 0.2); color: #64b5f6; }
        .badge-d1 { background: rgba(76, 175, 80, 0.2); color: #81c784; }
        .badge-success { background: rgba(76, 175, 80, 0.2); color: #81c784; }
        .badge-failed { background: rgba(244, 67, 54, 0.2); color: #e57373; }

        /* Toolbar */
        .toolbar {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            align-items: center;
        }

        .search-box {
            flex: 1;
            min-width: 200px;
            padding: 0.6rem 1rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.2);
            color: #e8e8e8;
            font-size: 0.9rem;
        }

        .search-box::placeholder {
            color: #888;
        }

        .filter-select {
            padding: 0.6rem 1rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.2);
            color: #e8e8e8;
            font-size: 0.9rem;
            cursor: pointer;
        }

        .filter-select option {
            background: #1a1a2e;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            padding: 1rem 1.5rem;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 8px;
            border-left: 4px solid #64c8ff;
            display: none;
            z-index: 1000;
        }

        .toast.show {
            display: block;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* Failed Models List */
        .failed-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .failed-item {
            padding: 0.75rem;
            background: rgba(244, 67, 54, 0.1);
            border-radius: 8px;
            margin-bottom: 0.5rem;
            border-left: 3px solid #e57373;
        }

        .failed-item .symbol {
            font-weight: 600;
            color: #e57373;
        }

        .failed-item .error {
            font-size: 0.8rem;
            opacity: 0.8;
            margin-top: 0.3rem;
        }

        /* Forecast Form */
        .forecast-form .form-group {
            margin-bottom: 1rem;
        }

        .forecast-form label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .forecast-form .filter-select {
            width: 100%;
            padding: 0.8rem 1rem;
        }

        /* Forecast Summary */
        .forecast-summary-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }

        .summary-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
        }

        .summary-item .value {
            font-size: 1.3rem;
            font-weight: 600;
            color: #64c8ff;
        }

        .summary-item .value.up {
            color: #4ade80;
        }

        .summary-item .value.down {
            color: #f87171;
        }

        .summary-item .label {
            font-size: 0.75rem;
            opacity: 0.6;
            margin-top: 0.3rem;
        }

        .trend-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            margin-top: 1rem;
        }

        .trend-indicator.bullish {
            border-left: 4px solid #4ade80;
        }

        .trend-indicator.bearish {
            border-left: 4px solid #f87171;
        }

        .trend-indicator .arrow {
            font-size: 1.5rem;
        }

        .trend-indicator .text {
            font-size: 1rem;
            font-weight: 500;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <header>
        <div class="container">
            <a href="/" class="back-link">&#8592; Dashboard</a>
            <span class="header-title">NHITS Service - Konfiguration</span>
            <span class="service-badge" id="service-status">Laden...</span>
        </div>
    </header>

    <div class="container">
        <!-- Tabs -->
        <div class="tabs">
            <button class="tab-btn active" onclick="switchTab('training')">Training</button>
            <button class="tab-btn" onclick="switchTab('models')">Modelle</button>
            <button class="tab-btn" onclick="switchTab('forecast')">Prognose</button>
            <button class="tab-btn" onclick="switchTab('performance')">Performance</button>
            <button class="tab-btn" onclick="switchTab('backup')">Backup / Restore</button>
        </div>

        <!-- Training Tab -->
        <div id="tab-training" class="tab-content active">
            <div class="grid-2">
                <!-- Training Status -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Training Status</h2>
                        <button class="btn btn-sm btn-primary" onclick="refreshStatus()">Aktualisieren</button>
                    </div>
                    <div class="training-status">
                        <div id="training-message" style="font-size: 1.1rem; margin-bottom: 0.5rem;">Kein Training aktiv</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="training-progress" style="width: 0%"></div>
                        </div>
                        <div class="training-info">
                            <div class="training-stat">
                                <div class="value" id="stat-completed">-</div>
                                <div class="label">Abgeschlossen</div>
                            </div>
                            <div class="training-stat">
                                <div class="value" id="stat-successful">-</div>
                                <div class="label">Erfolgreich</div>
                            </div>
                            <div class="training-stat">
                                <div class="value" id="stat-failed">-</div>
                                <div class="label">Fehlgeschlagen</div>
                            </div>
                        </div>
                        <div class="training-timing" id="training-timing" style="display: none;">
                            <div class="timing-stat">
                                <div class="value" id="stat-elapsed">-</div>
                                <div class="label">Vergangen</div>
                            </div>
                            <div class="timing-stat">
                                <div class="value" id="stat-eta">-</div>
                                <div class="label">Verbleibend (ETA)</div>
                            </div>
                        </div>
                        <div class="timeframe-breakdown">
                            <div style="font-size: 0.85rem; opacity: 0.7; margin-bottom: 0.75rem;">Modelle nach Timeframe:</div>
                            <div class="training-info" style="grid-template-columns: repeat(3, 1fr);">
                                <div class="training-stat" title="15-Minuten Modelle">
                                    <div class="value" id="stat-tf-m15">-</div>
                                    <div class="label">M15</div>
                                </div>
                                <div class="training-stat" title="St√ºndliche Modelle">
                                    <div class="value" id="stat-tf-h1">-</div>
                                    <div class="label">H1</div>
                                </div>
                                <div class="training-stat" title="T√§gliche Modelle">
                                    <div class="value" id="stat-tf-d1">-</div>
                                    <div class="label">D1</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Quick Actions -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Schnellaktionen</h2>
                    </div>
                    <div class="quick-actions">
                        <button class="btn btn-success" onclick="startTraining(['M15', 'H1', 'D1'])" id="btn-train-all">
                            Multi-Timeframe Training (M15, H1, D1)
                        </button>
                        <button class="btn btn-primary" onclick="startTraining(['M15'])" id="btn-train-m15">
                            Nur M15 Training
                        </button>
                        <button class="btn btn-primary" onclick="startTraining(['H1'])" id="btn-train-h1">
                            Nur H1 Training
                        </button>
                        <button class="btn btn-primary" onclick="startTraining(['D1'])" id="btn-train-d1">
                            Nur D1 Training
                        </button>
                        <button class="btn btn-danger" onclick="cancelTraining()" id="btn-cancel" disabled>
                            Training abbrechen
                        </button>
                        <button class="btn btn-warning" onclick="retrainFailed()" id="btn-retrain-failed">
                            Fehlgeschlagene erneut trainieren
                        </button>
                    </div>
                </div>
            </div>

            <!-- Failed Training Card -->
            <div class="card" id="failed-card" style="display: none;">
                <div class="card-header">
                    <h2 class="card-title">Fehlgeschlagene Trainings</h2>
                    <span class="badge badge-failed" id="failed-count">0</span>
                </div>
                <div class="failed-list" id="failed-list">
                    <!-- Dynamically populated -->
                </div>
            </div>
        </div>

        <!-- Models Tab -->
        <div id="tab-models" class="tab-content">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Trainierte Modelle</h2>
                    <span id="models-total" style="opacity: 0.7;">- Modelle</span>
                </div>
                <div class="toolbar">
                    <input type="text" class="search-box" id="model-search" placeholder="Symbol suchen..." oninput="filterModels()">
                    <select class="filter-select" id="favorite-filter" onchange="filterModels()">
                        <option value="">Alle Symbole</option>
                        <option value="favorites">&#9733; Nur Favoriten</option>
                        <option value="non-favorites">Ohne Favoriten</option>
                    </select>
                    <select class="filter-select" id="timeframe-filter" onchange="filterModels()">
                        <option value="">Alle Timeframes</option>
                        <option value="M15">M15</option>
                        <option value="H1">H1</option>
                        <option value="D1">D1</option>
                    </select>
                    <button class="btn btn-primary" onclick="loadModels()">Aktualisieren</button>
                    <div class="legend" style="margin-left: auto;">
                        <span title="Trend-Prognose"><span style="color: #4ade80;">‚Üë</span> Steigend <span style="opacity: 0.5;">/</span> <span style="color: #f87171;">‚Üì</span> Fallend</span>
                        <span title="Evaluierungsstatus"><span style="color: #fbbf24;">‚è≥</span> Ausstehend <span style="opacity: 0.5;">/</span> <span style="color: #4ade80;">‚úì</span> Korrekt <span style="opacity: 0.5;">/</span> <span style="color: #f87171;">‚úó</span> Falsch</span>
                        <span title="Favorit"><span style="color: #fbbf24;">‚òÖ</span> Favorit</span>
                    </div>
                </div>
                <div class="table-container">
                    <table id="models-table">
                        <thead>
                            <tr>
                                <th style="width: 40px; text-align: center;" title="Favorit">&#9733;</th>
                                <th>Symbol</th>
                                <th>Timeframe</th>
                                <th>Letzte Prognose</th>
                                <th>Trainiert am</th>
                                <th>Samples</th>
                                <th>Loss</th>
                                <th>Aktionen</th>
                            </tr>
                        </thead>
                        <tbody id="models-tbody">
                            <tr><td colspan="8" style="text-align: center; opacity: 0.5;">Lade Modelle...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Forecast Tab -->
        <div id="tab-forecast" class="tab-content">
            <!-- Batch Forecast Card -->
            <div class="card" style="margin-bottom: 1rem;">
                <div class="card-header">
                    <h2 class="card-title">Batch-Prognosen</h2>
                    <span id="batch-forecast-status" style="opacity: 0.7;"></span>
                </div>
                <div style="display: flex; gap: 1rem; flex-wrap: wrap; align-items: center;">
                    <div class="form-group" style="margin: 0;">
                        <label style="font-size: 0.85rem; opacity: 0.7;">Timeframe</label>
                        <select class="filter-select" id="batch-timeframe" style="min-width: 180px;">
                            <option value="M15">M15 (15 Min)</option>
                            <option value="H1" selected>H1 (1 Stunde)</option>
                            <option value="D1">D1 (T√§glich)</option>
                        </select>
                    </div>
                    <button class="btn btn-success" onclick="runBatchForecast('favorites')" id="btn-forecast-favorites">
                        ‚≠ê Prognose f√ºr Favoriten
                    </button>
                    <button class="btn btn-primary" onclick="runBatchForecast('all')" id="btn-forecast-all">
                        üìä Prognose alle Symbole
                    </button>
                    <button class="btn btn-sm" onclick="cancelBatchForecast()" id="btn-cancel-batch" style="display: none;">
                        ‚ùå Abbrechen
                    </button>
                </div>
                <!-- Batch Progress -->
                <div id="batch-progress-container" style="display: none; margin-top: 1rem;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                        <span id="batch-progress-text">0 / 0 Symbole</span>
                        <span id="batch-progress-percent">0%</span>
                    </div>
                    <div style="background: rgba(0,0,0,0.3); border-radius: 4px; height: 8px; overflow: hidden;">
                        <div id="batch-progress-bar" style="background: linear-gradient(90deg, #4ade80, #22c55e); height: 100%; width: 0%; transition: width 0.3s;"></div>
                    </div>
                    <div id="batch-results-summary" style="margin-top: 0.5rem; font-size: 0.85rem; opacity: 0.8;"></div>
                </div>
            </div>

            <div class="grid-2">
                <!-- Forecast Form -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Einzelne Prognose</h2>
                    </div>
                    <div class="forecast-form">
                        <div class="form-group">
                            <label for="forecast-symbol">Symbol</label>
                            <select class="filter-select" id="forecast-symbol" style="width: 100%;">
                                <option value="">Symbol w√§hlen...</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="forecast-timeframe">Timeframe</label>
                            <select class="filter-select" id="forecast-timeframe" style="width: 100%;">
                                <option value="M15">M15 (15 Min) - 2h Horizont</option>
                                <option value="H1" selected>H1 (1 Stunde) - 24h Horizont</option>
                                <option value="D1">D1 (T√§glich) - 7 Tage Horizont</option>
                            </select>
                        </div>
                        <div class="form-group" style="margin-top: 1rem;">
                            <button class="btn btn-success" onclick="runForecast()" id="btn-forecast" style="width: 100%; padding: 1rem;">
                                Prognose erstellen
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Forecast Summary -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Zusammenfassung</h2>
                    </div>
                    <div id="forecast-summary" style="opacity: 0.5; text-align: center; padding: 2rem;">
                        W√§hle ein Symbol und starte die Prognose
                    </div>
                </div>
            </div>

            <!-- Forecast Results -->
            <div class="card" id="forecast-results-card" style="display: none;">
                <div class="card-header">
                    <h2 class="card-title">Prognoseergebnisse</h2>
                    <span id="forecast-info" style="opacity: 0.7;"></span>
                </div>

                <!-- Chart Container -->
                <div id="forecast-chart" style="height: 300px; margin-bottom: 1.5rem; position: relative;">
                    <canvas id="forecastCanvas"></canvas>
                </div>

                <!-- Forecast Table -->
                <div class="table-container" style="max-height: 300px;">
                    <table>
                        <thead>
                            <tr>
                                <th>Zeitpunkt</th>
                                <th>Prognose</th>
                                <th>Konfidenz (Tief)</th>
                                <th>Konfidenz (Hoch)</th>
                                <th>Spanne</th>
                            </tr>
                        </thead>
                        <tbody id="forecast-tbody">
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Performance Tab -->
        <div id="tab-performance" class="tab-content">
            <!-- Auto-Evaluation Status Card -->
            <div class="card" style="margin-bottom: 1rem;">
                <div class="card-header">
                    <h2 class="card-title">Auto-Evaluierung & Retrain</h2>
                    <button class="btn btn-sm btn-primary" onclick="loadAutoStatus()">Aktualisieren</button>
                </div>
                <div id="auto-status-content">
                    <div class="grid-2" style="margin-bottom: 1rem;">
                        <!-- Auto-Evaluation Status -->
                        <div style="padding: 1rem; background: rgba(0,0,0,0.2); border-radius: 8px;">
                            <h4 style="margin: 0 0 0.5rem 0; opacity: 0.8;">Auto-Evaluierung</h4>
                            <div id="auto-eval-status">
                                <div style="opacity: 0.5;">Lade Status...</div>
                            </div>
                        </div>
                        <!-- Auto-Retrain Status -->
                        <div style="padding: 1rem; background: rgba(0,0,0,0.2); border-radius: 8px;">
                            <h4 style="margin: 0 0 0.5rem 0; opacity: 0.8;">Auto-Retrain</h4>
                            <div id="auto-retrain-status">
                                <div style="opacity: 0.5;">Lade Status...</div>
                            </div>
                        </div>
                    </div>
                    <!-- Prediction Stats -->
                    <div class="stats-bar" id="prediction-stats" style="margin-bottom: 1rem;">
                        <div class="stat-item">
                            <div class="stat-value" id="stat-pending">-</div>
                            <div class="stat-label">Ausstehend</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="stat-ready">-</div>
                            <div class="stat-label">Bereit zur Eval.</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="stat-waiting">-</div>
                            <div class="stat-label">Warten auf Horizont</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="stat-evaluated">-</div>
                            <div class="stat-label">Evaluiert</div>
                        </div>
                    </div>
                    <!-- Control Buttons -->
                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                        <button class="btn btn-sm" id="btn-toggle-auto-eval" onclick="toggleAutoEvaluation()">
                            ‚è∏Ô∏è Auto-Eval pausieren
                        </button>
                        <button class="btn btn-sm" id="btn-toggle-auto-retrain" onclick="toggleAutoRetrain()">
                            ‚è∏Ô∏è Auto-Retrain pausieren
                        </button>
                        <button class="btn btn-sm btn-success" id="btn-manual-eval" onclick="runManualEvaluation()">
                            üìä Jetzt evaluieren
                        </button>
                        <button class="btn btn-sm btn-warning" id="btn-manual-retrain" onclick="runManualRetrain()">
                            üîÑ Schlechte Modelle retrainieren
                        </button>
                    </div>
                </div>
            </div>

            <!-- Performance Table Card -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Modell Performance</h2>
                    <button class="btn btn-sm btn-primary" onclick="loadPerformance()">Aktualisieren</button>
                </div>
                <p style="opacity: 0.7; margin-bottom: 1rem;">
                    √úbersicht der Prognosegenauigkeit basierend auf historischen Evaluierungen.
                    Performance-Daten werden gesammelt, wenn Prognosen mit tats√§chlichen Preisen verglichen werden.
                </p>
                <!-- Evaluation Status -->
                <div id="evaluation-status" style="display: none; margin-bottom: 1rem; padding: 0.75rem; background: rgba(100, 200, 255, 0.1); border-radius: 8px; border: 1px solid rgba(100, 200, 255, 0.2);">
                    <span id="evaluation-message">Evaluierung l√§uft...</span>
                </div>
                <div class="table-container">
                    <table id="performance-table">
                        <thead>
                            <tr>
                                <th>Symbol</th>
                                <th>Evaluiert</th>
                                <th>√ò Fehler</th>
                                <th>Richtung</th>
                                <th>Letzte Eval.</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody id="performance-tbody">
                            <tr><td colspan="6" style="text-align: center; opacity: 0.5;">Lade Performance-Daten...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Backup Tab -->
        <div id="tab-backup" class="tab-content">
            <div class="grid-2">
                <!-- Status Card -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Backup Status</h2>
                        <button class="btn btn-sm btn-primary" onclick="loadBackupStatus()">Aktualisieren</button>
                    </div>
                    <div id="backup-status-content">
                        <div style="opacity: 0.5; text-align: center; padding: 2rem;">Lade Status...</div>
                    </div>
                </div>

                <!-- Quick Actions -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Schnellaktionen</h2>
                    </div>
                    <div class="quick-actions">
                        <button class="btn btn-success" onclick="backupModels()" id="btn-backup-models">
                            üíæ Modelle sichern (ZIP)
                        </button>
                        <button class="btn btn-success" onclick="backupPredictions()" id="btn-backup-predictions">
                            üíæ Prognosen sichern (JSON)
                        </button>
                        <div style="border-top: 1px solid rgba(255,255,255,0.1); margin: 1rem 0;"></div>
                        <button class="btn btn-primary" onclick="document.getElementById('restore-models-file').click()">
                            üì• Modelle wiederherstellen
                        </button>
                        <input type="file" id="restore-models-file" accept=".zip" style="display: none;" onchange="restoreModels(this)">
                        <button class="btn btn-primary" onclick="document.getElementById('restore-predictions-file').click()">
                            üì• Prognosen wiederherstellen
                        </button>
                        <input type="file" id="restore-predictions-file" accept=".json" style="display: none;" onchange="restorePredictions(this)">
                        <div style="border-top: 1px solid rgba(255,255,255,0.1); margin: 1rem 0;"></div>
                        <button class="btn btn-danger" onclick="clearPredictions()" id="btn-clear-predictions">
                            üóëÔ∏è Prognose-Daten l√∂schen
                        </button>
                    </div>
                </div>
            </div>

            <!-- Backup Result -->
            <div class="card" id="backup-result-card" style="display: none;">
                <div class="card-header">
                    <h2 class="card-title" id="backup-result-title">Backup Ergebnis</h2>
                    <button class="btn btn-sm btn-success" id="backup-download-btn" onclick="downloadBackup()" style="display: none;">
                        ‚¨áÔ∏è Herunterladen
                    </button>
                </div>
                <div id="backup-result-content">
                </div>
            </div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <script>
        const API_BASE = '/nhits/api/v1';
        let allModels = [];
        let latestForecasts = {};  // Cache for latest forecasts per model
        let trainingInterval = null;

        // Tab switching
        function switchTab(tabName) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

            event.target.classList.add('active');
            document.getElementById(`tab-${tabName}`).classList.add('active');

            // Load data for the selected tab
            if (tabName === 'models') loadModels();
            if (tabName === 'performance') {
                loadPerformance();
                loadAutoStatus();
            }
            if (tabName === 'forecast') loadForecastSymbols();
            if (tabName === 'backup') loadBackupStatus();
        }

        // Check service health
        async function checkHealth() {
            try {
                const res = await fetch(`${API_BASE.replace('/api/v1', '')}/health`);
                const data = await res.json();
                const badge = document.getElementById('service-status');
                if (data.status === 'healthy') {
                    badge.textContent = 'Online';
                    badge.classList.remove('offline');
                } else {
                    badge.textContent = 'Degraded';
                    badge.classList.add('offline');
                }
            } catch (err) {
                const badge = document.getElementById('service-status');
                badge.textContent = 'Offline';
                badge.classList.add('offline');
            }
        }

        // Training status
        async function updateTrainingStatus() {
            try {
                const res = await fetch(`${API_BASE}/forecast/training/progress`);
                const data = await res.json();

                const msgEl = document.getElementById('training-message');
                const progressEl = document.getElementById('training-progress');
                const timingEl = document.getElementById('training-timing');
                const btnCancel = document.getElementById('btn-cancel');
                const trainButtons = ['btn-train-all', 'btn-train-h1', 'btn-train-m15', 'btn-train-d1'];

                if (data.training_in_progress) {
                    msgEl.textContent = `Training: ${data.current_symbol || '-'} (${data.completed_symbols}/${data.total_symbols})`;
                    msgEl.classList.add('training-active');
                    progressEl.style.width = `${Math.max(data.progress_percent, 5)}%`;
                    progressEl.classList.add('active');
                    btnCancel.disabled = false;
                    trainButtons.forEach(id => document.getElementById(id).disabled = true);

                    document.getElementById('stat-completed').textContent = data.completed_symbols || 0;
                    document.getElementById('stat-successful').textContent = data.results?.successful || 0;
                    document.getElementById('stat-failed').textContent = data.results?.failed || 0;

                    if (data.timing) {
                        timingEl.style.display = 'grid';
                        document.getElementById('stat-elapsed').textContent = data.timing.elapsed_formatted || '-';
                        document.getElementById('stat-eta').textContent = data.timing.eta_formatted || '-';
                    }

                    // Start polling if not already
                    if (!trainingInterval) {
                        trainingInterval = setInterval(updateTrainingStatus, 2000);
                    }
                } else {
                    msgEl.textContent = data.message || 'Kein Training aktiv';
                    msgEl.classList.remove('training-active');
                    progressEl.style.width = '0%';
                    progressEl.classList.remove('active');
                    btnCancel.disabled = true;
                    trainButtons.forEach(id => document.getElementById(id).disabled = false);
                    timingEl.style.display = 'none';

                    // Stop polling
                    if (trainingInterval) {
                        clearInterval(trainingInterval);
                        trainingInterval = null;
                    }
                }

                // Load failed trainings
                await loadFailedTrainings();

            } catch (err) {
                console.error('Training status error:', err);
            }
        }

        // Load model counts by timeframe
        async function loadModelCounts() {
            try {
                const res = await fetch(`${API_BASE}/forecast/models/by-timeframe`);
                const data = await res.json();

                document.getElementById('stat-tf-m15').textContent = data.by_timeframe?.M15?.count || 0;
                document.getElementById('stat-tf-h1').textContent = data.by_timeframe?.H1?.count || 0;
                document.getElementById('stat-tf-d1').textContent = data.by_timeframe?.D1?.count || 0;
            } catch (err) {
                console.error('Failed to load model counts:', err);
            }
        }

        // Load failed trainings
        async function loadFailedTrainings() {
            try {
                const res = await fetch(`${API_BASE}/forecast/training/failed`);
                const data = await res.json();

                const failedCard = document.getElementById('failed-card');
                const failedList = document.getElementById('failed-list');
                const failedCount = document.getElementById('failed-count');

                if (data.count > 0) {
                    failedCard.style.display = 'block';
                    failedCount.textContent = data.count;

                    let html = '';
                    for (const [key, info] of Object.entries(data.models)) {
                        html += `
                            <div class="failed-item">
                                <div class="symbol">${info.symbol} (${info.timeframe})</div>
                                <div class="error">${info.error}</div>
                            </div>
                        `;
                    }
                    failedList.innerHTML = html;
                } else {
                    failedCard.style.display = 'none';
                }
            } catch (err) {
                console.error('Failed to load failed trainings:', err);
            }
        }

        // Start training
        async function startTraining(timeframes) {
            try {
                let url = `${API_BASE}/forecast/train-all?force=false&background=true`;
                timeframes.forEach(tf => url += `&timeframes=${tf}`);

                showToast(`Training wird gestartet (${timeframes.join(', ')})...`);
                const res = await fetch(url, { method: 'POST' });
                const data = await res.json();

                showToast(data.message || 'Training gestartet');
                setTimeout(updateTrainingStatus, 1000);
            } catch (err) {
                showToast('Fehler beim Starten des Trainings');
            }
        }

        // Cancel training
        async function cancelTraining() {
            try {
                const res = await fetch(`${API_BASE}/forecast/training/cancel`, { method: 'POST' });
                const data = await res.json();
                showToast(data.message || 'Training wird abgebrochen...');
                setTimeout(updateTrainingStatus, 1000);
            } catch (err) {
                showToast('Fehler beim Abbrechen');
            }
        }

        // Retrain failed
        async function retrainFailed() {
            try {
                const res = await fetch(`${API_BASE}/forecast/retrain-poor-performers`, { method: 'POST' });
                const data = await res.json();
                showToast(data.message || 'Retraining gestartet');
                setTimeout(updateTrainingStatus, 1000);
            } catch (err) {
                showToast('Fehler beim Starten des Retrainings');
            }
        }

        // Load models with full details
        async function loadModels() {
            try {
                // Fetch models and latest forecasts in parallel
                const [modelsRes, forecastsRes] = await Promise.all([
                    fetch(`${API_BASE}/forecast/models`),
                    fetch(`${API_BASE}/forecast/latest-per-model`)
                ]);

                const data = await modelsRes.json();
                const forecastsData = await forecastsRes.json();

                // Store forecasts in cache
                latestForecasts = forecastsData.forecasts || {};

                // Count favorites
                const favoriteCount = data.filter(m => m.is_favorite && m.model_exists).length;
                document.getElementById('models-total').textContent = `${data.length} Modelle (${favoriteCount} Favoriten)`;

                allModels = [];
                for (const model of data) {
                    if (!model.model_exists) continue;

                    // Parse timeframe from symbol (e.g., BTCUSD_H1 -> H1, BTCUSD -> default)
                    let baseSymbol = model.symbol;
                    let timeframeKey = 'default';
                    let timeframeLabel = 'H1 (Std)';

                    if (model.symbol.endsWith('_M15')) {
                        baseSymbol = model.symbol.replace('_M15', '');
                        timeframeKey = 'M15';
                        timeframeLabel = 'M15';
                    } else if (model.symbol.endsWith('_H1')) {
                        baseSymbol = model.symbol.replace('_H1', '');
                        timeframeKey = 'H1';
                        timeframeLabel = 'H1';
                    } else if (model.symbol.endsWith('_D1')) {
                        baseSymbol = model.symbol.replace('_D1', '');
                        timeframeKey = 'D1';
                        timeframeLabel = 'D1';
                    }

                    allModels.push({
                        symbol: baseSymbol,
                        fullSymbol: model.symbol,
                        timeframe: timeframeLabel,
                        timeframeKey: timeframeKey,
                        lastTrained: model.last_trained,
                        samples: model.training_samples,
                        loss: model.metrics?.final_loss,
                        isFavorite: model.is_favorite || false,
                        category: model.category || ''
                    });
                }

                filterModels();
            } catch (err) {
                console.error('Failed to load models:', err);
            }
        }

        // Filter models
        function filterModels() {
            const search = document.getElementById('model-search').value.toLowerCase();
            const tfFilter = document.getElementById('timeframe-filter').value;
            const favFilter = document.getElementById('favorite-filter')?.value || '';

            const filtered = allModels.filter(m => {
                const matchSearch = m.symbol.toLowerCase().includes(search);
                const matchTf = !tfFilter || m.timeframeKey === tfFilter;
                const matchFav = !favFilter || (favFilter === 'favorites' && m.isFavorite) || (favFilter === 'non-favorites' && !m.isFavorite);
                return matchSearch && matchTf && matchFav;
            });

            // Sort by 1. Favorites first, 2. Symbol, 3. Timeframe (M15, H1, D1)
            const timeframeOrder = { 'M15': 1, 'H1': 2, 'D1': 3, 'default': 2 };
            filtered.sort((a, b) => {
                // Favorites first
                if (a.isFavorite !== b.isFavorite) return b.isFavorite - a.isFavorite;
                // Then sort by symbol alphabetically
                const symbolCompare = a.symbol.localeCompare(b.symbol);
                if (symbolCompare !== 0) return symbolCompare;
                // Then sort by timeframe order
                return (timeframeOrder[a.timeframeKey] || 99) - (timeframeOrder[b.timeframeKey] || 99);
            });

            const tbody = document.getElementById('models-tbody');
            if (filtered.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; opacity: 0.5;">Keine Modelle gefunden</td></tr>';
                return;
            }

            let html = '';
            for (const model of filtered) {
                const tfClass = model.timeframeKey === 'M15' ? 'badge-m15' :
                               model.timeframeKey === 'D1' ? 'badge-d1' : 'badge-h1';

                // Format trained date
                let trainedDate = '-';
                if (model.lastTrained) {
                    const d = new Date(model.lastTrained);
                    trainedDate = d.toLocaleDateString('de-DE') + ' ' + d.toLocaleTimeString('de-DE', {hour: '2-digit', minute: '2-digit'});
                }

                // Get latest forecast for this model
                // Try full symbol first (e.g., "BTCUSD_H1"), then base symbol (e.g., "BTCUSD")
                let forecastInfo = '-';
                let forecast = latestForecasts[model.fullSymbol] || latestForecasts[model.symbol];
                if (forecast) {
                    const fcDate = new Date(forecast.timestamp);
                    const dateStr = fcDate.toLocaleDateString('de-DE') + ' ' + fcDate.toLocaleTimeString('de-DE', {hour: '2-digit', minute: '2-digit'});
                    const trendIcon = forecast.trend === 'up' ? '‚Üë' : (forecast.trend === 'down' ? '‚Üì' : '-');
                    const trendColor = forecast.trend === 'up' ? '#4ade80' : (forecast.trend === 'down' ? '#f87171' : 'inherit');
                    const evalIcon = forecast.evaluated ? (forecast.direction_correct ? '‚úì' : '‚úó') : '‚è≥';
                    const evalColor = forecast.evaluated ? (forecast.direction_correct ? '#4ade80' : '#f87171') : '#fbbf24';
                    forecastInfo = `<span style="color: ${trendColor}; font-weight: 600;">${trendIcon}</span> ${dateStr} <span style="color: ${evalColor}; font-size: 0.85em;" title="${forecast.evaluated ? (forecast.direction_correct ? 'Korrekt' : 'Falsch') : 'Ausstehend'}">${evalIcon}</span>`;
                }

                // Format loss
                const lossStr = model.loss ? model.loss.toFixed(4) : '-';

                // Favorite indicator
                const favIcon = model.isFavorite ? '<span title="Favorit" style="color: #fbbf24;">&#9733;</span>' : '<span style="opacity: 0.3;">&#9734;</span>';
                const rowStyle = model.isFavorite ? 'background: rgba(251, 191, 36, 0.05);' : '';

                html += `
                    <tr style="${rowStyle}">
                        <td>${favIcon}</td>
                        <td><strong>${model.symbol}</strong></td>
                        <td><span class="badge ${tfClass}">${model.timeframe}</span></td>
                        <td>${forecastInfo}</td>
                        <td>${trainedDate}</td>
                        <td>${model.samples || '-'}</td>
                        <td>${lossStr}</td>
                        <td>
                            <button class="btn btn-sm btn-primary" onclick="trainSingle('${model.symbol}', '${model.timeframeKey}')">Train</button>
                        </td>
                    </tr>
                `;
            }
            tbody.innerHTML = html;
        }

        // Train single model
        async function trainSingle(symbol, timeframe) {
            try {
                const tf = timeframe === 'default' ? 'H1' : timeframe;
                showToast(`Training ${symbol}/${tf} gestartet... (kann bis zu 60s dauern)`, 60000);

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 120000); // 2 min timeout

                const res = await fetch(`${API_BASE}/forecast/${symbol}/train?timeframe=${tf}&force=true`, {
                    method: 'POST',
                    signal: controller.signal
                });
                clearTimeout(timeoutId);

                const data = await res.json();

                if (data.success) {
                    const duration = data.training_duration_seconds ? ` (${Math.round(data.training_duration_seconds)}s)` : '';
                    showToast(`‚úì ${symbol}/${tf} erfolgreich trainiert${duration}`);
                    loadModels(); // Refresh models list
                } else {
                    showToast(`‚úó Fehler: ${data.error_message || 'Unbekannt'}`);
                }
            } catch (err) {
                if (err.name === 'AbortError') {
                    showToast('Training Timeout - bitte Status pr√ºfen');
                } else {
                    showToast(`Fehler beim Training: ${err.message}`);
                }
            }
        }

        // Load performance
        async function loadPerformance() {
            try {
                // Fetch both performance summary and evaluated predictions
                const [perfRes, evalRes] = await Promise.all([
                    fetch(`${API_BASE}/forecast/performance`),
                    fetch(`${API_BASE}/forecast/evaluated`)
                ]);
                const perfData = await perfRes.json();
                const evalData = await evalRes.json();

                const tbody = document.getElementById('performance-tbody');

                // Check if there are any evaluated predictions
                if ((!evalData.predictions || evalData.predictions.length === 0) &&
                    Object.keys(perfData.by_symbol || {}).length === 0) {
                    tbody.innerHTML = `
                        <tr><td colspan="6" style="text-align: center; padding: 2rem;">
                            <div style="opacity: 0.7; margin-bottom: 1rem;">Keine Evaluierungen vorhanden</div>
                            <div style="font-size: 0.85rem; opacity: 0.5;">
                                Performance-Daten werden automatisch gesammelt, wenn Prognosen erstellt<br>
                                und sp√§ter mit den tats√§chlichen Preisen verglichen werden.
                            </div>
                        </td></tr>
                    `;
                    return;
                }

                let html = '';

                // Show symbol-level performance summary
                for (const [symbol, metrics] of Object.entries(perfData.by_symbol || {})) {
                    const avgError = metrics.avg_error_pct || 0;
                    const dirAccuracy = (metrics.direction_accuracy || 0) * 100;
                    const statusClass = avgError < 0.5 && dirAccuracy > 50 ? 'badge-success' : 'badge-failed';
                    const statusText = metrics.needs_retraining ? 'Retraining n√∂tig' : 'OK';

                    // Format evaluated date from most recent prediction
                    let evaluatedAt = '-';
                    const symbolPreds = (evalData.predictions || []).filter(p => p.symbol === symbol);
                    if (symbolPreds.length > 0 && symbolPreds[0].evaluated_at) {
                        const d = new Date(symbolPreds[0].evaluated_at);
                        evaluatedAt = d.toLocaleDateString('de-DE') + ' ' + d.toLocaleTimeString('de-DE', {hour: '2-digit', minute: '2-digit'});
                    }

                    html += `
                        <tr>
                            <td><strong>${symbol}</strong></td>
                            <td>${metrics.evaluated}/${metrics.total}</td>
                            <td>${avgError.toFixed(4)}%</td>
                            <td>${dirAccuracy.toFixed(1)}%</td>
                            <td>${evaluatedAt}</td>
                            <td><span class="badge ${statusClass}">${statusText}</span></td>
                        </tr>
                    `;
                }

                // If no symbol metrics but have individual predictions, show those
                if (html === '' && evalData.predictions && evalData.predictions.length > 0) {
                    for (const pred of evalData.predictions.slice(0, 50)) {
                        const errorPct = pred.prediction_error_pct || 0;
                        const statusClass = pred.direction_correct ? 'badge-success' : 'badge-failed';
                        const statusText = pred.direction_correct ? 'Richtig' : 'Falsch';

                        let evaluatedAt = '-';
                        if (pred.evaluated_at) {
                            const d = new Date(pred.evaluated_at);
                            evaluatedAt = d.toLocaleDateString('de-DE') + ' ' + d.toLocaleTimeString('de-DE', {hour: '2-digit', minute: '2-digit'});
                        }

                        html += `
                            <tr>
                                <td><strong>${pred.symbol}</strong></td>
                                <td>${pred.horizon || 'H1'}</td>
                                <td>${errorPct.toFixed(4)}%</td>
                                <td>${pred.direction_correct ? '‚úì' : '‚úó'}</td>
                                <td>${evaluatedAt}</td>
                                <td><span class="badge ${statusClass}">${statusText}</span></td>
                            </tr>
                        `;
                    }
                }

                tbody.innerHTML = html || '<tr><td colspan="6" style="text-align: center; opacity: 0.5;">Keine Daten</td></tr>';
            } catch (err) {
                console.error('Failed to load performance:', err);
                document.getElementById('performance-tbody').innerHTML =
                    '<tr><td colspan="6" style="text-align: center; opacity: 0.5;">Fehler beim Laden</td></tr>';
            }
        }

        // ========== AUTO-EVALUATION FUNCTIONS ==========

        let autoEvalEnabled = true;
        let autoRetrainEnabled = true;

        // Load auto-evaluation status
        async function loadAutoStatus() {
            try {
                const res = await fetch(`${API_BASE}/forecast/auto-status`);
                const data = await res.json();

                // Update auto-eval status
                const autoEvalDiv = document.getElementById('auto-eval-status');
                const evalStatus = data.auto_evaluation;
                autoEvalEnabled = evalStatus.enabled;

                const runningBadge = evalStatus.running ?
                    '<span class="badge badge-success">Aktiv</span>' :
                    '<span class="badge badge-failed">Inaktiv</span>';
                const enabledBadge = evalStatus.enabled ?
                    '<span style="color: #4ade80;">Aktiviert</span>' :
                    '<span style="color: #f87171;">Pausiert</span>';

                let lastRunText = 'Noch nie';
                if (evalStatus.last_run) {
                    const d = new Date(evalStatus.last_run);
                    lastRunText = d.toLocaleTimeString('de-DE', {hour: '2-digit', minute: '2-digit'});
                }

                autoEvalDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                        ${runningBadge} ${enabledBadge}
                    </div>
                    <div style="font-size: 0.85rem; opacity: 0.8;">
                        <div>Intervall: ${evalStatus.interval_seconds}s</div>
                        <div>Letzte Ausf√ºhrung: ${lastRunText}</div>
                        <div>Gesamt evaluiert: ${evalStatus.total_evaluations}</div>
                    </div>
                `;

                // Update toggle button
                const toggleEvalBtn = document.getElementById('btn-toggle-auto-eval');
                if (autoEvalEnabled) {
                    toggleEvalBtn.innerHTML = '‚è∏Ô∏è Auto-Eval pausieren';
                    toggleEvalBtn.classList.remove('btn-success');
                } else {
                    toggleEvalBtn.innerHTML = '‚ñ∂Ô∏è Auto-Eval starten';
                    toggleEvalBtn.classList.add('btn-success');
                }

                // Update auto-retrain status
                const autoRetrainDiv = document.getElementById('auto-retrain-status');
                const retrainStatus = data.auto_retrain;
                autoRetrainEnabled = retrainStatus.enabled;

                const retrainEnabledBadge = retrainStatus.enabled ?
                    '<span style="color: #4ade80;">Aktiviert</span>' :
                    '<span style="color: #f87171;">Pausiert</span>';
                const retrainInProgress = retrainStatus.in_progress ?
                    '<span class="badge badge-warning">Training l√§uft...</span>' : '';

                let lastRetrainText = 'Noch nie';
                if (retrainStatus.last_run) {
                    const d = new Date(retrainStatus.last_run);
                    lastRetrainText = d.toLocaleTimeString('de-DE', {hour: '2-digit', minute: '2-digit'});
                }

                autoRetrainDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                        ${retrainEnabledBadge} ${retrainInProgress}
                    </div>
                    <div style="font-size: 0.85rem; opacity: 0.8;">
                        <div>Cooldown: ${retrainStatus.cooldown_hours}h</div>
                        <div>Letztes Retrain: ${lastRetrainText}</div>
                        <div>Gesamt retrained: ${retrainStatus.total_retrains}</div>
                    </div>
                `;

                // Show symbols needing retrain
                if (data.symbols_needing_retrain && data.symbols_needing_retrain.length > 0) {
                    autoRetrainDiv.innerHTML += `
                        <div style="margin-top: 0.5rem; padding: 0.5rem; background: rgba(255,193,7,0.1); border-radius: 4px; font-size: 0.8rem;">
                            <strong>Retrain ben√∂tigt:</strong> ${data.symbols_needing_retrain.join(', ')}
                        </div>
                    `;
                }

                // Update toggle button
                const toggleRetrainBtn = document.getElementById('btn-toggle-auto-retrain');
                if (autoRetrainEnabled) {
                    toggleRetrainBtn.innerHTML = '‚è∏Ô∏è Auto-Retrain pausieren';
                    toggleRetrainBtn.classList.remove('btn-success');
                } else {
                    toggleRetrainBtn.innerHTML = '‚ñ∂Ô∏è Auto-Retrain starten';
                    toggleRetrainBtn.classList.add('btn-success');
                }

                // Update prediction stats
                const predictions = data.predictions;
                document.getElementById('stat-pending').textContent = predictions.pending_count;
                document.getElementById('stat-ready').textContent = predictions.ready_for_evaluation;
                document.getElementById('stat-waiting').textContent = predictions.waiting_for_horizon;
                document.getElementById('stat-evaluated').textContent = predictions.evaluated_count;

            } catch (err) {
                console.error('Failed to load auto status:', err);
                document.getElementById('auto-eval-status').innerHTML = '<div style="color: #f87171;">Fehler beim Laden</div>';
                document.getElementById('auto-retrain-status').innerHTML = '<div style="color: #f87171;">Fehler beim Laden</div>';
            }
        }

        // Toggle auto-evaluation
        async function toggleAutoEvaluation() {
            const newState = !autoEvalEnabled;
            try {
                const res = await fetch(`${API_BASE}/forecast/auto-evaluation/toggle?enabled=${newState}`, {
                    method: 'POST'
                });
                const data = await res.json();
                if (data.success) {
                    showToast(data.message);
                    await loadAutoStatus();
                }
            } catch (err) {
                console.error('Failed to toggle auto-evaluation:', err);
                showToast('Fehler: ' + err.message);
            }
        }

        // Toggle auto-retrain
        async function toggleAutoRetrain() {
            const newState = !autoRetrainEnabled;
            try {
                const res = await fetch(`${API_BASE}/forecast/auto-retrain/toggle?enabled=${newState}`, {
                    method: 'POST'
                });
                const data = await res.json();
                if (data.success) {
                    showToast(data.message);
                    await loadAutoStatus();
                }
            } catch (err) {
                console.error('Failed to toggle auto-retrain:', err);
                showToast('Fehler: ' + err.message);
            }
        }

        // Manual retrain for poor performers
        async function runManualRetrain() {
            const btn = document.getElementById('btn-manual-retrain');
            btn.disabled = true;
            btn.textContent = '‚è≥ Retrain l√§uft...';

            try {
                const res = await fetch(`${API_BASE}/forecast/retrain-poor-performers`, {
                    method: 'POST'
                });
                const data = await res.json();

                if (data.success) {
                    if (data.symbols && data.symbols.length > 0) {
                        showToast(`Retrain gestartet f√ºr: ${data.symbols.join(', ')}`);
                    } else {
                        showToast(data.message || 'Keine Modelle ben√∂tigen Retraining');
                    }
                } else {
                    showToast('Fehler: ' + (data.detail || 'Unbekannter Fehler'));
                }
            } catch (err) {
                console.error('Manual retrain failed:', err);
                showToast('Fehler: ' + err.message);
            } finally {
                btn.disabled = false;
                btn.textContent = 'üîÑ Schlechte Modelle retrainieren';
                await loadAutoStatus();
            }
        }

        // Manual evaluation (updated)
        async function runManualEvaluation() {
            const btn = document.getElementById('btn-manual-eval');
            const statusDiv = document.getElementById('evaluation-status');
            const statusMsg = document.getElementById('evaluation-message');

            // Disable button and show loading state
            btn.disabled = true;
            btn.textContent = '‚è≥ Evaluierung...';
            statusDiv.style.display = 'block';
            statusMsg.textContent = 'Evaluierung l√§uft... Prognosen werden mit tats√§chlichen Preisen verglichen.';
            statusDiv.style.background = 'rgba(100, 200, 255, 0.1)';
            statusDiv.style.borderColor = 'rgba(100, 200, 255, 0.2)';

            try {
                const res = await fetch(`${API_BASE}/forecast/evaluate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                const data = await res.json();

                if (res.ok && data.success) {
                    // Success
                    btn.textContent = '‚úì Fertig';
                    statusDiv.style.background = 'rgba(76, 175, 80, 0.1)';
                    statusDiv.style.borderColor = 'rgba(76, 175, 80, 0.2)';

                    if (data.evaluated_count > 0) {
                        statusMsg.innerHTML = `<strong>${data.evaluated_count} Prognosen evaluiert!</strong><br>
                            <span style="font-size: 0.85rem; opacity: 0.8;">
                                Ausstehend vorher: ${data.pending_before} ‚Üí nachher: ${data.pending_after}
                            </span>`;

                        // Show per-symbol breakdown if available
                        if (data.by_symbol && Object.keys(data.by_symbol).length > 0) {
                            const symbolList = Object.entries(data.by_symbol)
                                .map(([sym, count]) => `${sym}: ${count}`)
                                .join(', ');
                            statusMsg.innerHTML += `<br><span style="font-size: 0.8rem; opacity: 0.7;">${symbolList}</span>`;
                        }
                    } else {
                        statusMsg.innerHTML = `<strong>Keine Prognosen bereit zur Evaluierung.</strong><br>
                            <span style="font-size: 0.85rem; opacity: 0.8;">
                                ${data.pending_before} Prognosen warten noch auf Ablauf ihres Zeithorizonts.
                            </span>`;
                    }

                    // Reload performance data and auto status
                    await loadPerformance();
                    await loadAutoStatus();
                    showToast(data.message);
                } else {
                    // Error response
                    btn.textContent = '‚úó Fehler';
                    statusDiv.style.background = 'rgba(244, 67, 54, 0.1)';
                    statusDiv.style.borderColor = 'rgba(244, 67, 54, 0.2)';
                    statusMsg.textContent = `Fehler: ${data.detail || 'Unbekannter Fehler'}`;
                }
            } catch (err) {
                console.error('Evaluation failed:', err);
                btn.textContent = '‚úó Fehler';
                statusDiv.style.background = 'rgba(244, 67, 54, 0.1)';
                statusDiv.style.borderColor = 'rgba(244, 67, 54, 0.2)';
                statusMsg.textContent = `Fehler: ${err.message}`;
            } finally {
                // Re-enable button after short delay
                setTimeout(() => {
                    btn.disabled = false;
                    btn.textContent = 'üìä Jetzt evaluieren';
                }, 2000);

                // Hide status after 10 seconds
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 10000);
            }
        }

        // Refresh all status
        async function refreshStatus() {
            await Promise.all([
                checkHealth(),
                updateTrainingStatus(),
                loadModelCounts()
            ]);
        }

        // Toast notification
        let toastTimeout = null;
        function showToast(message, duration = 3000) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            if (toastTimeout) clearTimeout(toastTimeout);
            toastTimeout = setTimeout(() => toast.classList.remove('show'), duration);
        }

        // Initial load
        refreshStatus();

        // Auto-refresh every 10 seconds
        setInterval(refreshStatus, 10000);

        // ========== FORECAST TAB ==========
        let forecastChart = null;

        // Load available symbols for forecast
        async function loadForecastSymbols() {
            try {
                const res = await fetch(`${API_BASE}/forecast/models`);
                const data = await res.json();

                const select = document.getElementById('forecast-symbol');
                const symbols = new Set();

                // Extract unique base symbols
                for (const model of data) {
                    if (!model.model_exists) continue;
                    let baseSymbol = model.symbol;
                    if (baseSymbol.endsWith('_M15')) baseSymbol = baseSymbol.replace('_M15', '');
                    else if (baseSymbol.endsWith('_H1')) baseSymbol = baseSymbol.replace('_H1', '');
                    else if (baseSymbol.endsWith('_D1')) baseSymbol = baseSymbol.replace('_D1', '');
                    symbols.add(baseSymbol);
                }

                // Sort and populate dropdown
                const sortedSymbols = Array.from(symbols).sort();
                select.innerHTML = '<option value="">Symbol w√§hlen...</option>';
                for (const sym of sortedSymbols) {
                    select.innerHTML += `<option value="${sym}">${sym}</option>`;
                }
            } catch (err) {
                console.error('Failed to load forecast symbols:', err);
            }
        }

        // ========== BATCH FORECAST FUNCTIONS ==========

        let batchForecastCancelled = false;
        let batchForecastRunning = false;

        // Run batch forecast for favorites or all symbols
        async function runBatchForecast(mode) {
            if (batchForecastRunning) {
                showToast('Batch-Prognose l√§uft bereits');
                return;
            }

            const timeframe = document.getElementById('batch-timeframe').value;
            batchForecastCancelled = false;
            batchForecastRunning = true;

            // Update UI
            const btnFavorites = document.getElementById('btn-forecast-favorites');
            const btnAll = document.getElementById('btn-forecast-all');
            const btnCancel = document.getElementById('btn-cancel-batch');
            const progressContainer = document.getElementById('batch-progress-container');
            const statusSpan = document.getElementById('batch-forecast-status');

            btnFavorites.disabled = true;
            btnAll.disabled = true;
            btnCancel.style.display = 'inline-flex';
            progressContainer.style.display = 'block';

            try {
                // Get symbols to process
                let symbols = [];

                if (mode === 'favorites') {
                    statusSpan.textContent = 'Lade Favoriten...';
                    // Get favorites from models endpoint
                    const res = await fetch(`${API_BASE}/forecast/favorites`);
                    const data = await res.json();

                    // Extract unique base symbols from favorites models
                    const symbolSet = new Set();
                    if (data.models && data.models.length > 0) {
                        for (const model of data.models) {
                            let baseSymbol = model.base_symbol || model.symbol;
                            // Remove timeframe suffix if present
                            if (baseSymbol.endsWith('_M15')) baseSymbol = baseSymbol.replace('_M15', '');
                            else if (baseSymbol.endsWith('_H1')) baseSymbol = baseSymbol.replace('_H1', '');
                            else if (baseSymbol.endsWith('_D1')) baseSymbol = baseSymbol.replace('_D1', '');
                            symbolSet.add(baseSymbol);
                        }
                    }
                    symbols = Array.from(symbolSet).sort();

                    if (symbols.length === 0) {
                        showToast('Keine Favoriten gefunden');
                        return;
                    }
                } else {
                    statusSpan.textContent = 'Lade alle Symbole...';
                    // Get all symbols with trained models
                    const res = await fetch(`${API_BASE}/forecast/models`);
                    const data = await res.json();

                    const symbolSet = new Set();
                    for (const model of data) {
                        if (!model.model_exists) continue;
                        let baseSymbol = model.symbol;
                        if (baseSymbol.endsWith('_M15')) baseSymbol = baseSymbol.replace('_M15', '');
                        else if (baseSymbol.endsWith('_H1')) baseSymbol = baseSymbol.replace('_H1', '');
                        else if (baseSymbol.endsWith('_D1')) baseSymbol = baseSymbol.replace('_D1', '');
                        symbolSet.add(baseSymbol);
                    }
                    symbols = Array.from(symbolSet).sort();
                }

                statusSpan.textContent = `${mode === 'favorites' ? 'Favoriten' : 'Alle'}: ${symbols.length} Symbole`;

                // Process symbols
                let completed = 0;
                let successful = 0;
                let failed = 0;
                const total = symbols.length;
                const results = [];

                for (const symbol of symbols) {
                    if (batchForecastCancelled) {
                        showToast('Batch-Prognose abgebrochen');
                        break;
                    }

                    // Update progress
                    updateBatchProgress(completed, total, symbol);

                    try {
                        const res = await fetch(`${API_BASE}/forecast/${symbol}?timeframe=${timeframe}`);
                        const data = await res.json();

                        if (data.error) {
                            failed++;
                            results.push({ symbol, success: false, error: data.error });
                        } else {
                            successful++;
                            const trend = data.predicted_prices && data.predicted_prices.length > 1 ?
                                (data.predicted_prices[data.predicted_prices.length - 1] > data.current_price ? '‚Üë' : '‚Üì') : '-';
                            results.push({
                                symbol,
                                success: true,
                                trend,
                                currentPrice: data.current_price,
                                predictedPrice: data.predicted_prices ? data.predicted_prices[data.predicted_prices.length - 1] : null
                            });
                        }
                    } catch (err) {
                        failed++;
                        results.push({ symbol, success: false, error: err.message });
                    }

                    completed++;
                    updateBatchProgress(completed, total, completed < total ? symbols[completed] : null);
                }

                // Show final summary
                const summaryDiv = document.getElementById('batch-results-summary');
                summaryDiv.innerHTML = `
                    <strong>Fertig!</strong> ‚úì ${successful} erfolgreich, ‚úó ${failed} fehlgeschlagen
                    ${results.filter(r => r.success).map(r => `
                        <span style="margin-left: 0.5rem; color: ${r.trend === '‚Üë' ? '#4ade80' : '#f87171'};">${r.symbol} ${r.trend}</span>
                    `).join('')}
                `;

                showToast(`Batch-Prognose abgeschlossen: ${successful}/${total} erfolgreich`);

            } catch (err) {
                console.error('Batch forecast error:', err);
                showToast('Fehler bei Batch-Prognose: ' + err.message);
            } finally {
                batchForecastRunning = false;
                btnFavorites.disabled = false;
                btnAll.disabled = false;
                btnCancel.style.display = 'none';
            }
        }

        // Update batch progress UI
        function updateBatchProgress(completed, total, currentSymbol) {
            const percent = total > 0 ? Math.round((completed / total) * 100) : 0;

            document.getElementById('batch-progress-text').textContent =
                `${completed} / ${total} Symbole${currentSymbol ? ` (${currentSymbol})` : ''}`;
            document.getElementById('batch-progress-percent').textContent = `${percent}%`;
            document.getElementById('batch-progress-bar').style.width = `${percent}%`;
        }

        // Cancel batch forecast
        function cancelBatchForecast() {
            batchForecastCancelled = true;
            showToast('Batch-Prognose wird abgebrochen...');
        }

        // Run forecast
        async function runForecast() {
            const symbol = document.getElementById('forecast-symbol').value;
            const timeframe = document.getElementById('forecast-timeframe').value;

            if (!symbol) {
                showToast('Bitte w√§hle ein Symbol');
                return;
            }

            const btn = document.getElementById('btn-forecast');
            btn.disabled = true;
            btn.textContent = 'Prognose wird erstellt...';
            showToast(`Erstelle Prognose f√ºr ${symbol}/${timeframe}...`);

            try {
                const res = await fetch(`${API_BASE}/forecast/${symbol}?timeframe=${timeframe}`);
                const data = await res.json();

                if (data.error) {
                    showToast(`Fehler: ${data.error}`);
                    return;
                }

                displayForecastResults(data);
                showToast(`Prognose f√ºr ${symbol} erstellt`);

            } catch (err) {
                console.error('Forecast error:', err);
                showToast('Fehler bei der Prognose');
            } finally {
                btn.disabled = false;
                btn.textContent = 'Prognose erstellen';
            }
        }

        // Display forecast results
        function displayForecastResults(data) {
            // Show results card
            document.getElementById('forecast-results-card').style.display = 'block';

            // Update info
            const timestamp = new Date(data.forecast_timestamp);
            document.getElementById('forecast-info').textContent =
                `${data.symbol} | ${data.timeframe} | ${timestamp.toLocaleString('de-DE')}`;

            // Get current price and predicted prices
            const currentPrice = data.current_price;
            const predictedPrices = data.predicted_prices;
            const lastPrice = predictedPrices[predictedPrices.length - 1];

            // Calculate change from current price to final prediction
            const change = lastPrice - currentPrice;
            const changePercent = (change / currentPrice) * 100;
            const isBullish = change >= 0;

            // Min/Max including current price
            const allPrices = [currentPrice, ...predictedPrices];
            const minPrice = Math.min(...allPrices);
            const maxPrice = Math.max(...allPrices);

            // Update summary
            const summaryEl = document.getElementById('forecast-summary');
            summaryEl.innerHTML = `
                <div class="forecast-summary-grid">
                    <div class="summary-item">
                        <div class="value">${formatPrice(currentPrice, data.symbol)}</div>
                        <div class="label">Aktueller Preis</div>
                    </div>
                    <div class="summary-item">
                        <div class="value ${isBullish ? 'up' : 'down'}">${formatPrice(lastPrice, data.symbol)}</div>
                        <div class="label">Endpreis (${data.horizon_hours}h)</div>
                    </div>
                    <div class="summary-item">
                        <div class="value">${formatPrice(minPrice, data.symbol)}</div>
                        <div class="label">Minimum</div>
                    </div>
                    <div class="summary-item">
                        <div class="value">${formatPrice(maxPrice, data.symbol)}</div>
                        <div class="label">Maximum</div>
                    </div>
                </div>
                <div class="trend-indicator ${isBullish ? 'bullish' : 'bearish'}">
                    <span class="arrow">${isBullish ? '‚Üë' : '‚Üì'}</span>
                    <span class="text">${isBullish ? 'Bullish' : 'Bearish'}: ${changePercent >= 0 ? '+' : ''}${changePercent.toFixed(3)}%</span>
                </div>
            `;
            summaryEl.style.opacity = '1';

            // Generate time labels - start with "Jetzt" for current price
            const labels = [];
            const baseTime = new Date(data.forecast_timestamp);
            const intervalMinutes = data.timeframe === 'M15' ? 15 : (data.timeframe === 'D1' ? 1440 : 60);

            // First label is "Jetzt" (current time)
            if (data.timeframe === 'D1') {
                labels.push(baseTime.toLocaleDateString('de-DE', { day: '2-digit', month: '2-digit' }));
            } else {
                labels.push('Jetzt');
            }

            // Then add forecast time labels
            for (let i = 0; i < predictedPrices.length; i++) {
                const time = new Date(baseTime.getTime() + (i + 1) * intervalMinutes * 60000);
                if (data.timeframe === 'D1') {
                    labels.push(time.toLocaleDateString('de-DE', { day: '2-digit', month: '2-digit' }));
                } else {
                    labels.push(time.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }));
                }
            }

            // Build chart data with current price as first point
            const chartData = {
                ...data,
                // Include current price at the start
                chartPrices: [currentPrice, ...predictedPrices],
                chartConfidenceLow: [currentPrice, ...data.confidence_low],
                chartConfidenceHigh: [currentPrice, ...data.confidence_high]
            };

            // Update chart
            updateForecastChart(labels, chartData);

            // Update table - show current price first, then predictions
            const tbody = document.getElementById('forecast-tbody');
            let html = '';

            // Current price row
            html += `
                <tr style="background: rgba(59, 130, 246, 0.1);">
                    <td><strong>${labels[0]}</strong></td>
                    <td><strong>${formatPrice(currentPrice, data.symbol)}</strong></td>
                    <td style="opacity: 0.5;">-</td>
                    <td style="opacity: 0.5;">-</td>
                    <td style="opacity: 0.5;">Aktuell</td>
                </tr>
            `;

            // Predicted prices
            for (let i = 0; i < predictedPrices.length; i++) {
                const low = data.confidence_low[i];
                const high = data.confidence_high[i];
                const spread = high - low;

                html += `
                    <tr>
                        <td>${labels[i + 1]}</td>
                        <td><strong>${formatPrice(predictedPrices[i], data.symbol)}</strong></td>
                        <td style="color: #f87171;">${formatPrice(low, data.symbol)}</td>
                        <td style="color: #4ade80;">${formatPrice(high, data.symbol)}</td>
                        <td style="opacity: 0.7;">${formatPrice(spread, data.symbol)}</td>
                    </tr>
                `;
            }
            tbody.innerHTML = html;
        }

        // Format price based on symbol
        function formatPrice(price, symbol) {
            if (symbol.includes('JPY')) {
                return price.toFixed(3);
            } else if (symbol.includes('BTC') || symbol.includes('ETH')) {
                return price.toFixed(2);
            } else if (symbol.includes('XAU')) {
                return price.toFixed(2);
            } else {
                return price.toFixed(5);
            }
        }

        // Update forecast chart
        function updateForecastChart(labels, data) {
            const ctx = document.getElementById('forecastCanvas').getContext('2d');

            if (forecastChart) {
                forecastChart.destroy();
            }

            // Use chart-specific arrays that include current price at start
            const chartPrices = data.chartPrices || data.predicted_prices;
            const chartConfidenceHigh = data.chartConfidenceHigh || data.confidence_high;
            const chartConfidenceLow = data.chartConfidenceLow || data.confidence_low;

            // Create point styling - first point (current price) gets different color
            const pointBackgroundColors = chartPrices.map((_, i) => i === 0 ? '#3b82f6' : '#64c8ff');
            const pointRadii = chartPrices.map((_, i) => i === 0 ? 6 : 2);

            forecastChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Konfidenz (Hoch)',
                            data: chartConfidenceHigh,
                            borderColor: 'rgba(74, 222, 128, 0.3)',
                            backgroundColor: 'rgba(74, 222, 128, 0.1)',
                            borderWidth: 1,
                            fill: false,
                            pointRadius: 0,
                            tension: 0.3
                        },
                        {
                            label: 'Prognose',
                            data: chartPrices,
                            borderColor: '#64c8ff',
                            backgroundColor: 'rgba(100, 200, 255, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            pointRadius: pointRadii,
                            pointBackgroundColor: pointBackgroundColors,
                            pointBorderColor: pointBackgroundColors,
                            pointHoverRadius: 5,
                            tension: 0.3
                        },
                        {
                            label: 'Konfidenz (Tief)',
                            data: chartConfidenceLow,
                            borderColor: 'rgba(248, 113, 113, 0.3)',
                            backgroundColor: 'rgba(248, 113, 113, 0.1)',
                            borderWidth: 1,
                            fill: '-1',
                            pointRadius: 0,
                            tension: 0.3
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                color: '#a0a0a0',
                                font: { size: 11 }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#fff',
                            bodyColor: '#e8e8e8',
                            borderColor: 'rgba(100, 200, 255, 0.3)',
                            borderWidth: 1
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: 'rgba(255, 255, 255, 0.05)' },
                            ticks: { color: '#a0a0a0', font: { size: 10 } }
                        },
                        y: {
                            grid: { color: 'rgba(255, 255, 255, 0.05)' },
                            ticks: {
                                color: '#a0a0a0',
                                font: { size: 10 },
                                callback: function(value) {
                                    return formatPrice(value, data.symbol);
                                }
                            }
                        }
                    }
                }
            });
        }

        // Load forecast symbols on page load
        loadForecastSymbols();

        // ========== BACKUP TAB ==========
        let currentBackupData = null;
        let currentBackupFilename = null;
        let currentBackupType = null;

        // Load backup status
        async function loadBackupStatus() {
            const content = document.getElementById('backup-status-content');
            try {
                const res = await fetch(`${API_BASE}/backup/status`);
                const data = await res.json();

                content.innerHTML = `
                    <div class="stats-bar" style="margin-bottom: 1rem;">
                        <div class="stat-item">
                            <div class="stat-value">${data.models.count}</div>
                            <div class="stat-label">Modelle</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${data.models.size_mb} MB</div>
                            <div class="stat-label">Modell-Gr√∂√üe</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${data.predictions.pending_count}</div>
                            <div class="stat-label">Ausstehende Prognosen</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${data.predictions.evaluated_count}</div>
                            <div class="stat-label">Evaluierte Prognosen</div>
                        </div>
                    </div>
                    <div style="opacity: 0.7; font-size: 0.85rem;">
                        <p><strong>Modell-Pfad:</strong> ${data.models.path}</p>
                        <p><strong>Symbole mit Metriken:</strong> ${data.predictions.symbols_with_metrics}</p>
                        <p><strong>Letzte Aktualisierung:</strong> ${new Date(data.timestamp).toLocaleString('de-DE')}</p>
                    </div>
                `;
            } catch (err) {
                console.error('Failed to load backup status:', err);
                content.innerHTML = '<div style="color: #e57373;">Fehler beim Laden des Status</div>';
            }
        }

        // Backup models - direct download
        async function backupModels() {
            const btn = document.getElementById('btn-backup-models');
            btn.disabled = true;
            btn.textContent = '‚è≥ Pr√ºfe Modelle...';

            try {
                // First check if models are available
                const res = await fetch(`${API_BASE}/backup/models`, { method: 'POST' });
                const data = await res.json();

                if (data.success) {
                    showBackupResult(
                        'Modell-Backup bereit',
                        `<p>‚úÖ <strong>${data.model_count} Modelle</strong> und <strong>${data.metadata_count} Metadaten</strong> bereit</p>
                         <p>Gesch√§tzte Gr√∂√üe: <strong>${data.size_mb} MB</strong></p>
                         <p style="opacity: 0.7;">Der Download wird gestartet...</p>`,
                        false
                    );

                    // Trigger direct download
                    showToast('Download wird gestartet...');
                    const downloadLink = document.createElement('a');
                    downloadLink.href = `${API_BASE}/backup/models/download`;
                    downloadLink.download = `nhits_models_backup.zip`;
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);

                    showToast(data.message);
                } else {
                    showBackupResult('Backup fehlgeschlagen', `<p style="color: #e57373;">${data.message}</p>`, false);
                }
            } catch (err) {
                console.error('Backup failed:', err);
                showToast('Backup fehlgeschlagen: ' + err.message);
            } finally {
                btn.disabled = false;
                btn.textContent = 'üíæ Modelle sichern (ZIP)';
            }
        }

        // Backup predictions
        async function backupPredictions() {
            const btn = document.getElementById('btn-backup-predictions');
            btn.disabled = true;
            btn.textContent = '‚è≥ Erstelle Backup...';
            showToast('Erstelle Prognose-Backup...');

            try {
                const res = await fetch(`${API_BASE}/backup/predictions`, { method: 'POST' });
                const data = await res.json();

                if (data.success) {
                    currentBackupData = JSON.stringify(data.backup_data, null, 2);
                    currentBackupFilename = data.filename;
                    currentBackupType = 'predictions';

                    showBackupResult(
                        'Prognose-Backup erstellt',
                        `<p>‚úÖ Prognose-Daten gesichert:</p>
                         <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
                            <li><strong>${data.pending_count}</strong> ausstehende Prognosen</li>
                            <li><strong>${data.evaluated_count}</strong> evaluierte Prognosen</li>
                            <li><strong>${data.metrics_count}</strong> Symbol-Metriken</li>
                         </ul>
                         <p style="opacity: 0.7;">Dateiname: ${data.filename}</p>`,
                        true
                    );
                    showToast(data.message);
                } else {
                    showBackupResult('Backup fehlgeschlagen', `<p style="color: #e57373;">${data.message}</p>`, false);
                }
            } catch (err) {
                console.error('Backup failed:', err);
                showToast('Backup fehlgeschlagen: ' + err.message);
            } finally {
                btn.disabled = false;
                btn.textContent = 'üíæ Prognosen sichern (JSON)';
            }
        }

        // Show backup result
        function showBackupResult(title, content, showDownload) {
            document.getElementById('backup-result-card').style.display = 'block';
            document.getElementById('backup-result-title').textContent = title;
            document.getElementById('backup-result-content').innerHTML = content;
            document.getElementById('backup-download-btn').style.display = showDownload ? 'inline-flex' : 'none';
        }

        // Download backup
        function downloadBackup() {
            if (!currentBackupData || !currentBackupFilename) return;

            let blob;
            if (currentBackupType === 'models') {
                // Decode base64 and create blob
                const byteCharacters = atob(currentBackupData);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                blob = new Blob([byteArray], { type: 'application/zip' });
            } else {
                blob = new Blob([currentBackupData], { type: 'application/json' });
            }

            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = currentBackupFilename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showToast('Download gestartet: ' + currentBackupFilename);
        }

        // Restore models
        async function restoreModels(input) {
            if (!input.files || input.files.length === 0) return;

            const file = input.files[0];
            showToast('Stelle Modelle wieder her...');

            try {
                const formData = new FormData();
                formData.append('file', file);

                const res = await fetch(`${API_BASE}/restore/models`, {
                    method: 'POST',
                    body: formData
                });
                const data = await res.json();

                if (data.success) {
                    showBackupResult(
                        'Wiederherstellung erfolgreich',
                        `<p>‚úÖ Backup wiederhergestellt:</p>
                         <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
                            <li><strong>${data.restored_models}</strong> Modelle</li>
                            <li><strong>${data.restored_metadata}</strong> Metadaten</li>
                         </ul>`,
                        false
                    );
                    showToast(data.message);
                    loadBackupStatus();
                } else {
                    showToast('Wiederherstellung fehlgeschlagen: ' + (data.detail || 'Unbekannter Fehler'));
                }
            } catch (err) {
                console.error('Restore failed:', err);
                showToast('Wiederherstellung fehlgeschlagen: ' + err.message);
            }

            input.value = '';
        }

        // Restore predictions
        async function restorePredictions(input) {
            if (!input.files || input.files.length === 0) return;

            const file = input.files[0];
            showToast('Stelle Prognosen wieder her...');

            try {
                const formData = new FormData();
                formData.append('file', file);

                const res = await fetch(`${API_BASE}/restore/predictions`, {
                    method: 'POST',
                    body: formData
                });
                const data = await res.json();

                if (data.success) {
                    showBackupResult(
                        'Wiederherstellung erfolgreich',
                        `<p>‚úÖ Prognose-Backup wiederhergestellt:</p>
                         <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
                            <li><strong>${data.restored_pending}</strong> ausstehende Prognosen</li>
                            <li><strong>${data.restored_evaluated}</strong> evaluierte Prognosen</li>
                            <li><strong>${data.restored_metrics}</strong> Metriken</li>
                         </ul>`,
                        false
                    );
                    showToast(data.message);
                    loadBackupStatus();
                } else {
                    showToast('Wiederherstellung fehlgeschlagen: ' + (data.detail || 'Unbekannter Fehler'));
                }
            } catch (err) {
                console.error('Restore failed:', err);
                showToast('Wiederherstellung fehlgeschlagen: ' + err.message);
            }

            input.value = '';
        }

        // Clear predictions
        async function clearPredictions() {
            if (!confirm('Alle Prognose-Daten l√∂schen? Diese Aktion kann nicht r√ºckg√§ngig gemacht werden!')) {
                return;
            }

            const btn = document.getElementById('btn-clear-predictions');
            btn.disabled = true;
            btn.textContent = '‚è≥ L√∂sche...';

            try {
                const res = await fetch(`${API_BASE}/backup/predictions/clear`, { method: 'DELETE' });
                const data = await res.json();

                if (data.success) {
                    showBackupResult(
                        'Daten gel√∂scht',
                        `<p>‚úÖ Alle Prognose-Daten wurden gel√∂scht:</p>
                         <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
                            <li><strong>${data.cleared_pending}</strong> ausstehende Prognosen</li>
                            <li><strong>${data.cleared_evaluated}</strong> evaluierte Prognosen</li>
                            <li><strong>${data.cleared_metrics}</strong> Metriken</li>
                         </ul>`,
                        false
                    );
                    showToast(data.message);
                    loadBackupStatus();
                } else {
                    showToast('L√∂schen fehlgeschlagen');
                }
            } catch (err) {
                console.error('Clear failed:', err);
                showToast('L√∂schen fehlgeschlagen: ' + err.message);
            } finally {
                btn.disabled = false;
                btn.textContent = 'üóëÔ∏è Prognose-Daten l√∂schen';
            }
        }
    </script>
</body>
</html>
